<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Everyone</title>
    <url>/hello-everyone/</url>
    <content><![CDATA[<p>Say hello to every step.</p>
]]></content>
  </entry>
  <entry>
    <title>2015简生活</title>
    <url>/life/2015-life-target/</url>
    <content><![CDATA[<h1 id="欲望"><a href="#欲望" class="headerlink" title="欲望"></a>欲望</h1><p>了解自己的真实欲望，不受外在潮流的影响，不盲从，不跟风。<br>把自己的精力全部用在最迫切的欲望上，如提升专业素养，照顾家庭，关心朋友，追求美食等。</p>
<h1 id="精神"><a href="#精神" class="headerlink" title="精神"></a>精神</h1><p>了解、选择、专注于1～3项自己真正想从事的精神活动，充分学习、提高，不盲从&#x2F;浪费自己的时间与精力。</p>
<h1 id="物质"><a href="#物质" class="headerlink" title="物质"></a>物质</h1><p>将家中超过一年不用的物品丢弃、送人、出售或捐赠，如看过的杂志、书，不再穿的衣服，各种礼物或装饰品。<br>明确自己的欲望与追求，不买不需要的物品。<br>确有必要的物品，买最好的，充分使用它。<br>不囤东西，不用便宜货、次品。<br>用布袋代替塑料袋和纸袋。<br>用一支好的钢笔代替堆积如山的中性笔。<br>用瓷杯、钢杯代替纸杯。<br>用电脑写东西，少用纸，养成纸质文件扫描、存档的习惯。<br>整合、精简电源线、充电设备，不重复购买电子产品。<br>精简出门行头，只带“身手纸钥钱”。</p>
<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>精简信息输入源头，减少使用社交网络、即时通信，少看微博、朋友圈。<br>定期远离互联网，远离手机，避免信息骚扰。<br>不关注与己无关的娱乐、社会新闻。<br>精简电子邮箱数量。<br>关注少而精，时间线干净。<br>APP使用少而精删除长期不使用的应用。</p>
<h1 id="表达"><a href="#表达" class="headerlink" title="表达"></a>表达</h1><p>写东西，说话，尽可能简单、直接、清楚。<br>多用名词、动词，少用形容词、副词。</p>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>使用有效的GTD方法，不拖延。<br>及时清理电子邮件，不堆积。<br>一次只专注一件事，不做Multiple-Task。</p>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>慢生活。<br>不做无效社交。<br>锻炼。<br>穿着简洁，不花哨。<br>少吃含有添加剂的食品。<br>喝白水和纯果汁，拒绝碳酸饮料和不纯果汁。</p>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>CI工具切换，从travis.ci到Github Actions</title>
    <url>/notes/change-ci-from-travis-to-github-actions/</url>
    <content><![CDATA[<p>很久没有改博客了，今天更新了一下简历，结果travis.ci罢工了。<br>说是我的credit不够，搜了一下，有人说是它们的bug，也有report说，它不再免费支持了。<br>随手就搜了一下<a href="https://earthly.dev/blog/migrating-from-travis/">替代品</a>，一眼相中原生的Github Actions。它看起来简单又直接，搜了一下教程。</p>
<p>首先，按照<a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">Sanonz - 利用 Github Actions 自动部署 Hexo 博客</a>配置了一下，基本可用。</p>
<p>只是，在<code>hexo deploy</code>那步遇到了一些permission的问题，解决方法是：</p>
<ol>
<li>在<code>_config.yml</code>中把<code>repo</code>值从<code>http</code>改为<code>ssh</code>地址，加上hexo-deployer-git 依赖包</li>
<li>按照<a href="https://github.com/sma11black/hexo-action#step-1-setup-deploy-keys-and-secrets">sma11black&#x2F;hexo-action</a>的提示，把public key加入到目标repo的deploy key中</li>
</ol>
<p>顺便阅读了一下<a href="https://github.com/sma11black/hexo-action#step-1-setup-deploy-keys-and-secrets">sma11black&#x2F;hexo-action</a>里的其他建议：</p>
<ul>
<li>把CNAME加在了resource文件之下，这样就不用每次提交的时候在script里面加啦</li>
<li>把<code>29esther.github.io</code>改为private repo可以隐藏原文件啦，不过这一步，需要多加一个PAT，步骤在<a href="https://github.com/actions/checkout#Checkout-multiple-repos-private">这里</a></li>
</ul>
<p>一切就正常工作啦。可以把travis config删掉啦。<br>想要关掉travis的账号，结果发现travis.ci用户删除必须<a href="https://travis-ci.community/t/account-removal/13164">发邮件给他们</a>，真是太low了！<br>懒得麻烦，账号就留着吧，从github这头，能删的删删吧。</p>
]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>平均分</title>
    <url>/reading/average-score/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>作者康辉。<br>微信读书上，一个礼拜，4h30m快速翻完的一本书。按理说是不值得单篇记录的，但是，看完之后，我也手痒痒，忍不住想写点啥，说上两句。<br>以前，我是最看不上成功学书籍和名人传记的了，里面大多记录的是个人经历、感受，加上点“老人言”成功学的味道。在心底里，我觉得，成功的人不过是比别人多了一点运气，风口上飞起的猪，不也是成功么？彼之成功学，有参考价值乎？所以，对于这类书，我都是敬而远之。<br>但是，大概是从《乔布斯传》开始，我渐渐得开始喜欢上阅读这些人物故事了。心态发生了改变，我不再关注其中的“成功学”以及作者的“老人言”，而是阅读其中的故事，来了解人生百态。前两天，看到一个视频，说维度，我们皆是四维世界中的三维生物，四维生物可以穿梭时间，五维生物可以一眼看到各种选择的尽头，而六维生物可以在各个平行世界中任意窜梭……看到这里，我关掉了视频。但是，我们当然只有一种人生，体验有限，为啥不读读别人的故事，全当新增体验了！<br>后面，我也阅读过几本人生故事、人物传记，或是自述，或是代笔，或是他人的观察。但有些书籍，把人物塑造得太过完美，就缺少了真实性，比如：《奥黛丽赫本传》。<br>这本书特别好！首先，康辉的文笔很好，不咬文嚼字，卖弄文学，相反，实事求是，接地气得表达，读起来甚是有趣，描绘得惟妙惟肖。而且，康辉特别注意避免陷入“成功学”的陷阱，我觉得这是源于他对自己的有清晰的认识，也明确本书的定位，所以，并没有强升价值，给读者灌输经验。最后，这不是康辉的自传，更像是他的日记节选，所以，是很真诚的一本分享而已。<br>这本书由自序、后记和七章正文组成。<br>【光阴的故事】讲了康辉的成长经历；【在巨人的肩膀上】带读者走近央视新闻的后台，看看每天争分夺秒的故事；【硬币的另一面】说了康辉挑战春晚的经历，还有一些他的感想；【康老师】是他两次演讲的原稿；【对不起，我爱你】是写给亲人的书信；【我的孩子们】讲了他和宠物的故事；【那些风花雪月的事】说了说他在工作之余，生活中的一些兴趣爱好，和读者分享分享。<br>每一章都是精挑细选的内容，相信康老师的眼光，真都还挺好读的。【在巨人的肩膀上】一章给我开了眼界，有很多精彩的故事。</p>
<h1 id="节选"><a href="#节选" class="headerlink" title="节选"></a>节选</h1><p>（刘德华）他最好的天分就是这一股永不服输的劲头。这样平凡却又努力不平凡的人生，或许才是大多数人可参考的人生范本。世上的天才能有几个？我们大多是女娲抟土造人疲惫时随手甩出的泥点子吧？但落地为人，只要更多地投入自己的生命里，那些被精心创造出来的和那些被随手甩出的，都一样，都同样拥有给自己做主的权利。</p>
<p>（康辉在汶川地震的凌晨直播中，发生了一个最大的食物，把外国领导人向我国打开的慰问电，说成了“贺电”）我一遍遍反复检讨着为什么会出现这样的错误，熬夜时状态疲劳？困倦？直播时信息纷乱？庞杂？这些都可以是理由，但都不应该是理由，如果接受这样的理由，那就是对自己的纵容、对职业的不尊重。归根结底，问题还是出在不够专注，而这正是直播的大忌。我很感谢观众的宽容，也很感谢领导和同事们的体谅，是他们帮我一点点减轻了心理上的负担，让我能继续有机会用更认真的工作来弥补过失。但我提醒自己，无论如何，不能滥用这些宽容和体谅，否则就辜负了这些宽容和体谅。</p>
<p>我不是“播神”，也从未见过什么神。无限趋近完美的工作，只能靠每一次的认真仔细、小心翼翼一点点积累。我们是人，难免出错，但我们又不可以以此为借口而降低工作的标准。完美或许不存在，但追求完美的人应该存在。</p>
<h2 id="成长-————-2011年在厦门大学的演讲"><a href="#成长-————-2011年在厦门大学的演讲" class="headerlink" title="成长 ———— 2011年在厦门大学的演讲"></a>成长 ———— 2011年在厦门大学的演讲</h2><p>第一，成长是一个不断认识自己的过程，通过认识自己去认识这个世界。<br>第二，成长是一个逐渐学会、懂得承担责任的过程。责任可以很大，也可以很小，小到对自己负责、对家人负责，大到对社会负责。<br>成长是一个慢慢懂得什么是“尊重”的过程。学会真正尊重别人，是成长的一个非常重要的标志。这种尊重一定是完全发自内心的，而不仅仅是做出来的一种礼貌性姿态。<br>成长是一个逐渐学会质疑、不再盲从的过程。不再冲动，而认真地审慎地作出决定。当开始学会运用你的人生经历、人生经验，去判断这些究竟代表了什么，就是在成长了。<br>认识自己，承担责任，懂得尊重，学会质疑，这是我在成长过程中所体会到的非常重要的关键词。</p>
<img  src="../../../../../pics/reading/as/average-score.jpg"   width="100"><span class="image-caption">平均分</span>

]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>北京口述历史·八旗子弟的世界</title>
    <url>/reading/ba-qi-zi-di-de-shi-jie/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>来自过年期间，公众号【X博士】推荐的饺子书单。<br>推荐人是这样说的</p>
<blockquote>
<p>在我看来，这最有价值的书之一，就是亲历者直接口述。<br>这本书就是有心人访问有故事的人。<br>八位老北京，有的一辈子钻研热爱京剧，有的年轻时参加过抗日杀奸团，有的是京城名医传人。这些普通人的人生就组成了大历史。那些具体的故事我都忘了，我就记住了他们用什么态度面对大历史、大变革中的痛苦，那种心态是宽容的，你心大了，事情就显得小了。<br>看完了就感觉我更喜欢李诚儒和姜文了，他们身上就是典型的北京味道。<br>看了这本小书，您就知道，老北京人追求的生活方式是讲究，是游刃有余，是在苦难中保持乐观。<br>看了这本小书，您就知道，老北京文化并不是那帮子高血压高血脂后脑勺带褶子大早起卡口黏痰完后就啃大肘子然后话都说不清楚评价啥就会蹦俩字——地道。<br>那不叫老北京，那就叫SB。</p>
</blockquote>
<h1 id="我看到的内容"><a href="#我看到的内容" class="headerlink" title="我看到的内容"></a>我看到的内容</h1><p>全书不长，八位老人的故事都很有意思。<br>最有意思的应该是第六篇「花鸟鱼虫的世界」和第七篇「朝阳门外南营房」。<br>第六篇「花鸟鱼虫的世界」介绍了一个老玩家，玩得十分精通，有各种收藏，可以说正事没有，净琢磨这些玩的了，但是他对玩物的态度又极其认真，让人心声佩服。<br>第七篇「朝阳门外南营房」，实在是让我大涨见识，无论是书中提到的「走会」，还是辛苦又悠闲的生活方式，不要钱就好面子，没钱也要享受的那种低物欲生活，打开了生活的另一种方式。不知道现在还有没有这样的人，自得其乐。</p>
<p>其他的小知识，包括「怹」，问了一圈北京的同学，没人知道这个字了，是对他的尊称，书里有两个老人提到自己父亲的时候会用这个词，不知道现在北京人是不是不用了。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>我觉得口述历史，记录下了大时代背景下个体的生活。其实无论哪个年代，哪个人，或是平凡，或是渺小，漫长的一生都会有不少精彩的故事。但是每个人又只能活一次，所以通过别人的故事，我们可以了解很多。但是，从口述历史看大历史，稍微有一点微观看宏观的感觉，历史确实是由微观组成，但是，回忆有太多的主观因素和避重就轻，很难形成客观的历史吧。<br>不过，从这本书中，我们可以看到满汉入关，从蒙古满族，八旗弟子的角度了解一些我不知道的事情。</p>
<img  src="../../../../../pics/reading/bqzddsj/cover.PNG"   width="100"><span class="image-caption">北京口述历史·八旗子弟的世界</span>]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>半小时漫画系列</title>
    <url>/reading/ban-xiao-shi-man-hua/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>很早以前就关注了「混子曰」的公众号了，在隔壁的图书馆里欣喜地发现这一系列的书还有不少，于是借来看看。本来只想着在<a href="../../../../../books/">目录</a>里随便写写，谁知道居然这么长，于是就单独开一页来记录了。</p>
<h1 id="中国史"><a href="#中国史" class="headerlink" title="中国史"></a>中国史</h1><h2 id="半小时漫画中国史-1"><a href="#半小时漫画中国史-1" class="headerlink" title="半小时漫画中国史 1"></a>半小时漫画中国史 1</h2><p>真的用了半小时，了解一下从春秋战国到大汉王朝的历史<br><img src="../../../../../pics/reading/bxsmh/202405-1-半小时漫画中国史1.jpeg" height="150"></p>
<h2 id="半小时漫画中国史-2"><a href="#半小时漫画中国史-2" class="headerlink" title="半小时漫画中国史 2"></a>半小时漫画中国史 2</h2><p>西汉，东汉，三国，西晋，东晋<br><img src="../../../../../pics/reading/bxsmh/202406-1-半小时漫画中国史2.jpeg" height="150"></p>
<h2 id="半小时漫画中国史-3"><a href="#半小时漫画中国史-3" class="headerlink" title="半小时漫画中国史 3"></a>半小时漫画中国史 3</h2><p>南北朝，隋朝，唐朝<br><img src="../../../../../pics/reading/bxsmh/202406-2-半小时漫画中国史3.jpeg" height="150"></p>
<h2 id="半小时漫画中国史-4"><a href="#半小时漫画中国史-4" class="headerlink" title="半小时漫画中国史 4"></a>半小时漫画中国史 4</h2><p>五代十国，北宋，南宋，元朝<br><img src="../../../../../pics/reading/bxsmh/202406-3-半小时漫画中国史4.jpeg" height="150"></p>
<h2 id="半小时漫画中国史（番外篇）-中国传统节日"><a href="#半小时漫画中国史（番外篇）-中国传统节日" class="headerlink" title="半小时漫画中国史（番外篇） - 中国传统节日"></a>半小时漫画中国史（番外篇） - 中国传统节日</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li>（道教）上元 - 天官，中元 - 地官，下元 - 水官<ul>
<li>上元天官生日为正月十五，天官赐福</li>
<li>中元地官生日为七月十五，地官赦罪</li>
<li>下元水官生日为十月十五，水官救灾</li>
</ul>
</li>
<li>二十八星宿，四个片区 &#x3D; 四象<ul>
<li>东方七宿 青龙 像巨龙</li>
<li>南方七宿 朱雀 像展翅朱雀</li>
<li>西方七宿 白虎 像猛虎</li>
<li>北方七宿 玄武 像蛇与龟的合体</li>
</ul>
</li>
</ul>
<h4 id="节日"><a href="#节日" class="headerlink" title="节日"></a>节日</h4><p>春节：腊月二十三到正月十五<br>元宵节&#x2F;上元节（道教）：正月十五，灯节 &#x3D; 情人节<br>清明节：阳历4月4&#x2F;5&#x2F;6日，太阳到达黄经15°时开始， 上巳节（三月三，招魂辟邪，洗冷水澡） + 寒食节（三天：大寒食、官寒食、小寒食，吃冷饭，祭祀扫墓） + 清明（踏青游玩）<br>端午节：五月初五，五月称为毒月、恶月，粽子（祭祀供品、驱邪避毒），龙舟（伍子胥投江）<br>七夕&#x2F;乞巧节&#x2F;女儿节：七月初七，掷花针，穿七孔针，晒棉衣，雕瓜果<br>中元节：七月十五，七月阴气初生，接祖先鬼魂回家，在家里祭祀，三月阴气下降，祖先鬼魂要回墓地，所以扫墓。七月是鬼月，路边烧纸-给鬼魂引路，放河灯-给鬼魂照明<br>中秋节：八月十五，拜月仪式<br>重阳节：九月九。道教，这天清气上升，浊气下降，所以需要登高，和菊花酒，插茱萸来消灾避难长寿；民间，采摘果实，代表丰收的晒秋节；现代，九有健康长久的意思，所以称为老年节&#x2F;敬老节<br>腊八节：腊月初八。腊日节 + 佛祖成道（燃灯供佛&#x2F;腊八粥）</p>
<h4 id="节气"><a href="#节气" class="headerlink" title="节气"></a>节气</h4><p>24个仙人轮值，大概15天为周期。<br>春：<br>立春、雨水、惊蛰<br>春分、清明、谷雨<br>夏：<br>立夏、小满、芒种<br>夏至、小暑、大暑<br>秋：<br>立秋、处暑、白露<br>秋分、寒露、霜降<br>冬：<br>立冬、小雪、大雪<br>冬至、小寒、大寒</p>
<img src="../../../../../pics/reading/bxsmh/202405-2-半小时漫画中国史-节日.jpg" height="150">

<h1 id="世界史"><a href="#世界史" class="headerlink" title="世界史"></a>世界史</h1><h2 id="半小时漫画世界史-1"><a href="#半小时漫画世界史-1" class="headerlink" title="半小时漫画世界史 1"></a>半小时漫画世界史 1</h2><h3 id="欧洲"><a href="#欧洲" class="headerlink" title="欧洲"></a>欧洲</h3><h4 id="1-希腊文明"><a href="#1-希腊文明" class="headerlink" title="1. 希腊文明"></a>1. 希腊文明</h4><ul>
<li>1.0 克里特文明<br>代表国家：米诺斯</li>
<li>2.0 迈锡尼文明<br>代表事件：特洛伊战争</li>
<li>3.0 古风时代<br>代表国家：雅典，斯巴达<br>代表事件：<ul>
<li>希波战争（希腊 - 雅典，斯巴达 vs. 波斯）<ul>
<li>第一次希波战争，公元前492年，大流士，海路并进，陆军失败，海军翻船</li>
<li>第二次希波战争，公元前490年，大流士，马拉松平原，马拉松战役，斐里皮徳斯跑回雅典报捷</li>
<li>第三次希波战争，大流士儿子薛西斯，斯巴达在温泉关陆战，叛徒指路使斯巴达国王列奥尼达腹背受敌，他让希腊联军先撤，带三百名亲卫固守（斯巴达三百勇士），直到战斗到最后一人，然后薛西斯进入希腊，南下逼近雅典，雅典人去楼空，薛西斯烧城。雅典负责海战，把波斯巨舰诱入萨拉米湾，使用希腊小船获得胜利</li>
</ul>
</li>
<li>希腊内战，伯罗奔尼撒战争（雅典 vs. 斯巴达）</li>
<li>希腊统一，马其顿国王亚历山大向东征服了埃及、波斯、西亚和印度，建立了地跨欧亚非三洲的超级帝国，三十岁去世，然后，帝国分成了欧亚非三块</li>
</ul>
</li>
</ul>
<h4 id="2-罗马时代"><a href="#2-罗马时代" class="headerlink" title="2. 罗马时代"></a>2. 罗马时代</h4><ul>
<li>罗马王政：简单君主制度，帝王主导</li>
<li>罗马共和国：执政官（两个） + 元老院（几百人）<br>  恺撒：自封终身独裁官，被元老院一人一刀捅死<br>  前三头同盟：恺撒、庞培、克拉苏</li>
<li>罗马帝国：<br>  开国皇帝 - 屋大维<br>  四帝共治 - 戴克里先，帝国分为东西，分别由一对大皇帝+小皇帝管<br>  再统一 - 君士坦丁大帝</li>
<li>分裂成西罗马和东罗马：<br>  西罗马：意大利为主的欧洲片区，约一百年，被日耳曼人占领，之后进入中世纪<br>  东罗马（拜占庭）：土耳其为主的亚洲片区，存活约一千年</li>
</ul>
<h4 id="3-中世纪：西罗马灭亡到文艺复兴的一千年"><a href="#3-中世纪：西罗马灭亡到文艺复兴的一千年" class="headerlink" title="3. 中世纪：西罗马灭亡到文艺复兴的一千年"></a>3. 中世纪：西罗马灭亡到文艺复兴的一千年</h4><ul>
<li>西罗马灭亡，被日耳曼民族建立的无数个小国家取代</li>
<li>日耳曼是一个大民族，有很多分支：哥特人、法兰克人、汪达尔人、盎格鲁人、萨克逊人……</li>
<li>日耳曼人被认为是现在大部分欧洲人的祖先</li>
<li>丕平献土：丕平送梵蒂冈给教皇</li>
<li>法兰克人的法兰克王国的查理曼大帝，统一了日耳曼国家，统一了西欧，是欧洲历史上最伟大的君主之一，红桃K</li>
<li>欧洲“二统”：皇帝 + 教皇</li>
<li>查理曼大帝死后，西欧分给他的三个孩子 &#x3D; 西法兰克（法国），中法兰克（意大利），东法兰克（德国）</li>
<li>黑暗中世界景象四件套：文化全靠背经，艺术只画上帝一家亲，科技全赖村头铁匠铺，外交不断打中东</li>
</ul>
<h4 id="4-欧洲大格局"><a href="#4-欧洲大格局" class="headerlink" title="4. 欧洲大格局"></a>4. 欧洲大格局</h4><ul>
<li>东法兰克<ul>
<li>德意志，德国的雏形，有很多诸侯，各自为政</li>
<li>奥托大帝（公元960年）统一了德意志，改称罗马帝国</li>
<li>继任者扩充为 神圣罗马帝国，又叫第一帝国</li>
</ul>
</li>
<li>英法战争</li>
<li>十字军东征：西欧组团打中东，两百年，败回欧洲<ul>
<li>骑士团不属于任何国家，直接向教皇报告</li>
<li>医院骑士团：起源于耶路撒冷一家医院附近，治病救人，耶路撒冷被中东人占领后，他们退居罗德岛，又被中东人占领，退到马耳他岛，拿破仑占领马耳他岛，他们流离失所，教皇给他们在罗马租了一个office，只管救病治人搞慈善，就是马耳他骑士团，标志为马耳他十字，形状由4个“V”字组成，最初是黑底白色，13世纪中期开始普遍使用红底白色</li>
<li>圣殿骑士团：起源于耶路撒冷所罗门圣殿，法国同乡会，经营有道，富甲天下，被法国国王赶尽杀绝，白底白红十字</li>
<li>条顿骑士团：德国同乡会，被拿破仑解散，后来重新集结，总部在奥地利，分布于欧洲各地，标志为白底黑十字<img src="../../../../../pics/reading/bxsmh/logos.png" height="150"></li>
</ul>
</li>
<li>文艺复兴<ul>
<li>背景<ul>
<li>东罗马帝国被奥斯曼帝国攻占，中世纪结束</li>
<li>黑死病换走了三分之一人口</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-大锅乱炖式"><a href="#5-大锅乱炖式" class="headerlink" title="5. 大锅乱炖式"></a>5. 大锅乱炖式</h4><ul>
<li>大航海时代<ul>
<li>葡萄牙绕过非洲最南端，到达亚洲</li>
<li>西班牙哥伦布，发现新大陆 - 美洲</li>
<li>葡萄牙和西班牙先富，招来英国抢夺，英国变成欧洲一霸，号称日不落帝国</li>
<li>大开眼界，科学革命，工业革命</li>
</ul>
</li>
<li>革命</li>
<li>英国革命：君主立宪制</li>
<li>美国革命：独立</li>
<li>法国大革命：国王路易十六上断头台，终结君主制，建立革命和军事专制的共和政体</li>
<li>拿破仑时代</li>
<li>拿破仑建立法兰西第一帝国，占领整个欧洲</li>
<li>进攻俄国时，损失五十万法军</li>
<li>反法联盟二十年7次进攻，5次针对拿破仑，终于在比利时的滑铁卢取得了胜利</li>
<li>德意志逆袭</li>
<li>德意志内部分裂，以普鲁士 &amp; 奥地利为首</li>
<li>普鲁士铁血宰相俾斯麦通过战争策略和外交手段，打败奥地利，法国，统一了德意志诸邦，建立了德意志帝国，又叫第二帝国</li>
<li>同盟国：德国、奥匈帝国、意大利 vs. 协约国：英国、法国、俄国， 第一次世界大战</li>
</ul>
<h3 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h3><h4 id="1-独立"><a href="#1-独立" class="headerlink" title="1. 独立"></a>1. 独立</h4><p>哥伦布发现新大陆后，整个欧洲都来占地，美洲成了欧洲殖民地，其中最大的是英国和法国殖民地，英国在七年战争中战胜法国，确立了对北美大部分地区（现加拿大+美国）的殖民统治。<br>英国政府压榨美洲居民，以波士顿倾茶事件为导火索，英美矛盾爆发。<br>美国的“国父”，第一任总统，乔治·华盛顿，是独立战争中的关键指挥官。<br>1776年7月4日，美国独立宣言正式签，由杰斐逊起草。7月4日是美国国庆节——独立日。<br>最初的美国只有十三个州，都在东边。</p>
<h4 id="2-扩张"><a href="#2-扩张" class="headerlink" title="2. 扩张"></a>2. 扩张</h4><ol>
<li>买：（1803年）从法国买路易斯安那；（1819年）从西班牙买佛罗里达；（1845年）德克萨斯独立共和国（1836年从墨西哥独立）并入美国；（1846年）从英国手中获得了俄勒冈地区，这包括了今天的俄勒冈州、华盛顿州、爱达荷州和一部分蒙大拿州；（1848年）墨西哥割让了加利福尼亚、新墨西哥、亚利桑那等地区给美国；（1867年）从俄罗斯帝国买阿拉斯加；（1898），吞并夏威夷。</li>
<li>南北战争<br>根本原因：经济原因，南方种植园经济（奴隶主和黑奴），北方工业经济（老板和员工）。南方要出口棉花，进口生活品，希望关税低，北方怕进口商品抢生意，希望关税高。<br>过程与转折：双方僵持，拉阵营，南方稍占上风，林肯任美国总统，支持北方。南方畜养黑奴的州联合起来，号称美利坚联盟国，和北方政府的美利坚合众国，发动南北战争。1863年1月1日，林肯签署了解放宣言，无数黑奴逃到北方参军，1865年，南方联盟投降，北方大胜，奴隶制废除。林肯被枪杀。</li>
</ol>
<h4 id="3-发展"><a href="#3-发展" class="headerlink" title="3. 发展"></a>3. 发展</h4><p>第一次世界大战（1914-1918年）：美国人保持中立，两边卖武器，火上浇油，欧洲资产转移到美国，美国大赚。然后德国潜艇误伤美国船只，美国加入一战，成为战胜国，得到赔款。<br>美国富裕，大兴投资，提高产能，产能过剩，引发经济危机，1929年至1939年的大萧条。<br>第二次世界大战（1939-1945年）：轴心国：纳粹德国、意大利、日本，后来加入的还有匈牙利、罗马尼亚、保加利亚 vs. 同盟国：英国、苏联、中国、法国（战后重新加入）、美国（1941年加入）。美国战争经济，带来了就业机会和经济繁荣，同时，技术进步，发明了原子弹。</p>
<h3 id="日本"><a href="#日本" class="headerlink" title="日本"></a>日本</h3><h4 id="1-混乱时代"><a href="#1-混乱时代" class="headerlink" title="1. 混乱时代"></a>1. 混乱时代</h4><p>  代表：弥生时代、古坟时代</p>
<h4 id="2-天皇时代"><a href="#2-天皇时代" class="headerlink" title="2. 天皇时代"></a>2. 天皇时代</h4><p>  代表：飞鸟时代、奈良时代、平安时代<br>  大和平原的大和部落强大，建立了大和民族，统治者自称天皇，派遣唐使，学习了中央集权。三个朝代名称由首都所在地区分。</p>
<h4 id="3-幕府时代"><a href="#3-幕府时代" class="headerlink" title="3. 幕府时代"></a>3. 幕府时代</h4><p>  代表：镰仓幕府、室町幕府、德川幕府<br>  武士集团保护天皇，两大武士家族，发动了源平之争，源氏胜出，封为“征夷大将军”。天皇被将军架空，日本进入幕府（将军府）时代。</p>
<h4 id="4-天皇归来"><a href="#4-天皇归来" class="headerlink" title="4. 天皇归来"></a>4. 天皇归来</h4><p>  代表：明治时代<br>  明治维新，学习西方，洋为日用。</p>
<img src="../../../../../pics/reading/bxsmh/202407-2-半小时漫画世界史1.jpg" height="150">

<h2 id="半小时漫画世界史-2"><a href="#半小时漫画世界史-2" class="headerlink" title="半小时漫画世界史 2"></a>半小时漫画世界史 2</h2><h3 id="四大文明最早的：两河文明（美索不达米亚文明）"><a href="#四大文明最早的：两河文明（美索不达米亚文明）" class="headerlink" title="四大文明最早的：两河文明（美索不达米亚文明）"></a>四大文明最早的：两河文明（美索不达米亚文明）</h3><p>两河文明发源于西亚，两条流进波斯湾的河是<strong>幼发拉底河</strong>和<strong>底格里斯河</strong>，两河冲击之间的平原叫两河流域，是两河文明的发源地。北边和东边是高原，不适合种地，南边是沙漠。<br>第一波开发商：苏美尔人，苏美尔文明，基础设施建设<br>耕田种地，出现了早期的社会分工和阶级分化，还有最早的文字——楔形文字。<br>第二波开发商：闪米特人，阿卡德文明，物业管理<br>来自西边的沙漠，先后建立古巴比伦王国和新巴比伦王国。汉谟拉比国王，发行了《汉谟拉比法典》。<br>中东：西亚和东北非，包括两河流域<br>中东四强：吕底亚、米底亚、埃及和新巴比伦<br>第三波开发商：印欧人，波斯，扩建<br>来自北边的高原，波斯帝国的居鲁士二世灭了中东四强，建立了波斯帝国，统一了中东，派遣地方官员，发行货币，搞基建，修公路，同时，三次希波战争，波斯由盛转衰。亚历山大建立了亚历山大帝国，他死之后，帝国被分割，两河流域变成了塞琉古王国。帕提亚继承了波斯文明，与西边的罗马抗争，之后又被萨珊波斯取代，后被阿拉伯人灭亡，加入阿拉伯帝国。</p>
<h3 id="印度"><a href="#印度" class="headerlink" title="印度"></a>印度</h3><p>古印度约等于巴基斯坦 + 尼泊尔 + 印度 + 孟加拉国<br>印度在亚欧大陆南边。外围：北面是三条大山脉（兴都库什山脉，苏莱曼山脉，喜马拉雅山脉），南面都是水，但是兴都库什山脉和苏莱曼山脉交汇处有缺口，开伯尔山口，正对西方，所以，西方人入侵。内部：北方平原，有印度河和恒河，南方是德干高原，易守难攻，所以古印度没有统一。<br>印度文明最早发源于印度河附近，哈拉帕文明，达罗毗荼人<br>第一波冲击：雅利安人，从开伯尔山口进入，征服了达罗毗荼人，从印度河流域，发展到恒河流域，称霸北方，达罗毗荼人逃到南方。<br>第二波冲击：波斯人，波斯帝国的扩张。<br>第三波冲击：希腊人，被压力善待占了一部分。<br>印度人接盘：摩揭陀人旃陀罗笈多·孔雀起义，把希腊人赶走了，建立了孔雀帝国。孙子阿育王，用战争把孔雀帝国推上了兴盛的顶点。后来，他大力推广佛教，把释伽牟尼的舍利送到世界各个角落。<br>第四波冲击：西域大月氏，被匈奴欺压，举国搬迁到了印度，改为贵霜帝国。<br>印度人又接盘：摩揭陀人旃陀罗·笈多一世，统一了大部分印度，建立了笈多帝国，在超日王死后分裂，戒日王重新统一了北印度，建立了戒日帝国。戒日王时代短暂，死后印度又土崩瓦解。<br>第五波冲击：突厥人，建立了德里苏丹国，首都在德里，国家首领叫苏丹。统治了印度三百年，主要成就：1. 改变印度人宗教信仰；2. 打败蒙古。<br>第六波冲击：蒙古人，帖木儿反抗蒙古帝国时，建立了帖木儿帝国，他的后代巴布尔进入印度，成立了莫卧儿帝国。<br>第七波冲击：欧洲人。葡萄牙人最早，建立了果阿等殖民地；随后荷兰人也在印度设立了贸易据点；英国人则通过建立多个重要的贸易和行政中心，如马德拉斯、加尔各答和孟买，逐步扩大了他们在印度的影响力，并最终在19世纪确立了对整个印度的殖民统治。1857年印度民族大起义失败，英国正式统治印度，以新德里为首都。<br>印度觉醒：印度国民大会党（国大党）反抗殖民，1947年印度独立，同时印巴分治。国大党以印度教徒为主，穆斯林建立了穆斯林联盟，领袖是穆罕默德·阿里·真纳。国大党地盘印度斯坦，穆斯林地盘巴基斯坦。<br>番外：种姓制，雅利安人的统治管理手段</p>
<ol>
<li>婆罗门 - 雅利安人，大神（原人）的嘴，僧侣贵族，主管宗教</li>
<li>刹帝利 - 雅利安人，大神（原人）的手臂，军政贵族，主管军政</li>
<li>吠舍 - 雅利安人，大神（原人）的腿，一般百姓，从事工商业</li>
<li>首陀罗 - 达罗毗荼人，大神（原人）的脚，佣人和工匠</li>
<li>达利特 - 不可接触者（贱民），挑大粪</li>
</ol>
<h3 id="古埃及"><a href="#古埃及" class="headerlink" title="古埃及"></a>古埃及</h3><p>有很多的王朝，纳尔迈统一了埃及，中央集权，然后分裂，然后统一，然后分裂，然后外族统治。</p>
<ol>
<li>喜克索斯人从西亚进入，控制了埃及北部，建立了喜克索斯王朝。南面是古埃及人。对峙多年，古埃及人重新统一了古埃及，建立了埃及第十八王朝，进入全盛时期。</li>
<li>南边的努比亚人在古埃及又分裂后进入，把分裂的古埃及统一了，建立了努比亚王朝，被古埃及人推翻。</li>
<li>波斯人占领了埃及，被古埃及人反抗，波斯人又入侵，直到亚历山大灭波斯</li>
<li>希腊人亚历山大进入埃及，并建立亚历山大港为政治中心。亚历山大死后，埃及总督托勒密建立了古埃及最后一个王朝：托勒密王朝，引入希腊文明，古埃及进入希腊化时期</li>
<li>罗马人控制了埃及。后来屋大维打败了安东尼和埃及艳后，古埃及彻底变成了罗马帝国的一部分。</li>
</ol>
<h3 id="俄国"><a href="#俄国" class="headerlink" title="俄国"></a>俄国</h3><h4 id="1-部落时代"><a href="#1-部落时代" class="headerlink" title="1. 部落时代"></a>1. 部落时代</h4><p>斯拉夫人在欧洲中部，不团结，按区域分成了西斯拉夫人，南斯拉夫人，东斯拉夫人</p>
<h4 id="2-基辅罗斯"><a href="#2-基辅罗斯" class="headerlink" title="2. 基辅罗斯"></a>2. 基辅罗斯</h4><p>北方部落强大，建立了大城市诺夫哥罗德，位于善于经商的北欧人和希腊中间。留里克为首的北欧瓦良格人受邀前来统治，并建立起了一个国家罗斯，其继承人奥列格进一步扩展了领土，将基辅作首都，国名基辅罗斯。后来，统治者弗拉基米尔推广了东罗马帝国的希腊正教作为国教，成为后来的东正教。他的儿子智者死后，国家分裂成多个公国。</p>
<h4 id="3-被殖民"><a href="#3-被殖民" class="headerlink" title="3. 被殖民"></a>3. 被殖民</h4><p>蒙古入侵</p>
<h4 id="4-莫斯科公国"><a href="#4-莫斯科公国" class="headerlink" title="4. 莫斯科公国"></a>4. 莫斯科公国</h4><p>反抗蒙古，合并其他公国，伊凡三世赶走了蒙古人，建立以莫斯科为首都的莫斯科公国，伊凡三世娶了东罗马帝国的末代公主，成为了罗马帝国、东罗马帝国之后的第三罗马，继承了欧洲正统。伊凡三世的孙子伊凡四世确认了君主专制，称沙皇，国家改为沙皇俄国，同时他削弱权贵，加强王权。<br>从基辅罗斯到沙皇俄国伊凡四世，统治者都是北欧人留里克的后代，所以又称留里克王朝。</p>
<h4 id="5-罗曼诺夫王朝"><a href="#5-罗曼诺夫王朝" class="headerlink" title="5. 罗曼诺夫王朝"></a>5. 罗曼诺夫王朝</h4><p>在1613年，罗曼诺夫被选为沙皇，结束了俄国的“混乱时期”，进入罗曼诺夫王朝。其孙子彼得大帝是俄国史上最伟大的沙皇，进行军事、行政、经济和文化改革，迁都圣彼得堡。之后，叶卡捷琳娜大帝通过宫廷政变上台，进行领土扩张，吞并克里米亚和波兰的一部分和文化发展。亚历山大二世在1861年，解放农奴制，使俄罗斯进入了现代化进程。第一次世界大战的失败，1917年爆发了二月革命，最后一位沙皇尼古拉二世被迫退位，罗曼诺夫王朝宣告结束。</p>
<h4 id="6-苏联时代"><a href="#6-苏联时代" class="headerlink" title="6. 苏联时代"></a>6. 苏联时代</h4><p>1917年10月，布尔什维克党在列宁和托洛茨基的领导下发动了十月革命，推翻了临时政府。俄罗斯内战之后，1922年布尔什维克党建立了以工农苏维埃（苏维埃政权）为基础的新政府苏维埃社会主义共和国联盟（苏联），宣布退出第一次世界大战。然后，苏联发展重工业，斯大林模式，从中央统一下令，地方照办，集中力量发展国力。斯大林在二战中领导苏联，成为世界两大超级大国之一。第二次世界大战后，苏联和美国开始了长达数十年的冷战对抗（1947年-1991年）。美国和西欧组成了北大西洋公约组织，苏联和东欧组成了华沙条约组织，苏联在古巴部署导弹，引发古巴导弹危机。1991年12月25日苏联解体，15个加盟共和国宣布独立。</p>
<img src="../../../../../pics/reading/bxsmh/202407-1-半小时漫画世界史2.jpeg" height="150">

<h1 id="科学史"><a href="#科学史" class="headerlink" title="科学史"></a>科学史</h1><h2 id="半小时漫画科学史-1"><a href="#半小时漫画科学史-1" class="headerlink" title="半小时漫画科学史 1"></a>半小时漫画科学史 1</h2><h4 id="文明的诞生"><a href="#文明的诞生" class="headerlink" title="文明的诞生"></a>文明的诞生</h4><ul>
<li>大河文化：平原、气候良好、河流水源。农耕稳定。四大文明：古埃及、古巴比伦、古印度、中国。</li>
<li>希腊：山多 -&gt; 城邦 -&gt; 自由；出海 -&gt; 思想开放、凶残；临近古埃及和古巴比伦 -&gt; 继承科学遗产，天文、历法和数学；经商 -&gt; 平等<ul>
<li>民主制度，公民大会，主要指雅典制度，希腊也有斯巴达的寡头政治）</li>
<li>奴隶和奴隶主</li>
<li>追求真理，了解自然哲学</li>
</ul>
</li>
</ul>
<h4 id="自然哲学的两个终极问题"><a href="#自然哲学的两个终极问题" class="headerlink" title="自然哲学的两个终极问题"></a>自然哲学的两个终极问题</h4><ol>
<li>世界上最小的东西是啥</li>
<li>泰勒斯 - 哲学与科学之父：万物的本原是水 -&gt; 万物源于水，水孕育了生命。同时，古希腊哲学的四大门派认为：<br>* 米利都学派：泰勒斯：万物的本原是水<br>* 毕达哥拉斯学派：毕达哥拉斯：万物的本原是数<br>* 埃利亚学派：巴门尼德：万物的本原是存在<br>* 爱非斯学派：赫拉克利特：万物的本原是逻各斯</li>
<li>德谟克里特<br>   他的老师留基伯认为：万物的本原是原子（原子论1.0），德谟克里特在此基础上提出：万物的本原是原子 + 虚空 -&gt; 原子是不可再分的，在虚空中运动，构成了万物</li>
<li>亚里士多德：土、水、火、气、以太。月亮上面的世界是以太构成的，月球以下，包括地球，都是由水、火、土、气构成的。气和火轻，飘在大地上方、月球下方；土和水重，朝地心下落，构成大地；气和火外面是其他天体，由以太组成。</li>
<li>世界上最大的东西是啥</li>
<li>毕达哥拉斯：大地是圆的<br>逻辑：1. 大地是三维的；2. 三维世界有球形；3.三维世界里球形最完美；4. 大地也是完美的 -&gt; 大地是圆的，宇宙也是圆的<br>“崇尚完美”<br>柏拉图提出天体运动是完美的匀速圆周运动，但是理论和观测不相符，所以，他发起拯救现象。</li>
<li>欧多克斯：同心球叠加模型，地心说1.0<br>内容：1. 地球是宇宙的中心，且静止不动；2. 地球外套着球面A，球面A与地球同心，且同心球自身绕轴旋转；3. 天体沿同心球的赤道运动。<br>扩展：大概有27个同心球嵌套</li>
<li>亚里士多德：水晶球模型，地心说2.0<br>基础：证明大地是球形的：1. 夜晚朝着北极星一直走，前方会出现新的星星，而后方的星星会消失；2. 大海里的帆船，靠近时会先出现船帆，后出现船身，离去时，船身先消失；3. 月食时，大地投在月亮上的影子是弓形的。<br>内容：同心球数量为49个，最外层存在一个恒星天球，所有天球都是由水晶制成的，并由一系列的天使推动运动，加入了天使推动的天体运动机制，包含了天体运动和宇宙结构的完整解释</li>
<li>托勒密：地心说3.0，终极版本<br>步骤：1. 大量学习前人理论，并进行系统性总结；2. 加入自己想法，并根据实际观测结果不断校正理论；3. 提出系统的地心说模型，出版巨著《天文学大成》&#x2F;《至大论》。<br>特点：引入大量数学方法论证</li>
</ol>
<p>西方哲学（代表人物：泰勒斯，亚里士多德） -&gt; 自然哲学（牛顿） -&gt; 科学（法拉第）<br>                                  -&gt; 形而上学（黑格尔）</p>
<h4 id="人物八卦"><a href="#人物八卦" class="headerlink" title="人物八卦"></a>人物八卦</h4><ol>
<li>师徒关系：苏格拉底（古希腊大哲学家） -&gt; 柏拉图（古希腊大哲学家，创立柏拉图学园） -&gt; 亚里士多德（创立逍遥学派） -&gt; 亚历山大（横扫欧亚非大陆，建立亚历山大帝国）</li>
<li>毕达哥拉斯是数学的宗师，证明了黄金分割，勾股定理 -&gt; 有理数危机</li>
<li>欧几里得 - 几何之父，毕业于柏拉图学园，著有《几何原本》。书中用到了公理化方法：首先，有23条最近基本的定义：点、线、面、圆、角……；然后，5条公设：点到点可作一条直线；从定义和公设出发，可推理演绎结论，如：三角形内角和为180度。</li>
<li>阿基米德 - 力学奠基人，1. 浮力定理；2. 制造武器；3. 杠杆原理；4. 算出圆周率</li>
<li>花刺子米 - 代数之父：阿拉伯人，智慧宫，建立了代数学。</li>
</ol>
<h4 id="大学与文艺复兴"><a href="#大学与文艺复兴" class="headerlink" title="大学与文艺复兴"></a>大学与文艺复兴</h4><ol>
<li>11世纪，欧洲的黑暗时代，意大利诞生了第一所大学：博洛尼亚大学。后建立了巴黎大学、牛津大学、剑桥大学……</li>
<li>牛津大学的第一任校长：格罗斯泰斯特提出教学大纲，系统化学习</li>
<li>牛津大学的老师罗杰·培根，实验科学</li>
<li>人才+场所+自然哲学（科学的基础） -&gt; 文艺复兴，文艺复兴的发源地是佛罗伦萨，由美第奇家族赞助。</li>
<li>文艺复兴著名人物：</li>
</ol>
<ul>
<li>但丁，《神曲》，“文艺复兴的先驱”或“文艺复兴的开创者”</li>
<li>文艺复兴三杰：达·芬奇，在绘画、雕塑、建筑、音乐、科学等领域都有所建树，热爱做实验，还研究过飞行器，设计各种机械装置。米开朗琪罗-雕塑。拉斐尔-绘画。</li>
<li>笛卡儿：理：直角坐标系，实现了代数和几何的相互转换；文：我思故我在。</li>
<li>惠更斯：光的波动说</li>
<li>哈维：血液循环理论</li>
<li>弗朗西斯·培根：实验科学，近代归纳法的创始人</li>
</ul>
<h4 id="哥白尼革命-把宇宙的中心从地球转移到了太阳"><a href="#哥白尼革命-把宇宙的中心从地球转移到了太阳" class="headerlink" title="哥白尼革命 - 把宇宙的中心从地球转移到了太阳"></a>哥白尼革命 - 把宇宙的中心从地球转移到了太阳</h4><ol>
<li>哥白尼建立了全新的日心说模型，并写了《天体运行论》，基于长年累月的观测和数学计算。但是，有三个问题没有解决：1. 地动抛物：如果地球会动，为什么人起跳会落在原地；2. 恒星基本不变：如果地球在动，星空应该发生变化，与观测的不同；3. 准确度不够：没有准确描述天体运动。</li>
<li>布鲁诺 - 科学的殉道者：积极宣传了哥白尼的日心说，发展出自己的宇宙观：宇宙是无限的，其中存在着无数个太阳系和地球。</li>
<li>伽利略 - 现代科学的祖师爷</li>
</ol>
<ul>
<li>萨尔维阿蒂大船假设 -&gt; 自然本性（惯性） -&gt; 解决了地动抛物</li>
<li>斜面实验 -&gt; 摩擦力</li>
<li>望远镜 -&gt; 月球表面有环形山，不是完美光滑的；木星有四颗卫星 -&gt; 挑战了“完美”的地心说</li>
<li>著书《关于托勒密和哥白尼两大世界体系的对话》（简称《对话》）</li>
<li>著书《关于两门新科学的对话》，总结了材料强度、动力学的相关知识及力学原理</li>
<li>长期观察太阳，晚年失明</li>
</ul>
<ol start="4">
<li>第谷 - 天文学奠基人：拥有详细、精确的天文数据，观测了超新星爆炸和彗星</li>
</ol>
<ul>
<li>超新星爆炸 -&gt; 恒星演化，周年视差是有的 -&gt; 宇宙不是完美不变的</li>
<li>彗星 -&gt; 第谷证明了彗星不是大气现象，是星体 -&gt; 彗星的轨迹也不是匀速圆周运动</li>
</ul>
<ol start="5">
<li>开普勒 - 天空立法者、天文学家：以日心说为基本框架，几何学做工具，进行数据分析</li>
</ol>
<ul>
<li>开普勒第二定律：一颗行星在同样的时间内相对于太阳扫过的面积是一样的</li>
<li>开普勒第一定律：行星沿椭圆轨道绕太阳运动，太阳处在椭圆两个焦点的其中一个上</li>
<li>开普勒第三定律：所有的行星轨道的半长轴的三次方，和它绕太阳转一圈的时间的平方的比值，都是相等的</li>
</ul>
<ol start="6">
<li>牛顿</li>
</ol>
<ul>
<li>广义二项式定理，发明了流数（微积分），研究万有引力定律及光学</li>
<li>发明了反射式望远镜，提出了系统的光学理论</li>
<li>万有引力定律：F &#x3D; G * (m1 * m2) &#x2F; r^2，F 是两个物体之间的万有引力，单位是牛顿（N），G 是万有引力常数，其值为 6.67430 × 10^-11 N·m^2&#x2F;kg^2；m1 和 m2 是两个物体的质量，单位是千克（kg）；r 是两个物体之间的距离，单位是米（m）</li>
<li>牛顿用微积分详细论证了在平方反比的万有引力下，行星的运行轨道为椭圆形，并出版了《自然哲学的数学原理》（《原理》）</li>
</ul>
<h4 id="牛顿革命-请上帝离开"><a href="#牛顿革命-请上帝离开" class="headerlink" title="牛顿革命 - 请上帝离开"></a>牛顿革命 - 请上帝离开</h4><p>牛顿三大定律和万有引力定律，实现了宇宙和地球上物理学的统一，形成了一套新的世界观 -&gt; 可以自行转动，不需要上帝存在</p>
<p>科学史上的两个奇迹年：1666牛顿奇迹年，1905爱因斯坦奇迹年</p>
<img src="../../../../../pics/reading/bxsmh/202405-3-半小时漫画科学史1.jpg" height="150">

<h1 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h1><h2 id="半小时漫画唐诗"><a href="#半小时漫画唐诗" class="headerlink" title="半小时漫画唐诗"></a>半小时漫画唐诗</h2><p>风雅颂<br>诗经 楚辞<br>国风 离骚<br>四言 -&gt; 五言 -&gt; 七言<br>唐朝以前，古体诗，唐朝之后，格律诗：平仄、押韵、对仗<br>初唐：王绩————朴实、初唐四杰（王勃、杨炯、卢照邻、骆宾王）————开拓了诗歌题材、陈子昂————复古，学习汉魏诗歌、张若虚————集大成者，《春江花月夜》孤篇盖全唐<br>盛唐：贺知章、张九龄、高适————边塞诗派代表，带刀诗人、王昌龄————边塞诗派代表，七绝圣手、岑参————边塞诗派代表、孟浩然————山水田园诗派代表，仕隐双失、王维————山水田园诗派代表，诗佛，仕隐双得、李白————诗仙、杜甫————诗圣<br>中唐：白居易、韩愈、李贺<br>晚唐：李商隐、杜牧、温庭筠<br><img src="../../../../../pics/reading/bxsmh/202112-1-TangShi.jpg" height="150"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="半小时漫画预防常见病"><a href="#半小时漫画预防常见病" class="headerlink" title="半小时漫画预防常见病"></a>半小时漫画预防常见病</h2><img src="../../../../../pics/reading/bxsmh/202407-3-半小时漫画预防常见病.jpg" height="150">

<h2 id="半小时漫画经济学"><a href="#半小时漫画经济学" class="headerlink" title="半小时漫画经济学"></a>半小时漫画经济学</h2><img src="../../../../../pics/reading/bxsmh/202407-4-半小时漫画经济学.jpg" height="150">]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>Everything I Never Told You</title>
    <url>/reading/everything-i-never-told-you/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>几个月后，终于又打开了书，感谢shuxian的督促。<br>这次看的是一本小说，看的时候，不禁问自己，看小说究竟和看电视剧有什么区别？以前人看小说，就和现在的人看电视剧似的，都是不务正业。</p>
<h1 id="流水观后感"><a href="#流水观后感" class="headerlink" title="流水观后感"></a>流水观后感</h1><p>观后感就和封面上说的一样，我们终此一生，就是要摆脱他人的期待，找到真正的自己。<br>幸好我的父母没啥梦想，我的人生浑浑噩噩都是我的选择。<br>作者是一个华裔，书里面牵扯到了种族歧视、婚姻伦理，性别取向等等，而且放在了一个很古老的时代。小说叙事很平淡，抽丝剥茧得描述整个事件。没有一个人是坏人，每一个人都很无奈，但当事件发生，没有一个人是无辜的。<br>但是，现在的我们还是有一样的问题，会把自己的期待，放到别人身上；也常常一厢情愿地把别人因为种种原因（可能是爱）而做出的妥协当作他们的意愿。尊重个体，也要尊重自我，对自己诚实一点。</p>
<img  src="../../../../../pics/reading/einty/everything-i-never-told-you.jpg"   width="100"><span class="image-caption">无声告白</span>

<h1 id="See-you-next-book"><a href="#See-you-next-book" class="headerlink" title="See you next book!"></a>See you next book!</h1>]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>蛤蟆先生去看心理医生</title>
    <url>/reading/ha-ma-xian-sheng-qu-kan-xin-li-yi-sheng/</url>
    <content><![CDATA[<img src="../../../../../pics/reading/hmxsqkxlys/title.webp" width="150">

<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>这是一本很有名的书，在各大榜单上排名都很高。<br>确实是一本阅读不费力，却又可以收获一些知识的，介于小说和科普之间的一本故事书。<br>借一个蛤蟆先生和心理医生苍鹭的对话，带我们一窥心理学的知识，给我们一些思维方向。</p>
<h1 id="精华提炼"><a href="#精华提炼" class="headerlink" title="精华提炼"></a>精华提炼</h1><ol>
<li>我们人生常处于三种状态，儿童自我状态、父母自我状态以及成人自我状态。在儿童自我状态中，我们会受童年影响，表现得像一个孩子，而在父母状态下，我们会模仿父母的行为，只有在成人自我状态下，我们才能拥有理性思考，做出正确的判断和行为。<br><img  src="/../../../../../pics/reading/hmxsqkxlys/%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.jpg"  ><span class="image-caption">三种状态</span></li>
<li>人生坐标，基于以上三种状态的影响，我们会把自己放在不同的定位中，把人生变成一个“自证预言”。由此，我们更加应该把自己放在“我好；你也好”的状态下，相信自己，相信别人。<br><img  src="/../../../../../pics/reading/hmxsqkxlys/%E4%BA%BA%E7%94%9F%E5%9D%90%E6%A0%87.jpg"  ><span class="image-caption">人生坐标</span></li>
</ol>
<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><h2 id="第四章-抑郁的原因"><a href="#第四章-抑郁的原因" class="headerlink" title="第四章 抑郁的原因"></a>第四章 抑郁的原因</h2><blockquote>
<p>必须完成的事情，唯有靠他自己才能完成。蛤蟆越来越清楚地认识到，他最好尽快“长大成人”。</p>
</blockquote>
<p>心理医生或是其他的外界帮助，只能是我们解决问题的辅助、工具，想要解决问题，还是得靠自己，可以咨询、求助他人，但万万不可依赖别人。</p>
<blockquote>
<p>和许多人一样，他从未有意识地用这样的方式来看待过自己的情绪，所以很难用语言来形容，更别提对别人说了。实际上，他已经下意识地运用了很多行为上的策略，成功地逃避了对自我的认识。</p>
</blockquote>
<p>对自我的认识非常重要。我们都是自己世界里的主角，活着不是为了取悦他人，所以要时常认真体会自己真实的感觉，依此来调节行为和方向，走向幸福人生。</p>
<blockquote>
<p>你要不要为自己做决定，我说了不算。蛤蟆，你自己想要做什么？</p>
</blockquote>
<blockquote>
<p>他并不习惯沉浸在专注的思考中，但在咨询师一再的询问之下，他还是在脑海里一一回顾了那些不快的情形，思索着能从每件事情中学到什么普遍的道理。</p>
</blockquote>
<h2 id="第五章-成长的寓言"><a href="#第五章-成长的寓言" class="headerlink" title="第五章 成长的寓言"></a>第五章 成长的寓言</h2><blockquote>
<p>“儿童自我状态”，是由我们童年残留的遗迹搭建而成，包含我们小时候体验过的所有情感。你一定知道在刚出生时，我们只具备几种最基本的情感。幼年时，这些基本情感逐渐发展演变成更微妙、更复杂的行为模式，这些行为模式成为自我的核心，融为我们自身的一部分，定义了我们一生的行为。正因为这样，某些特定的情形和场景会激发我们的基本行为模式，让我们自动做出反应，所以我们会和小时候一样去行动和感受。具体的情形和场景因人而异。</p>
</blockquote>
<blockquote>
<p>儿童的基本情感：快乐和深情、愤怒、悲伤、恐惧</p>
</blockquote>
<p>如果你觉得你缺少某一种情感，或者你的某一种情感特别弱，不常流露，那么你需要探究一下各种的原因，往往是因为后天的影响——“某些“顺从行为导致了你无意识中的隐藏。基本情感是不会消失的，而会转化成其他的行为。</p>
<blockquote>
<p>所有的儿童基本情感加在一起，构成了所谓“自然型儿童”。</p>
</blockquote>
<h2 id="第六章-探索童年"><a href="#第六章-探索童年" class="headerlink" title="第六章 探索童年"></a>第六章 探索童年</h2><blockquote>
<p>但我们现在讨论的就是‘小题大做’的事件。一个简单的提问，便能引发许多其他重要的问题，这些问题对你的学习和领悟作用很大，也因此会对你的整个人生有深远的影响。</p>
</blockquote>
<p>对于童年的记忆，要“小题大做”的探究其影响，它可能在潜移默化中暗示了你选择的原因，也是决定了你将来必然的成功&#x2F;失败。</p>
<blockquote>
<p>成长的本质就是要减少并最终打破这样的依赖关系，这样才能成为一个独立自主的人。而顺从行为可能导致有些人学会了把依赖当成生活方式。换句话说，这些人永远都没有真正长大成人。</p>
</blockquote>
<h2 id="第七章-愤怒的表现"><a href="#第七章-愤怒的表现" class="headerlink" title="第七章 愤怒的表现"></a>第七章 愤怒的表现</h2><blockquote>
<p>就像所有好问题一样，答案会让你产生痛苦的自我觉察。</p>
</blockquote>
<blockquote>
<p>怄气的人是总绷着脸、阴沉沉的样子，而且安静得很反常。蛤蟆，在我看来，“适应型儿童”的所有行为里，怄气是最能说明怎样用时间来稀释愤怒的例子。通常这是孩子在权威之下无法随心所欲才做出的反应。成年人或许会因为输掉一场权力斗争而生闷气，也是同样道理。说白了，怄气是输家在对强大的赢家做出反应。</p>
</blockquote>
<p>怄气是愤怒的一种转化，因为无法随心所欲，所以产生的一种缓慢释放压力，降低愤怒的行为。</p>
<blockquote>
<p>当成年人怄气、撒泼、郁闷或是厌烦的时候，我们会想他们究竟是行为不当，还是在无意识或无法控制地重演童年的行为模式。这类行为会导致两个后果，都是负面的。第一个就是会被人嘲笑。看到一个成年人撒泼怄气是件蛮好笑的事情，但也让人尴尬。而更严重的后果是，这类行为告诉别人，这人是个失败者。</p>
</blockquote>
<h2 id="第八章-意外访客"><a href="#第八章-意外访客" class="headerlink" title="第八章 意外访客"></a>第八章 意外访客</h2><blockquote>
<p>要明白，世界还在继续运转，不会因为你情绪不好就停下来。</p>
</blockquote>
<p>这是一个残忍的<strong>事实</strong>。</p>
<h2 id="第九章-秘密协议"><a href="#第九章-秘密协议" class="headerlink" title="第九章 秘密协议"></a>第九章 秘密协议</h2><blockquote>
<p>越是能帮助你深入自我的概念，也越容易引发激烈的阻抗。因为这些概念最容易打破我们的心理平衡，它们最有可能带你走向深层的蜕变，而这个过程往往是痛苦的。我们看到的自己，并不一定总是我们喜欢的样子。从当下的你，变成你想成为的自己，必定要经历行为和态度的转变，需要付出艰辛的努力，需要勇气和决心。</p>
</blockquote>
<blockquote>
<p>我们绝不是父母的翻版。虽然父母对我们影响极大，但每个人自身的独特性确保了我们不是父亲或母亲的复制品，而是独立的个体。</p>
</blockquote>
<blockquote>
<p>困惑是学习过程的第一阶段，这说明固有知识的局限开始被打破了。你要直面新的信息，这些新的信息会挑战你现有的观念和行为模式。由此产生的焦虑是让你改变的动力，很可能也会开启你的创造力。</p>
</blockquote>
<blockquote>
<p>没有一种批判比自我批判更强烈，也没有一个法官比我们自己更严苛。我们会严厉地惩罚，包括折磨自己，在极端案例里，甚至会施以极刑。但问题是，即便对自己轻判，这种谴责和惩罚也可能伴随一生，变成无期徒刑。</p>
</blockquote>
<blockquote>
<p>能帮你的人是你自己，也只有你自己。有许多问题需要你向自己发问。比如你能停止自我批判吗？你能对自己好一些吗？也许最重要的问题是，你能开始爱自己吗？</p>
</blockquote>
<h2 id="第十一章-蛤蟆先生的选择"><a href="#第十一章-蛤蟆先生的选择" class="headerlink" title="第十一章 蛤蟆先生的选择"></a>第十一章 蛤蟆先生的选择</h2><blockquote>
<p>只有在“成人自我状态”里，才能学到关于自我的新知识，才能思考当下的事情，评估自己的行为，或者倾听别人对你的看法而不马上驳斥，当然这一点很难做到。</p>
</blockquote>
<blockquote>
<p>在“儿童状态”时，你会体验到童年的感受，好的坏的都有。你会再现过去的情形，再次体验过去的情绪，可你学不到任何新的东西。</p>
</blockquote>
<blockquote>
<p>当你处在‘父母状态’时，基本上你不是在挑剔就是在教育别人。不管是哪种，你都在用言行重复从父母那里学来的观念和价值观，你会想证明给别人看，让别人接受你的观念和价值观。这种确信无疑的状态，就没法给新知识和新理念留出一席之地。旧的思想主宰着你，这就是为什么单靠争论不能改变一个人的想法，只会让人更固执己见。</p>
</blockquote>
<blockquote>
<p>没人能强迫别人进入他们的“成人状态”。这个过程需要艰辛的努力和刻意的思考。我们在另外两种状态时，像父母或儿童一样行事，几乎不需要去思考，因为我们知道要做什么、说什么，就好像在演戏一样。</p>
</blockquote>
<blockquote>
<p>没有人能“让”我们产生什么感受，除非他们用蛮力胁迫你。说到底，是我们“选择”了自己的感受。我们“选择”了愤怒，我们“选择”了悲伤。</p>
</blockquote>
<blockquote>
<p>情绪化的行为也有条件反射。以往的经历教会我们在相似情境下不经大脑就能自动做出反应，我们无法避免这种反应。</p>
</blockquote>
<blockquote>
<p>你还要为自己的不快乐责怪别人多久？</p>
</blockquote>
<blockquote>
<p>责怪是人处在“儿童自我状态”里做的事情。但一个处在“成人自我状态”的人，可能会有怎样恰当的做法呢？</p>
</blockquote>
<blockquote>
<p>相比责怪，负起责任听着如何？</p>
</blockquote>
<blockquote>
<p>为自己的行为，包括自己的情绪，负责。这才是成年人会做的事情。毫无疑问，这很难，但相比于责怪别人，它还真有个天大的好处，就是，你能开始对此行动了。如果你为自己负责，就会认识到你对自己是有自主权的。因此你就知道自己有力量来改变处境，更重要的是，有力量改变你自己。</p>
</blockquote>
<p>这个非常重要。它让我们意识到，我们是能够摆脱童年和父母的影响，改变自己，掌握人生的方向。</p>
<h2 id="第十二章-说出人生故事"><a href="#第十二章-说出人生故事" class="headerlink" title="第十二章 说出人生故事"></a>第十二章 说出人生故事</h2><p>这一章主要是蛤蟆在回忆他的人生，比较有趣的是苍鹭的反应，他一直在问：</p>
<blockquote>
<p>为什么？是怎样的情形？之后发生了什么？那些事情让你有什么感受？后来呢？你是怎么应对情绪的？关键是，你能由此学到什么？</p>
</blockquote>
<p>我觉得，遇到问题、处于困境时，我们可以尝试自己描述一下问题，在描述中，多问问自己的感受、原因和一些细节，由此来发现隐藏的线索。</p>
<h2 id="第十三章-人生坐标与心理游戏"><a href="#第十三章-人生坐标与心理游戏" class="headerlink" title="第十三章 人生坐标与心理游戏"></a>第十三章 人生坐标与心理游戏</h2><blockquote>
<p>他在回忆时不再谴责自己。他能找到事件之间的联系，能客观地去看，而不再感到内疚。慢慢地，他开始理解为什么有些事情会以那样的方式发生，以及它会带来怎样的影响。换句话说，蛤蟆在反思自己的所作所为，并从中学习领悟。</p>
</blockquote>
<blockquote>
<p>也许还有另一种活法，无须跟着预先设定的剧本走，甚至可以没有剧本，或者说，可以即兴发挥。不过，这会让人感到害怕，没了剧本，你怎么知道该做什么或说什么呢？可反过来，想到每一个全新的时刻都意味着独一无二的机会和挑战，又让人无比激动。蛤蟆认定，所谓活得真实，就是真诚地回应当下的需求。这能打破从童年延续而来的因果循环，让真实的自我摆脱过去经历的束缚，在自由中成为真正的自己。他决定要让自己活得更真实一点儿。</p>
</blockquote>
<blockquote>
<p>一切的关键就在于那是“人生坐标”。一旦我们在童年决定用哪种态度和观点，我们就会在随后的人生里始终坚持自己的选择。这些态度和观点，变成我们存在的底层架构。从那以后，我们便建构出一个世界，不断确认和支持这些信念和预期。换一个词来说，我们把自己的人生变成了一个“自证预言”。我们会控制事件的发生，从而确保预言会成真。我们会确保自己的世界和预期的一样。</p>
</blockquote>
<h2 id="第十四章-赢了游戏-输了自己"><a href="#第十四章-赢了游戏-输了自己" class="headerlink" title="第十四章 赢了游戏 输了自己"></a>第十四章 赢了游戏 输了自己</h2><blockquote>
<p>在人生坐标左侧上玩游戏的人都处在“父母状态”，而且永远都是“挑剔型父母状态”。这些人动不动就指责，焦虑得随时会发脾气，还想用不可能达到的标准来评判别人。当然了，有时候他们会摆出‘养育型父母’的姿态，说些诸如‘我比你更心痛’或‘我是为你好’之类的话，但大部分人都能听出这是虚情假意。关于这类人的心理状态，还有一个有意思的现象，那就是他们从来不会抑郁。因为愤怒能够非常有效地抵抗抑郁。愤怒的人从不觉得内疚，因为他们总在怪罪别人。他们自卫的方式，是把自己内在的恐惧对外投射到别人身上，这样就能把对自己的怒火转向别人。</p>
</blockquote>
<h2 id="第十五章-最后一次面谈"><a href="#第十五章-最后一次面谈" class="headerlink" title="第十五章 最后一次面谈"></a>第十五章 最后一次面谈</h2><blockquote>
<p>“我好；你也好”的人生坐标并非静止的状态，而是动态的过程，是一种发自内心信念的行为。你觉得自己是好的，也相信别人是好的，那就得靠行为和态度持续地对自己和别人展示出来。而这个选择肯定不能给你庇护，免于“残暴命运如投石飞箭般的摧残”。信自己，信他人。</p>
</blockquote>
<blockquote>
<p>情商真正的意思是理解你内心的情感世界，并且还能掌控它。高情商的人都有强大的自我意识，了解自己的情感。他们能管理情绪，能从悲伤和不幸中重新振作。但也许最重要的是，他们能控制冲动，也懂得延迟满足，从而避免轻率的决定和不妥的行为。</p>
</blockquote>
<blockquote>
<p>情商和理解别人有关，一个高情商的人能辨识他人的感受，这种技能称为“共情”。但也许情感智力中最大的技能是通过理解和回应对方的情感，与他人建立良好的关系。</p>
</blockquote>
<blockquote>
<p>情感智力能让你在自我成长和完善的路上走得更远，因为它将带你从独立的个体走向共生的关系。独立性隐含了做自己的自豪感，还包括独特的才能、与众不同的部分。独立的人时刻守护新发现的自主权，如同一个曾被殖民的国家重获自由一样。这当然没错，但共生性则体现出成熟和自我接纳，还包括求同存异地接纳他人。共生性可以让你在社交和工作上与别人有效联结，协同合作。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://book.douban.com/review/12909084/">《编辑手记：蛤蟆先生如何开始一段意外之旅?》</a></li>
<li><a href="https://book.douban.com/review/12950075/">《蛤蟆先生》核心知识点及咨询过程梳理</a></li>
</ul>
<img  src="../../../../../pics/reading/hmxsqkxlys/cover.PNG"   width="100"><span class="image-caption">蛤蟆先生去看心理医生</span>]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Read a Book</title>
    <url>/reading/how-to-read-a-book/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>这本书真的很难看，hard to read。这种论说指导型的书籍，没有小说精彩，还很长，真的很难看书的时候不睡着。<br>这是我第二次拿起这本书在看了，第一次就是无疾而终，翻了前几章，就没在看下去了，这次终于坚持着看完了。<br>仔细想想，我认真读书的时光，大多在中学，偷偷在被窝里看各种小说，仰角45度悲伤的那种，可能有些人觉得，言情小说不配算作读书，但不得不承认真的有很多人愿意为他们买单，那时候看的书，现在大多都被翻拍成了热门的电视剧、电影，不知道是不是和买书的同一批消费者。【啊……怀念青春QwQ<br>看教科书能算么？我买的嘎多编程书还一本未尽。所以，关于读书的方法，我真的不敢高谈有见解。不过，我一直记得有一位历史老师说过，一本书初看很薄，后来应该越看越厚，因为有很多补充知识，相关知识会需要寻找，读者也需要破解作者的线索，记下很多相互关联之处以及感想启发，最后，再回头看这本书，应该比初始时更薄，因为那时，书中的内容对读者来说，已经消化，读者也看清了这本书的起承转合，发展脉络，一切如数家珍，看这本书，就如同书的目录一样，薄薄几页了。我初始对读书的理解大概如此吧。</p>
<p>总之，「磨刀不误砍柴功」，在开启『读书101』的时候，我们应该先来学习一下，如何阅读一本书。<br>读完这本书，shuxian就要求我暂缓『读书101』计划一个月。开启一个计划，最怕的就是冷冻，希望一个月后，仍然可以相见。:)</p>
<h1 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h1><p>本书从三个方面讲解了阅读书籍的方法，首先，需要达成的共识是，只有读者主动地阅读才能吸取书中精华，达到最佳效果。对于所有的书本，我们在阅读之前都有列出基本问题，然后在阅读中寻找答案，这样才能有所收获。<br>具体来说，阅读有四个层次，他们层层递进。每一层都有更深入的目的、步骤和规则。<br>此外，本书还给每一种类型的书籍，提供了阅读建议和指南，帮助读者更加深入的学习前三个阅读层次的方法，能够做到融会贯通。<br>最后，作者留下丰富的《附录》，以及严谨的长达8页的《索引》。附录1是137个《建议阅读书目》，其中还是很多是作者的名字，所以，大于137本书。附录2是一个非常负责任，并且配有标准答案的《四种层次阅读的练习与测验》（是谁说歪果仁不用做阅读理解的……），非常有趣。<br>总结大纲如下：<br><img  src="/../../../../../pics/reading/htrab/how2read1book-mind-map.png"  ><span class="image-caption">读书笔记</span></p>
<h1 id="后面说说"><a href="#后面说说" class="headerlink" title="后面说说"></a>后面说说</h1><p>终于看完了，真的不容易。不知道是翻译的问题，还是原著风格的原因，句子有很多晦涩难懂，动不动就弄个多重否定，晕死。而且，有很多逻辑、调理不清，我常常要看很多遍，有的时候为了对比，看到后面的时候还要翻回前面去，去理解前面的逻辑。截取一个片段，大家感受下。<br><img  src="/../../../../../pics/reading/htrab/how2read1book-lyric-poetry.jpg"  ><span class="image-caption">阅读故事、戏剧与诗的一些建议</span></p>
<img  src="../../../../../pics/reading/htrab/how2read1book.jpg"   width="100"><span class="image-caption">如何阅读一本书</span>

<h1 id="See-you-next-book"><a href="#See-you-next-book" class="headerlink" title="See you next book!"></a>See you next book!</h1>]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>在这个复杂世界里</title>
    <url>/reading/in-this-complicated-world/</url>
    <content><![CDATA[<h2 id="《他人只是自己眼中的故事》"><a href="#《他人只是自己眼中的故事》" class="headerlink" title="《他人只是自己眼中的故事》"></a>《他人只是自己眼中的故事》</h2><p>他人只是自己眼中的故事而已，为了满足自己心中的情感抒发，别人所有的事情都是故事。</p>
<h2 id="《两个哑巴》"><a href="#《两个哑巴》" class="headerlink" title="《两个哑巴》"></a>《两个哑巴》</h2><p>“我期望语无伦次地过活，或者完全没有语言，这让我不再没完没了地诉说着我爱着的姑娘，和让我憎恨的生活。”</p>
<p>为什么那么多人着急放弃沉默？可能是因为他们从来没真的沉默过。</p>
<p>“谢谢你。现在我很好，希望你也是。勿念。”</p>
<h2 id="《不再让你孤单》"><a href="#《不再让你孤单》" class="headerlink" title="《不再让你孤单》"></a>《不再让你孤单》</h2><p>青春苦短，女友勤换。</p>
<p>路遥远，我们一起走。</p>
<h2 id="《第三次赌博》"><a href="#《第三次赌博》" class="headerlink" title="《第三次赌博》"></a>《第三次赌博》</h2><p>孩子是一夜之间长大的，父母是一夜之间变老的。每人都有自己的经历方式，对我，这一夜很漫长。</p>
<p>生活教会我，永远不要对你爱的人说残忍的话。你不会知道，哪句话会成为这一生对她说的最后一句话。而她的回答，也许就是“我怕”。</p>
<h2 id="《走马灯》"><a href="#《走马灯》" class="headerlink" title="《走马灯》"></a>《走马灯》</h2><p>“这世界上再浓烈的情感也不该逾越作为人想要活下去的本能。”</p>
<h2 id="《妈妈》"><a href="#《妈妈》" class="headerlink" title="《妈妈》"></a>《妈妈》</h2><p>时间是场永远赢不了的游戏，前一秒，你还在嫌弃它的漫长；后一秒，像风吹过的沙城，了无痕迹！</p>
<h2 id="《北京食记》"><a href="#《北京食记》" class="headerlink" title="《北京食记》"></a>《北京食记》</h2><p>假若他日相逢，我将何以贺你？以眼泪，以沉默。</p>
<h2 id="《我最好朋友的婚礼》"><a href="#《我最好朋友的婚礼》" class="headerlink" title="《我最好朋友的婚礼》"></a>《我最好朋友的婚礼》</h2><p>这就是我们最大的区别，我沉浸于回忆，略悲观，而她就是现世享乐主义者。我们在同一间寄宿学校念书，不同班，每周五一起搭两个小时的巴士回家。中学六年，从未间断。在不回家的时候，我们骑着自行车在街上疯跑，对路边的行人大笑。那些引人发笑的内容早已忘了，可是那时的青春就是如此明亮，可以笑出声来。</p>
<h2 id="《皮格马利翁》"><a href="#《皮格马利翁》" class="headerlink" title="《皮格马利翁》"></a>《皮格马利翁》</h2><p>我也不知道为什么有些人可以拥有天赋，而有些人只是心怀盲目的热诚。但后来我发现，天赋并不是上天赐予人类的最珍贵的礼物，遗忘的能力才是。</p>
<p>这世界上大概再没有什么比爱更无用也更伟大。</p>
<h2 id="《你喜欢的一切，最后都会变成一座碑》"><a href="#《你喜欢的一切，最后都会变成一座碑》" class="headerlink" title="《你喜欢的一切，最后都会变成一座碑》"></a>《你喜欢的一切，最后都会变成一座碑》</h2><p>恶人自有恶人磨，轮不到你和我。</p>
]]></content>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>季羡林谈人生</title>
    <url>/reading/ji-xian-lin-tan-ren-shen/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>仔细想想，现在的人生有很多纠结，不知道未来的方向在哪里，也不知道选择是否值得。<br>找来一个耄耋老人的人生感悟来拜读一下，想要从中获取一些灵感。<br>首先，得到是一种乐观豁达的态度，文字有一些幽默，阅读的时候，我就感觉走在沙滩上，处处都藏着珍珠。<br>我看到了一个慈祥的老人，没有倚老卖老，而是努力认真工作，帮助他人的丰满形象。<br>后面，我又去看了一下季老的一生，有很多的故事。季老也来自山东，不由得让我想到我爷爷和奶奶。<br>如今他们都去了天堂，留下了被时间追赶的我。最近，身边都是00后，打开电视的冬奥会，也都是00后，被追着拍在沙滩上的我，深深感到年龄的无力啊。。。</p>
<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><h2 id="关于人生"><a href="#关于人生" class="headerlink" title="关于人生"></a>关于人生</h2><p>我们“人”的“生”，都绝对是被动的。<br>不如意事常八九，可与人言无二三。<br>考、考、考，变成烤、烤、烤，一直到知命之年，厄运仍然难免。<br>脑袋瓜变成了花岗岩，已经快到不可救药的程度了。<br>六指子划拳，多此一指。<br>就算谈人生经历吧，我本来也可以写“今天天气哈，哈，哈”一类的文章，这样谁也不得罪，读者读了晚报上的文章，可以消遣，可以催眠。我这个作者可以拿到稿费。双方彼此彼此，各有所获，心照不宣，各得其乐。这样岂不是天下太平，宇宙和合了吗？<br>讲真话是容易得罪人的，何况好多人养成了“对号入座”的习惯，完全像阿Q一样，忌讳极多。<br>信缘分与不信缘分，对人的心情影响是不一样的。信者胜可以做到不骄，败可以做到不馁，绝不至胜则忘乎所以，败则怨天尤人。中国古话说：“尽人事而听天命。”首先必须“尽人事”，否则馅儿饼绝不会自己从天上落到你嘴里来，但又必须“听天命”。人世间，波诡云谲，因果错综，只有能做到“尽人事而听天命”，一个人才能永远保持心情的平衡。<br>走运时，要想到倒霉，不要得意过了头；倒霉时，要想到走运，不必垂头丧气。心态始终保持平衡，情绪始终保持稳定，此亦长寿之道也。<br>我力避发九斤老太之牢骚，但有时又如骨鲠在喉不得不一吐为快耳。</p>
<h2 id="满招损，谦受益"><a href="#满招损，谦受益" class="headerlink" title="满招损，谦受益"></a>满招损，谦受益</h2><p>知足知不足，有为有不为。<br>在宗法伦理色彩极强的中国社会中，朋友被尊为五伦之一，曰“朋友有信”。我又记得什么说中说：“朋友，以义合者也。”<br>适用于一切时代、一切地区，万古长青的道德教条恐怕是绝无仅有的。<br>如果真有一个人，人人都说他好，这个人很可能是一个极端圆滑的人，圆滑到玻璃球又能长只脚的程度。</p>
<h2 id="论压力"><a href="#论压力" class="headerlink" title="论压力"></a>论压力</h2><p>压力如何排除呢？粗略来分类，压力来源可能有两类：一被动，一主动。天灾人祸，意外事件，属于被动，这种压力，无法预测，只有泰然处之，切不可杞人忧天。主动的来源于自身，自己能有所作为。我的“三不主义”的第三条是“不嘀咕”，我认为，能做到遇事不嘀咕，就能排除自己造成的压力。<br>应当恐惧而恐惧者是正常的。应当恐惧而不恐惧者是英雄。我们平常所说的从容镇定、处变不惊，就是指的这个。不应当恐惧而恐惧者是孱头。不应当恐惧而不恐惧者也是正常的。<br>我们都要锻炼自己，对什么事情都不要惊慌失措，而要处变不惊。<br>顺其自然，尽人事。<br>一寸光阴不可轻。<br>只要心里一想急，我就祭起了我的法宝，法宝共有两件：一是儒家的“既来之，则安之”，一是道家的顺其自然。你别说，这法宝还真灵，只要把它一祭起，心中立即微波不兴，我对一切困难都处之泰然了。</p>
<h2 id="谈老"><a href="#谈老" class="headerlink" title="谈老"></a>谈老</h2><p>人吃饭是为了活着，但活着却不是为了吃饭。<br>我仍然要老老实实干活，清清白白做人；绝不干对不起祖国和人民的事；要尽量多为别人着想，少考虑自己的得失。<br>万物方生方死。</p>
<h2 id="新年述怀"><a href="#新年述怀" class="headerlink" title="新年述怀"></a>新年述怀</h2><p>过去带来惆怅，现在带来迷惘，未来带来希望。<br>窗外已是寒冬。荷塘里在夏天接天映日的荷花，只剩下干枯的残叶在寒风中摇曳。玉兰花也只留下光秃秃的枝干在那里苦撑。但是，我知道，我仿佛看到荷花蜷曲在冰下淤泥里做着春天的梦，玉兰花则在枝头梦着“春意闹”。它们都在活着，只是暂时地休息，养精蓄锐，好在明年新世纪、新千年中开出更多更艳丽的花朵。<br>天增岁月人增寿，春满乾坤福满门。<br>《唐书》记载，张公艺九世同居，唐高宗问他睦族之道。公艺提笔写了一百多个“忍”字递给皇帝。从那以后，姓张的多自命为“百忍家声”。&#x3D; 唐朝有一个姓张的大官，家庭和睦，美名远扬，一直传到了皇帝的耳中。皇帝赞美他治家有道，问他道在何处，他一气写了一百个“忍”字。这说得非常清楚：家庭中要互相容忍，才能和睦。这个故事非常有名。在旧社会，新年贴春联，只要门楣上写着“百忍家声”就知道这一家一定姓张。中国姓张的权益祖先的容忍为荣了。<br>现在我们中国人的容忍水平，看了真让人气短。</p>
<img  src="../../../../../pics/reading/jxltrs/cover.PNG"   width="100"><span class="image-caption">季羡林谈人生</span>]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>手账系列</title>
    <url>/reading/journaling-and-notes-0/</url>
    <content><![CDATA[<h1 id="故事开始"><a href="#故事开始" class="headerlink" title="故事开始"></a>故事开始</h1><p>九月中旬，我突然开始想写手账了。<br>可能是心里一直种着一棵这么做的种子，然后，在看到一个旅行册后，突然发芽了。<br>「凡事预则立」，「预」是「立」的必要不充分条件。<br>因为还有很多不确定，不知道从何下手，于是，我买了很多速成手册和技巧书籍。<br>一边阅读，一边在小红书、ins上找自己喜欢的博主，确定风格和学习。<br>期待在即将达到的10月开启我的手账生活！yo🎉yo🎉<br>书记，按阅读顺序排列。</p>
<img  src="../../../../../pics/reading/jan/journaling-and-notes-0.jpg"   width="200"><span class="image-caption">手账系列</span>

<h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>我不会建议想入坑的同学和我一样读这些无趣的书，毕竟我已经帮你总结好了。<br>我会建议你在小红书上多搜搜大触们的手账，看看自己的喜欢的风格到底是什么，像我，就被ins风吸引，于是赶紧下了ins关注那些喜欢的风格的博主。<br><strong>切记</strong>，不要冲动消费！先选择好风格再下手</p>
<h1 id="笔记清单"><a href="#笔记清单" class="headerlink" title="笔记清单"></a>笔记清单</h1><p>按阅读顺序排序<br><a href="../journaling-and-notes-1/">神奇手账</a><br><a href="../journaling-and-notes-2/">幸运手账 + 手帐入坑指南</a><br><a href="../journaling-and-notes-3/">最强手账改造术</a><br><a href="../journaling-and-notes-4/">聪明人用方格笔记本</a></p>
]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Journaling</tag>
      </tags>
  </entry>
  <entry>
    <title>神奇手账</title>
    <url>/reading/journaling-and-notes-1/</url>
    <content><![CDATA[<h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>这本书翻译有两个版本，大陆版和台版。台版的封面更可爱一些，但是，价格高出很多。内容应该都是一样的。<br>这本书里所说的手账和我理解的略微不同，它更多地侧重在如何进行日程计划，你需要先有年计划，月计划，再到日计划，指导你怎样用计划安排日程，让你的时间可以最大化地利用起来。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="正确使用手账笔记本的基本原则"><a href="#正确使用手账笔记本的基本原则" class="headerlink" title="正确使用手账笔记本的基本原则"></a>正确使用手账笔记本的基本原则</h3><h4 id="装备原则"><a href="#装备原则" class="headerlink" title="装备原则"></a>装备原则</h4><ol>
<li>手账笔记本要同时拥有周计划表和月计划表<ul>
<li>月计划表：记录每月预定行程，以“与他人的约会”为主</li>
<li>周计划表：记录每周预定行程，写行程细节、以“自己想做的事”为主</li>
</ul>
</li>
<li>手账笔记本要能随手携带，最好不要太大</li>
<li>牢记四色笔记规则，手账内容一目了然<ul>
<li>蓝色：工作 -&gt; 可冷静执行</li>
<li>绿色：私事 -&gt; 娱乐计划、令人期待的预定行程</li>
<li>红色：健康 -&gt; 身体、危机管理等重要事项</li>
<li>黑色：杂事 -&gt; 生活相关的琐碎杂事，平常心处理</li>
</ul>
</li>
</ol>
<h4 id="笔记原则"><a href="#笔记原则" class="headerlink" title="笔记原则"></a>笔记原则</h4><ol>
<li>月计划表，区分整月行程：<ul>
<li>与他人的的约定，事项前写上时间</li>
<li>自己想做的事情（&#x3D;待办清单），事项前加上勾选方块</li>
<li>可以加上相关人员的预定行程</li>
<li>做到公开透明</li>
</ul>
</li>
<li>周计划表检视每日进度<ul>
<li>记录待办事项</li>
</ul>
</li>
</ol>
<h4 id="小笔记本里的清单"><a href="#小笔记本里的清单" class="headerlink" title="小笔记本里的清单"></a>小笔记本里的清单</h4><ul>
<li>年度清单</li>
<li>人生清单</li>
<li>活动时间表</li>
<li>禁止清单</li>
<li>五十大目标</li>
<li>购物清单</li>
</ul>
<h3 id="管理时间"><a href="#管理时间" class="headerlink" title="管理时间"></a>管理时间</h3><ol>
<li>让看不见时间，变成看得见的时间<ul>
<li>把开始的时间“圈出来”，用时钟提醒自己注意进度</li>
<li>用“箭头”标记结束，确实了解每项工作花费时间</li>
<li>月计划表上，在每个周一写出工作时间</li>
</ul>
</li>
<li>休假日也要写在手账上<ul>
<li>休假日用绿色荧光笔圈出</li>
<li>休假日有两种，在计划表上用不同形式表示：<ul>
<li>私人行程（可以出游的日子）-&gt; 圈</li>
<li>完全休息 -&gt; 涂满颜色</li>
</ul>
</li>
</ul>
</li>
<li>每天规划一段专属自己的幸福时光<ul>
<li>安排每天让自己开心的一项计划<ul>
<li>尽量不花钱，或低价</li>
<li>可单独完成</li>
<li>自己会期待</li>
</ul>
</li>
</ul>
</li>
<li>下班后想提升自己，手账是最佳工具<br> 写出全日行程 -&gt; 定位下班后的自由时间<br> 每天设定一小步 -&gt; 向梦想前进 -&gt; 目标不能过高，每天都要采取行动</li>
<li>编列独家“每月行程表”，善用属于自己的时间<br> 在月计划表种找出空闲时间，可能变更的行程，画上波浪线</li>
<li>九宫格暗示法，同时达成八项年度目标<ul>
<li>内容<br>健康   ｜ 穿着打扮 ｜ 心灵精神面<br>工作   ｜ 【年份】 ｜ 进修<br>生活   ｜ 爱好兴趣 ｜ 金钱、物品</li>
<li>一年内可完成，且值得实现</li>
</ul>
</li>
<li>先排“大活动”，以免错过后悔<ul>
<li>一年一度的活动，提前写在月计划表上</li>
<li>提醒自己下一季度的重要事件</li>
</ul>
</li>
<li>刻意留下“无所事事”的一天<ul>
<li>月初就安排 </li>
<li>安排行程时，尽量避开</li>
</ul>
</li>
<li>除了“该做的事”，也要记下“不该做的事”<br> 维护禁止清单，写下替代方案</li>
<li>健康也很重要<ul>
<li>将“留意自身健康”写进每月的代办事项</li>
<li>把运动计划写进手账</li>
</ul>
</li>
</ol>
<h3 id="整理文件和灵感"><a href="#整理文件和灵感" class="headerlink" title="整理文件和灵感"></a>整理文件和灵感</h3><ol>
<li>定期整理收件箱，再也不会忘了回复<ul>
<li>首先要养成邮件分类的习惯，这不会需要很久</li>
<li>将带回复的邮件设为“草稿”，固定时间统一处理，建议时间选择午休后</li>
<li>每周检查一次邮件</li>
</ul>
</li>
<li>年底整理通讯录 &#x3D; 整理人脉 &#x3D; 审视人际关系</li>
<li>养成备份习惯，减少生活中的突发状况<ul>
<li>把“备份”加入待办清单，养成习惯</li>
</ul>
</li>
<li>将网络资料纸质化，容易规划阅读时间<ul>
<li>纸质化对于阅读内容，和所需要的阅读时间有掌握</li>
<li>在手账笔记本上写下关键词，管理每天获得的信息</li>
</ul>
</li>
<li>灵感常在放松时出现，一定要安排休息日<ul>
<li>充分休息且随时笔记，发现更多好想法</li>
</ul>
</li>
<li>手账+小笔记本，完整收集每个好点子<ul>
<li>手账可以当小笔记本的索引</li>
<li>可以发送点子的电子邮件，但记得在主题里加上日期，方便日后查找</li>
</ul>
</li>
<li>累积好点子手账笔记本，打造专属灵感宝盒</li>
</ol>
<h3 id="提高工作效率"><a href="#提高工作效率" class="headerlink" title="提高工作效率"></a>提高工作效率</h3><ol>
<li>只要在6个时间点整理，终结桌上的文件山<ul>
<li>每天一次：可以写在每周计划上。当天使用过且仍需用到的文件，分类成已处理、待确认、进行中</li>
<li>每周一次：将一周的文件分类成必须保存和须处理掉的数据</li>
<li>每月一次：个人月结算日，列在月计划旁边的“本周活动清单”栏中</li>
<li>每三个月一次</li>
<li>每半年一次</li>
<li>每年一次</li>
<li>想快速找到文件，关键就是日期</li>
</ul>
</li>
<li>写日期后再依序排列，整理名片超简单</li>
<li>书柜上，只留用得到的书籍<ul>
<li>每三个月定期整理书柜，将书分为三类：保留、丢弃、卖掉</li>
<li>看完书后，在当日手账上决定去留</li>
</ul>
</li>
<li>写上一行字，让工作环境清爽又整齐<ul>
<li>避免拥有重复性物品，果断留下一个即可</li>
<li>借用他人的物品，当天归还</li>
<li>规划每个东西应该归位的地方</li>
</ul>
</li>
<li>写出细节的购物清单，避免冲动购物<ul>
<li>把想买物品的细节全部写下来：颜色、材质、预算</li>
</ul>
</li>
<li>写下购物时的心情，了解自己真正的需求<ul>
<li>从购物清单中，了解自己真正的需求</li>
</ul>
</li>
<li>每年两次，只花一天整理衣柜<ul>
<li>换季时整理衣物，只留下适合自己的，将衣物分为三类：保留、丢弃、卖掉</li>
<li>回想当初购买的心情，决定衣服的去留</li>
</ul>
</li>
<li>在周计划表上，写出预定和额外的支出</li>
</ol>
<h3 id="情绪更积极"><a href="#情绪更积极" class="headerlink" title="情绪更积极"></a>情绪更积极</h3><ol>
<li>不喜欢的工作，如何利用手账顺利完成它<ul>
<li>把不悦的负面感觉写出来，深挖原因，化为正面的反省力</li>
<li>在处理棘手工作时，记录下 行动、结果、反省 -&gt; 加强自己的能力</li>
<li>容易拖延的工作，要安排出作业时间，让自己没有借口</li>
</ul>
</li>
<li>待办清单上，要分“今天做”和“明天做”<ul>
<li>提前一天，用五分钟，写下待办清单</li>
<li>将内容细分化，写下“预计花费时间”和“截止时间”列出来</li>
</ul>
</li>
<li>只有手账达人知道的“梦想成真”笔记术<ul>
<li>预定周行程时，写下“未来一周宣言”</li>
<li>预言好的结果，写下来就能成真</li>
<li>使用正面词句，避免负面；以肯定句、过去式做笔记</li>
</ul>
</li>
<li>除了公事，也要记下放松心情的微小的幸福<ul>
<li>从规律的生活中，找出简单的快乐</li>
<li>记下每天让自己幸福一次的“每日一绿”</li>
<li>维护“愿望清单”（具体描绘）和“购物清单”，让自己有所期待</li>
<li>告别霉运，记下每一个幸福瞬间，让别人感到开心也可以记录</li>
</ul>
</li>
<li>记下成功的原因，找出你的必胜模式<ul>
<li>找出为自己带来幸运的潜规则，好事就会一直来</li>
<li>每天找出一件好事，记下来</li>
<li>反省内容正面化，找出你的专属胜利公式 -&gt; 下次该怎么做会成功</li>
</ul>
</li>
<li>“一写就成真”的手账术，要持续一整年<ul>
<li>了解自己的优缺点，怀抱着目标以及梦想</li>
<li>列出八个大目标，搭配“周计划”逐步实现</li>
<li>坚持一年</li>
</ul>
</li>
<li>想要过得不错的一年，就要为自己找出每月目标<ul>
<li>制定“每月主题”，预测问题 -&gt; 远离问题</li>
<li>目标要切实可达到</li>
</ul>
</li>
</ol>
<h3 id="增进人脉"><a href="#增进人脉" class="headerlink" title="增进人脉"></a>增进人脉</h3><ol>
<li>手账，也是解决人际关系的工具<ul>
<li>感到挫折的原因和人，具体地描绘在手账上，了解人&#x2F;事原因</li>
<li>分清是对方的问题，还是自己需要多做准备</li>
<li>选择保持距离，还是提前安排 -&gt; 事先预防出错</li>
</ul>
</li>
<li>利用手账，初次见面也能聊不停<ul>
<li>调查对方背景，预留时间以确定当天谈话的内容</li>
<li>事先准备可能聊到的话题，写在预定会面当天的“周计划本”上</li>
</ul>
</li>
<li>从“改变行程”的原因，看出谁最难相处<ul>
<li>从取消的行程上，发现谁是“拒绝往来户”</li>
<li>把保持联络当成预定行程，减轻人际关系的压力</li>
</ul>
</li>
<li>手账的四色原则，帮你在行程撞期时做抉择<ul>
<li>写下所有的行程，然后根据颜色，做出选择，较为期待的一边优先</li>
<li>可以利用小反省，选择之后，记录下取舍，再冲突时，可以做参考</li>
</ul>
</li>
<li>专门准备“给别人看”的手账计划表</li>
<li>能让你成长的对象，才是“人脉”</li>
</ol>
<img  src="../../../../../pics/reading/jan/journaling-and-notes-1.jpg"   width="100"><span class="image-caption">神奇手账</span>


<h1 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h1><p><a href="../journaling-and-notes-2/">幸运手账 + 手帐入坑指南</a><br><a href="../journaling-and-notes-3/">最强手账改造术</a><br><a href="../journaling-and-notes-4/">聪明人用方格笔记本</a></p>
]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Journaling</tag>
      </tags>
  </entry>
  <entry>
    <title>幸运手账 + 手帐入坑指南</title>
    <url>/reading/journaling-and-notes-2/</url>
    <content><![CDATA[<h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>这两本书差不多，《手帐入坑指南》是第三方出版社手机手帐达人的经验，然后总结的书籍；《幸运手账》是一位手帐达人的经历总结，给新人提供了思路。都是大陆出版社，所以是我们想象中手账的样子。蛮适合作为入坑手册的，尤其是《幸运手账》，非常实用。</p>
<h1 id="手帐入坑指南"><a href="#手帐入坑指南" class="headerlink" title="手帐入坑指南"></a>手帐入坑指南</h1><h2 id="手账基础"><a href="#手账基础" class="headerlink" title="手账基础"></a>手账基础</h2><p>手账本没有固定的定义，自己想清楚即可。<br>必备文具：</p>
<ol>
<li>手帐本：手账本有各种各样的品牌和内页，总之，选择适合自己的购买就好</li>
<li>写字笔：也是五花八门，各种风格，选自己喜欢的</li>
<li>画笔：彩铅、水彩、水彩笔、记号笔</li>
<li>周边：各种胶带、贴纸，各式便签纸，印章</li>
<li>辅助：压花器、图案修正带、修正带橡皮、手账垫板、模版尺、长尾夹、回形针、书签、笔状胶水、点点胶、剪刀、打印机、琴谱架（固定摊开的本子）</li>
</ol>
<h2 id="手账内容"><a href="#手账内容" class="headerlink" title="手账内容"></a>手账内容</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol>
<li>计划：工作、学习、生活</li>
<li>记录：吃喝、玩乐、情感</li>
<li>打卡：21天打卡培养习惯，用打卡表监督自己</li>
<li>待办事项：四象限（重要、紧急）</li>
<li>学习：倒计时、每日&#x2F;作息安排（可用饼状图）、笔记、总结</li>
<li>每日扩展记录：预定事项、天气、睡眠时间、工作评价、阅读书籍等</li>
<li>进度管理：甘特图</li>
<li>记账：年度总览圆环、收支表格、</li>
<li>种草清单：记录入眼时间、种草度&#x2F;心动指数、名称和入手时间、价格，记录时思考原因</li>
<li>理想：写清楚目标，列下清单，比如想去的地方</li>
<li>周记：在左侧<strong>简明扼要</strong>地写下每日安排，右侧作为备忘录和内容补充【注意分类】</li>
<li>月记：一个月的行程</li>
<li>生活记录：美食、观影、演唱会、购物、亲子、生日、节日</li>
</ol>
<h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ol>
<li>周间手账：需要计划与记录，但时间不多</li>
<li>时间轴手账：记录较少，计划较多</li>
<li>一日一页：时间较多，喜欢记录</li>
<li>自定义手账：不定期记录，或需要分类记录</li>
</ol>
<h2 id="手账排版"><a href="#手账排版" class="headerlink" title="手账排版"></a>手账排版</h2><h3 id="排版方式"><a href="#排版方式" class="headerlink" title="排版方式"></a>排版方式</h3><ol>
<li>分区化（简单实用）<ul>
<li>方格排版：品字形、田字形、晶字形，竖排</li>
<li>多格排版：交叉排列、对称排列、不对称排列</li>
<li>漫画式排版：错位排列、互补排列、镶嵌式排列</li>
<li>重叠排版：依次重叠、重点突出重叠、复杂重叠</li>
</ul>
</li>
<li>对角线（具有视觉美的对角线）<ul>
<li>单页对角线：上下对称、斜角对称、中心环绕对称</li>
<li>跨页对角线：中间相连、互补排列</li>
<li>倾斜对角线：平行倾斜、对角倾斜、双重倾斜边框</li>
</ul>
</li>
<li>均衡感（稳定的排版）<ul>
<li>中心排版：中心图片，四周文字、中心文字，四周留白</li>
<li>纸胶带拼圆：破圆拼贴、内圆和外圆、捕梦网</li>
</ul>
</li>
<li>不均衡（打破固有的思维）<ul>
<li>斜角装饰</li>
<li>底部装饰</li>
</ul>
</li>
<li>灵活感（页面动感）<ul>
<li>直线串联装饰元素：直角转折、锐角转折</li>
<li>曲线串联装饰元素：弧线分割、大弧度转折、压缩弧度</li>
</ul>
</li>
</ol>
<h3 id="手工创意"><a href="#手工创意" class="headerlink" title="手工创意"></a>手工创意</h3><ol>
<li>自制模板尺，用卡纸做出万能模板尺</li>
<li>彩旗装饰，贴彩色胶带，再用剪刀剪出想要的样式</li>
<li>用彩色胶带拼出百搭字母和随信小数字</li>
<li>用回形针和胶带做出彩色索引和书签</li>
</ol>
<h1 id="幸运手账"><a href="#幸运手账" class="headerlink" title="幸运手账"></a>幸运手账</h1><h2 id="手账工具"><a href="#手账工具" class="headerlink" title="手账工具"></a>手账工具</h2><ol>
<li>手账本： 阅读、日常、电影、旅行、梦想</li>
<li>笔：针管、双头荧光笔、钢笔、高光笔</li>
<li>胶带</li>
<li>其他：圆规、点点胶、便签纸、直尺、剪刀</li>
</ol>
<h2 id="手账简笔画"><a href="#手账简笔画" class="headerlink" title="手账简笔画"></a>手账简笔画</h2><p>发挥想象，努力联想，简笔画不一定要和实物一样</p>
<h2 id="手账类别"><a href="#手账类别" class="headerlink" title="手账类别"></a>手账类别</h2><ol>
<li>日常手账<ul>
<li>年规划<ul>
<li>年份形象页，有个好的开头</li>
<li>梦想清单，让今年不再迷茫</li>
<li>全年月目标</li>
<li>七个人物法，找到目标和梦想</li>
<li>甘特图，跟踪目标实现情况</li>
<li>学习记录</li>
<li>电视节目</li>
<li>网综</li>
<li>TED</li>
</ul>
</li>
<li>月规划<ul>
<li>月份形象页</li>
<li>月安排，圆形、长条形、表格形</li>
<li>月计划分类，分为学习、工作、家庭和社交等</li>
<li>打卡页，日常习惯养成</li>
<li>阅读清单</li>
<li>观影清单</li>
<li>情绪清单，真实记录情绪和原因 -&gt; 自我调节</li>
<li>购物清单</li>
</ul>
</li>
<li>周计划<ul>
<li>周目标</li>
<li>周总结：快速梳理成功完成的事情，和教训</li>
</ul>
</li>
<li>每日手账<ul>
<li>Todo list</li>
<li>每日总结</li>
</ul>
</li>
<li>月总结<ul>
<li>梳理当月重要事件</li>
<li>完成的任务，例：学习内容</li>
<li>印象深刻的一些话</li>
</ul>
</li>
</ul>
</li>
<li>梦想手账<br>写下梦想标题，然后努力，记录完成状况，伙伴人数，日期，地点，和完成的感觉</li>
<li>读书手账<ul>
<li>标题字速成法，彩笔打底+线笔描框；彩笔打底+线笔描框+阴影；粗体字</li>
<li>打印封面图，贴上，或者手写标题+作者</li>
<li>摘抄+感悟</li>
<li>思维导图</li>
<li>读后感：<ul>
<li>这本书讲了什么内容</li>
<li>你最喜欢书的哪个部分</li>
<li>这本书对你有什么影响</li>
<li>它的优点在哪里</li>
</ul>
</li>
</ul>
</li>
<li>电影手账<ul>
<li>基本内容：片名、评分、导演、制片地区、编剧、语言、主演、上映时间、片长、观影日期、影院、海报封面、剧照（可选）</li>
<li>可加剧情、台词、感想</li>
<li>可附电影票</li>
</ul>
</li>
<li>旅行手账<ul>
<li>第一个跨页：版面+地点+时间+简介</li>
<li>第二个跨页：照片+内容介绍</li>
<li>美食相册，随意拼接</li>
</ul>
</li>
<li>清单手账<br>最简单的手账，大标题，清单式的日期以及简介</li>
</ol>
<h2 id="手账摄影"><a href="#手账摄影" class="headerlink" title="手账摄影"></a>手账摄影</h2><ol>
<li>摆拍<br>三角构图、对角线构图、角落形构图、视觉中心构图</li>
<li>修图<br>黄油相机：海洋、宇宙、硬朗滤镜</li>
</ol>
<img  src="../../../../../pics/reading/jan/journaling-and-notes-2.jpg"   width="200"><span class="image-caption">幸运手账 + 手帐入坑指南</span>

<h1 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h1><p><a href="../journaling-and-notes-1/">神奇手账</a><br><a href="../journaling-and-notes-3/">最强手账改造术</a><br><a href="../journaling-and-notes-4/">聪明人用方格笔记本</a></p>
]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Journaling</tag>
      </tags>
  </entry>
  <entry>
    <title>最强手账改造术</title>
    <url>/reading/journaling-and-notes-3/</url>
    <content><![CDATA[<h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>前面两本书的书记都很快就完成了，从这本开始会慢一些。不是因为内容多，因为文字变多了。这本书主要就是介绍手账模版和各种免费手账资源。<br>里面有很多链接，但是大多数我打开就是 <em>ERROR - The requested URL could not be retrieved</em> 。还有的打开了，日期都是2008年，下载的zip包没法解析。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="任何手账都能根据个人需求进行个性化定制"><a href="#任何手账都能根据个人需求进行个性化定制" class="headerlink" title="任何手账都能根据个人需求进行个性化定制"></a>任何手账都能根据个人需求进行个性化定制</h2><p>五大基本功能的扩展形式：<br>    * 日程安排 -&gt; Google Calendar<br>    * ToDo -&gt; ToDo App<br>    * 备忘录 -&gt; Evernote<br>    * 通讯录 -&gt; Facebook<br>    * 参考索引 -&gt; dropbox<br>手账基本功能逐渐被替代。<br>所以，定制内容，让手账为你所用<br>    * 备忘录 -&gt; 记录生活点滴、体重、名人名言<br>    * 参考索引 -&gt; DIY空间<br>    * 通讯录 -&gt; 读书笔记、影评剧评<br>    * 日程安排 -&gt; 备忘 + ToDo + 愿望、目标<br>任何手账 + 根据自身需要定制 （替换页、粘贴&#x2F;夹页、增设配件） + 使用方法和习惯 &#x3D; 最适合你的完美个人手账</p>
<h2 id="通过拼贴、夹页打造与众不同的个人手账"><a href="#通过拼贴、夹页打造与众不同的个人手账" class="headerlink" title="通过拼贴、夹页打造与众不同的个人手账"></a>通过拼贴、夹页打造与众不同的个人手账</h2><ol>
<li>分类贴纸 -&gt; 标签、索引</li>
<li>指示&amp;边角用贴纸 -&gt; 功能分区</li>
<li>纸胶带 -&gt; 简易索引</li>
<li>夹入小笔记本，增设备忘录</li>
<li>用小号备忘录管理日常信息</li>
<li>增设配件管理五大类信息</li>
<li>制作格式多样的可替换小册子</li>
<li>粘贴日历，笔记本变手账</li>
<li>打印日历，夹在笔记本&#x2F;手账里</li>
</ol>
<h2 id="亲手制作替换页，打造属于你的手账模版"><a href="#亲手制作替换页，打造属于你的手账模版" class="headerlink" title="亲手制作替换页，打造属于你的手账模版"></a>亲手制作替换页，打造属于你的手账模版</h2><ol start="10">
<li>通过手账管理梦想&amp;目标，手写体透露出决心，且能记录书写情绪，纸质册更方便查阅</li>
<li>用月历管理新买的书籍和正在阅读的书籍</li>
<li>根据自己的需求，制作专属替换页</li>
<li>运用模版管理目标<br>设定目标时，可以采用SMART原则：<br>* S - Specific 目标是否足够清晰？<br>* M - Measurable 对象是否足够明确？<br>* A - Achievable 目标是否足够实现？<br>* R - Relvant 是否是自己真正想做的？<br>* T - Timing 是否设定了明确的时间节点？</li>
</ol>
<h2 id="增设配件，让手账的可能性无限扩大"><a href="#增设配件，让手账的可能性无限扩大" class="headerlink" title="增设配件，让手账的可能性无限扩大"></a>增设配件，让手账的可能性无限扩大</h2><ol>
<li>松紧带，让手账实现无限扩展</li>
<li>收纳袋，可以放手机</li>
<li>透明文件夹，存放卡片和照片</li>
<li>独特封面</li>
<li>粘贴型透明收纳袋，放护身符</li>
<li>带多个笔插的笔套</li>
<li>卡片型&#x2F;PVC镜子</li>
</ol>
<h2 id="个性化手账让生活更精彩"><a href="#个性化手账让生活更精彩" class="headerlink" title="个性化手账让生活更精彩"></a>个性化手账让生活更精彩</h2><ol>
<li>在备忘录里整理出“个人守则”</li>
<li>列表清单是“行动的指南” - 从随意的ToDo List开始，明确自己想要的究竟是什么 -&gt; 用清单的清单开始</li>
<li>用灵活的N次贴维护清单物品，利用空间，定期回顾</li>
<li>打造适合自己的生活记录手册</li>
<li>更新维护“拒绝清单”</li>
<li>用个人地图作为“行动清单”</li>
<li>统一存放就医相关文件票据</li>
</ol>
<h2 id="个性化手账让工作更顺利"><a href="#个性化手账让工作更顺利" class="headerlink" title="个性化手账让工作更顺利"></a>个性化手账让工作更顺利</h2><ol>
<li>用项目卡片逐渐找到“自己心中的答案”</li>
<li>分析“成功模式”和“失败模式”的卡片<br> 记录日期、案例、起止时间、成功原因、状况、对手等要素，分析自己的习惯和武器，获得自信</li>
<li>制作关系与工作的3D人脉图</li>
<li>用手工打造的会议记录模版，对各类信息进行有效管理</li>
<li>及时记录ToDo列表</li>
<li>用N次贴双轨制维护ToDo列表，及时更新任务状态</li>
<li>同步管理日程安与待办事项的甘特图</li>
<li>按照计划，制作预想ToDo列表</li>
<li>如实记录项目进展和结果</li>
</ol>
<h2 id="纸面与数码结合，进一步活用个人手账"><a href="#纸面与数码结合，进一步活用个人手账" class="headerlink" title="纸面与数码结合，进一步活用个人手账"></a>纸面与数码结合，进一步活用个人手账</h2><ol>
<li>解决二者重叠，找到分界线和侧重点</li>
</ol>
<img  src="../../../../../pics/reading/jan/journaling-and-notes-3.jpg"   width="100"><span class="image-caption">最强手账改造术</span>


<h1 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h1><p><a href="../journaling-and-notes-1/">神奇手账</a><br><a href="../journaling-and-notes-2/">幸运手账 + 手帐入坑指南</a><br><a href="../journaling-and-notes-4/">聪明人用方格笔记本</a></p>
]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Journaling</tag>
      </tags>
  </entry>
  <entry>
    <title>聪明人用方格笔记本</title>
    <url>/reading/journaling-and-notes-4/</url>
    <content><![CDATA[<h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>和《神奇手帐》一样，这是一本全彩印刷的书籍。全彩印刷的，图片比较多，而且给人一种「大忽悠」的感觉。<br>整本书很多口号，像传销宣传一样，标题很多都是什么聪明人怎样怎样，怎样怎样可以让头脑更聪明。我看得内心毫无波澜，甚至还有点想笑。<br>这就是网上购书的不好吧，如果是实体书店选书的话，我可能就不会买了。<br>既然买了，就好好读，一起吸取精华吧！</p>
<p>这本书介绍的是如何利用方格笔记本，来达到高效工作、学习的思维整理。<br>最后还给出了一些精美笔记案例，这些笔记案例值得学习一下。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="若想改变人生，那就先改变“笔记本”吧"><a href="#若想改变人生，那就先改变“笔记本”吧" class="headerlink" title="若想改变人生，那就先改变“笔记本”吧!"></a>若想改变人生，那就先改变“笔记本”吧!</h2><ol>
<li>有两种笔记，阻碍能力发挥和使头脑变聪明的笔记本<br> 改变笔记本，能力也将随之改变</li>
<li>要写“能够重现所学内容的笔记”，这样的笔记才有意义<ul>
<li>不能按照自己的习惯随意记笔记</li>
<li>不能完全照搬黑板、白板板书</li>
<li>不能为了避免遗忘而记笔记</li>
<li>一定要想好目的和如何发挥作用后再开始记笔记</li>
<li>重现性 &#x3D; 能力 &amp; 成果</li>
</ul>
</li>
<li>“阻碍能力发挥的笔记本”，应立刻放手<ul>
<li>这样的笔记本会造成负面影响</li>
<li>知识和技能会逐渐丢失</li>
<li>有害于把握未来人生机遇</li>
</ul>
</li>
<li>利用方格笔记本的横线、竖线，可以整理归纳笔记内容，写出漂亮美观的笔记<ul>
<li>记录时以方格笔记本的横线、竖线为指引线，可以留出空白，使行首对齐，调整行间距和文字大小</li>
<li>美观整齐的笔记本一目了然，使人思路清晰</li>
<li><strong>两页一主题</strong>，激发头脑潜能</li>
<li>使用方格笔记本，可以培养信息整理的能力</li>
</ul>
</li>
<li>用方格笔记本改变“框架” &#x3D; 是头脑变聪明<ul>
<li>“框架”决定工作、学习质量</li>
<li>人的思考和行动受“框架”影响 -&gt; 框架清晰明确，人会正确思考和行动</li>
<li>有意识地按照“框架”整理思路，可以让思路更清晰</li>
</ul>
</li>
<li>要想以后把握住机遇，必须重新审视自己的笔记本</li>
</ol>
<h2 id="麦肯锡的咨询顾问们使用的“麦肯锡笔记本”的秘诀"><a href="#麦肯锡的咨询顾问们使用的“麦肯锡笔记本”的秘诀" class="headerlink" title="麦肯锡的咨询顾问们使用的“麦肯锡笔记本”的秘诀"></a>麦肯锡的咨询顾问们使用的“麦肯锡笔记本”的秘诀</h2><ol>
<li>“横向”使用方格笔记本<br> 横向视野更宽阔，有助于养成全面考虑的思考方式<br> 笔记本的使用方向会影响信息的理解速度</li>
<li>聪明人的笔记本的共同原则——黄金三分法。<ul>
<li>把书写空间分成三分，按照“板书” -&gt; “发现” -&gt; “总结”的顺序记笔记</li>
<li>坚决按照简单的“思考方式(框架)”记笔记</li>
<li>Point Seat：左侧写重点，右侧写采取的行动 &#x3D; 谁、何时、做什么</li>
<li>“空、雨、伞”：现在的情况，认清事实、对此情况的解释、依据该解释而采取的行动</li>
</ul>
</li>
<li>养成用A4大小笔记本的习惯_024<br> 更大的笔记本，提升思考空间<br> 输入和输出工作的工具皆以“A4笔记本为基本”</li>
<li>按“一页一主题”的方法记笔记，在笔记本上方的空白区域写“题目”<br> “标题”使笔记的主题清晰，方便日后翻阅了解重点和结论，提升理解速度<br> 因为内容较多，所以采取“一页一主题”更加方便</li>
<li>通过大量的书写练习 -&gt; 大量舍弃，反复磨炼记笔记的能力，使笔记本进化成“容易取得理想结果的笔记本”</li>
</ol>
<h2 id="人生之本！看透“学习笔记本”"><a href="#人生之本！看透“学习笔记本”" class="headerlink" title="人生之本！看透“学习笔记本”"></a>人生之本！看透“学习笔记本”</h2><ol>
<li>笔记本具有<strong>记忆</strong>、<strong>思考</strong>、<strong>传达</strong>这三项功能<ul>
<li>根据情况的不同，适时调整优先顺序，进化笔记本的使用方法</li>
<li>“记忆型笔记本” &#x3D; 学习笔记本，目的是理解、记录知识</li>
<li>“思考型笔记本” &#x3D; 工作笔记本，为了看清本质、理解重点、引出结论</li>
<li>“传达型笔记本” &#x3D; 提案&#x2F;博弈笔记本，要从众多信息中筛选出对方所需信息，并经过梳理后为对方提供解决、改善方案</li>
</ul>
</li>
<li>改掉“照搬板书”的笔记法，用“空白的一秒钟”形成难以忘记的记忆<ul>
<li>完全照搬的记录方式只是单一的机械化行为，很难形成记忆，也没有经过自己的思考和理解，导致日后难以应用</li>
<li>在“看黑板-&gt;写笔记”的过程中加入“空白的一秒钟”，强化理解和记忆</li>
<li>将“空白的一秒钟”变为习惯，强化能够形成永久记忆的“快速记忆回路”</li>
</ul>
</li>
<li>用“两页一主题”的方式使用学习笔记本<ul>
<li>建议B5或A4的笔记本，两页并作一页使用</li>
<li>在最上方留出3-5厘米的空白部分，写上“标题”和“重点”，之后很容易回顾和高效复习</li>
<li>按“黄金三分法”分割一大页笔记，左侧为“板书区域”，中间是“发现区域“，记录老师评语和自己的思考，右侧作为“概括总结区域”，记录疑难解答</li>
<li>“学习笔记本”的关键点在于对“中部区域”的使用。在听课过程中的疑问和发现的重点要写入“中部区域”</li>
</ul>
</li>
<li>“逻辑连接词”是将“发现”故事化的决定性因素<ul>
<li>逻辑词体现逻辑关系，可将“发现点”故事化</li>
<li>逻辑连接词可以用箭头表示，提高效率的同时，可以提高“重现性”</li>
<li>三种箭头符号可以简单地将信息和知识更加“视觉性”、“逻辑性”地展现出来，像故事一样串联</li>
<li>—&gt; 总结逻辑连接词（对所写内容进行概括总结）：<ul>
<li>可总结为</li>
<li>总而言之</li>
<li>总之</li>
</ul>
</li>
<li>｜》展开连接词（寻找理由和原因时的“为什么”、将解决办法具体化的“因此”）：<ul>
<li>这是因为</li>
<li>具体来说</li>
<li>因此</li>
</ul>
</li>
<li>&#x3D;&#x3D;&#x3D;&gt;强调连接词：<ul>
<li>其实</li>
<li>重点是</li>
</ul>
</li>
<li>换个角度连接词（发现新观点）：<ul>
<li>如果……</li>
<li>假如你是那个人的话</li>
</ul>
</li>
</ul>
</li>
<li>记笔记时，重要的是，要有意识地总结概括<ul>
<li>在总结区域写下对学习内容的“概括总结”和“解决疑难点的方法”，解决所有问题</li>
<li>这样的记录方法可以强化“概括能力”和“发文能力”</li>
<li>理想的笔记在于一眼明白重点</li>
<li>笔记的三个重点为：逻辑连接词、三种箭头、概括区域</li>
<li>笔记的“总而言之”要有意识地按照“三个重点”概括、总结</li>
</ul>
</li>
<li>中部区域用箭头+逻辑词展开，加深理解，右侧概括总结</li>
</ol>
<h2 id="工作笔记本，是“舍弃型”笔记本"><a href="#工作笔记本，是“舍弃型”笔记本" class="headerlink" title="工作笔记本，是“舍弃型”笔记本"></a>工作笔记本，是“舍弃型”笔记本</h2><ol>
<li>职场人士的笔记本是筛选“应舍弃信息”的工具<ul>
<li>笔记本的目的是从庞大的信息中筛选和引导出与结果相关的重要信息，并理出重点、得出结论 -&gt; <strong>舍弃</strong></li>
<li>使用方格笔记本 -&gt; 舍弃 -&gt; 引导出结论，锻炼“舍弃力”</li>
<li>不急躁、踏踏实实地改掉代谢不良型笔记本的坏习惯</li>
<li>用三分法整理信息，引出最终结论</li>
</ul>
</li>
<li>善于工作的人一边舍弃无用的信息，一边记笔记<ul>
<li>看清信息 -&gt; 对信息进行取舍 -&gt; 思考顺利开展，快速得出结论</li>
<li>从100中找出最重要的“1”，解决问题</li>
<li>容易整理的笔记本 &#x3D; 用方格笔记本磨炼“舍弃技术”</li>
<li>掌握舍弃的技术能够找到解决问题的突破口</li>
</ul>
</li>
<li>用方格笔记本提升“提问力”<ul>
<li>工作的第一步是确认“问题是什么?”</li>
<li>像“问诊”一样，通过“提问”找出问题点，思考问题点的改善、解决方案，向客户提出建议</li>
<li>在“一页一主题”的方格笔记本做“标题”能够锻炼“提问力”，可以在方格笔记本的“标题区域”写出问题</li>
</ul>
</li>
</ol>
<h2 id="一生的武器！掌握“提案笔记本”"><a href="#一生的武器！掌握“提案笔记本”" class="headerlink" title="一生的武器！掌握“提案笔记本”"></a>一生的武器！掌握“提案笔记本”</h2><ol>
<li>“笔记本”的终极目标是“提案笔记本”<ul>
<li>提案笔记本最重要的一点是能够按照逻辑性思维总结提案内容</li>
<li>首先“设定论点”，然后按照“事实 -&gt; 解释 -&gt; 行动”的步骤思考问题</li>
</ul>
</li>
<li>基于事实思考问题<br> 三分方格笔记本，写事实、解释、行动，培养基于事实思考问题的习惯</li>
<li>用“五个为什么”查明问题的根本原因<ul>
<li>通过连问“五个为什么”深度挖掘思考，可以明白表面问题和根本问题</li>
<li>使用“逻辑连接词”、“箭头”、“四方形”三个工具，兼具视觉效果和逻辑性，深入分析，迅速准确地找出“根本原因”</li>
</ul>
</li>
<li>最终归纳为“一条信息”<ul>
<li>理想目标是把需要传递给对方的信息概括总结为“1～2句话”</li>
</ul>
</li>
<li>用黄金三分法，准确设定论点 -&gt; 区分“事实”和“意见” -&gt; 基于“事实”提问“五个为什么”找出本质问题 -&gt; 明确“行动” -&gt; 用一条信息概括总结出“结论”</li>
<li>工作笔记的出口必定是“行动”<ul>
<li>在行动中，使用“看得见的语言”：具体、可行</li>
<li>“是否能够浮现出画面”和“是否真实”是关键点</li>
</ul>
</li>
<li>博弈笔记本三大要点：<ul>
<li>提案笔记本 &#x3D; 报纸的一页内容</li>
<li>“信息为先”，写完信息再画图</li>
<li>根据想达到的心里效果用逆向思维的方式选出图表</li>
</ul>
</li>
<li>常用效果：<ul>
<li>Waterfall效果 -&gt; 强调落差</li>
<li>金字塔效果 -&gt; “自上而下”地展开，第一层明确目标，第二层写出实现目标的三个重点，第三层写完成三个重点应采取的行动</li>
<li>高楼效果 -&gt; 强调差异，呈现消息的长条图，重点对比明确，将详细说明或含义放在右侧</li>
</ul>
</li>
</ol>
<h2 id="7个方格魔法"><a href="#7个方格魔法" class="headerlink" title="7个方格魔法"></a>7个方格魔法</h2><ol>
<li>“框架”使笔记更清晰 -&gt; 记笔记前，先快速画出框架</li>
<li>笔记要能3秒重现内容 -&gt; 将笔记方向设为“横向”，按照“标题 + 黄金三分法”的方法记笔记</li>
<li>方格笔记本用法：打开一页 -&gt; 写框架记笔记 -&gt; 一边用框架整理思路，一边记笔记</li>
<li>方格笔记的小技巧：记笔记时空出右侧区域、选择A4笔记本、用“三个重点”整理每页的笔记内容</li>
<li>将条例式的待办事项，转化为“九宫格”或“即时贴”的视觉化办公清单 -&gt; 空分留白、使用均等大小的格子、增加图解、使完成任务更有趣</li>
<li>方格笔记本的使用术可分为两个步骤 -&gt; 先将信息整理成方便阅读的形式，然后，在另一张笔记本上，划分三个空间，依据事实 -&gt; 解释 -&gt; 行动的流程展开思考，最后导出结论</li>
<li>用简单步骤画出逻辑式图解：画辅助线 -&gt; 绘图 -&gt; 擦掉辅助线</li>
</ol>
<img  src="../../../../../pics/reading/jan/journaling-and-notes-4.jpg"   width="100"><span class="image-caption">聪明人用方格笔记本</span>

<h1 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h1><p><a href="../journaling-and-notes-1/">神奇手账</a><br><a href="../journaling-and-notes-2/">幸运手账 + 手帐入坑指南</a><br><a href="../journaling-and-notes-3/">最强手账改造术</a></p>
]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Journaling</tag>
      </tags>
  </entry>
  <entry>
    <title>我这一辈子</title>
    <url>/reading/my-life/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>久仰老舍先生大名，这本书也在我的reading list上许久。今终于读完了。<br>说出来怕大家笑话，看到这个题目，我还以为是老舍先生的自传，打开才发现是一篇篇小说故事。<br>每个故事都很丰满，跌宕起伏，道尽了小人物的辛酸、无奈。<br>阅读这种有年代感的书，虽然情节很好，但是我还是不太舒服，感觉就像在看爸爸书架上一本泛黄的旧书。明明是在手机上看的电子书，我却总是隐隐能闻到一种腐朽的霉味，好像几个书页上，还有书虫啄食的痕迹。究其原因，是因为书中的遣词用句和现代语有些许脱节，必不可少地带上了年代感。<br>唉，书中说的都是小故事，寥寥几页文章，就是一个小人物痛苦的一生。越长大越难评判，越长大越能体会，可怜之人必有可恨之处，可恨之人又怎会没有可怜之处。未经他人苦，莫劝他人善。真是越长大越难开口啊！<br>你我又有何资格来感慨他人的悲哀呢？</p>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><h2 id="微神"><a href="#微神" class="headerlink" title="微神"></a>微神</h2><p>这第一篇，我感觉我被愚弄了。<br>开头各种描写都非常美好，男女主豆蔻年华，两情相悦。<br>后面，我（男主）离乡求学，两人分开，女主被迫卖身以生活，做了小姐，等我回来想再与她相见，女主不愿玷污曾经的美好，孤独地赴了黄泉。<br>那个年代，留给女生的选择总是很少，后面还有两篇，女生要么做了妓、要么被夫家虐待。</p>
<h2 id="抱孙"><a href="#抱孙" class="headerlink" title="抱孙"></a>抱孙</h2><p>愚昧真的会害死人。<br>看这篇的时候，真不知道是该笑还是该哭。明明是很悲伤的事情，是那个愚昧的老太太害死了孙子和儿媳。可是，她的愚昧让人不由地发笑。<br>如何来拯救自以为是的愚民么？<br>转念一想，你我就能百分百地接受超出理解范围的事么？</p>
<h2 id="黑白李"><a href="#黑白李" class="headerlink" title="黑白李"></a>黑白李</h2><p>黑白李是一对亲生弟兄。虽都是好人，但性格相反。哥哥黑李守规矩，不愿变更，弟弟白李更活泼叛逆些，愿意接受新鲜事物。<br>因为接受不了电车会取代人力，导致车夫下岗的变化，白李带头砸了电车，要被处分就义。黑李带他受罚了。<br>所以，首先，人不能不接受时代的变化，不能和时代潮流斗争，不然只会白白牺牲。白李砸了电车，电车也不会停。另外，人的目光总是短小，他们只会看到眼前的得失和变化，每次工业变革，大家都会担心是不是要下岗失业了，但结局是变更往往带来更多的工作岗位，生活也会变好。所以，人不能，也没必要违抗时代发展。</p>
<h2 id="断魂枪"><a href="#断魂枪" class="headerlink" title="断魂枪"></a>断魂枪</h2><p>这篇我没看懂。<br>为什么“沙子龙”不愿意把他的断魂枪和枪法传下去。即使有了更厉害的热武器，这个冷武器也绝对有存在意义的。而且这个意义不会只在无聊的表演场上。</p>
<h2 id="小铃儿"><a href="#小铃儿" class="headerlink" title="小铃儿"></a>小铃儿</h2><p>讲述的以一个优秀的好苗子，是如何在错误的指导下，走向歧途，最后断送人生的故事。<br>作为一个没有被老师欣赏过的学生，我觉得有一略略的微爽。听老师、听家长的话也不一定有好的结局。相反，钻牛角尖的话，还有可能走向灭绝。<br>但是作为一个成年人，我非常担心下一代的教育环境。虽然这篇文章已有一定的年纪，但是所说的道理在今天更加值得我们关注了。因为今天的社会风气戾气更重，更加功利和绝对。人们渐渐倾向于只会看和认可与自己相同的观点，而陷入了一个悲观和狭隘的恶性循环。</p>
<h2 id="老字号"><a href="#老字号" class="headerlink" title="老字号"></a>老字号</h2><p>这篇我感触最深了！我的感受和读完「黑白李」类似。<br>我和辛德治差不多，都喜欢现在的生活，不愿意脱离舒适圈，让我们主观移动是不可能的，那如果环境发生了变化，我们被迫改变呢？那一定是怨声载道，不可能有积极的。就算可能宏观上来说是良性的改变，我们不能违背，但心理绝对不会乖乖听话，怎么都得埋怨，可能还会悄悄地给你使点绊子，在角落里暗爽。<br>钱掌柜走了，辛德治心里一百个不愿意，周掌柜到任做改革，辛德治心里又一百个不情愿。明明看着营业额提升，效益变好，辛德治也不开心，总觉得不贵。周掌柜也不愿意带着这些老伙计改革，教也教不会，学也学不像，带他们赚钱了，他们心里还不乐意。于是，对面的铺子给了周掌柜职位，周掌柜就走了。钱掌柜终于回来了，一切又复原了。对于辛德治来说，这样才是对的，仿佛周掌柜就是一场梦。可惜，店的衰败和亏损是事实，店不得不裁人。辛德治含着泪对老掌柜说：“我一人干五个人的活，咱们不怕！”老掌柜也说：“咱们不怕！”辛德治那晚睡得非常香甜，准备次日干五个人的活。可是，过了一年，店卖给了对面铺子。<br>讽刺不讽刺？<br>循规蹈矩，不愿意接受改革，是不是注定要被时代抛弃？但是坚守匠心，还是守旧不懂变通，都是结局决定说辞的。</p>
<h2 id="月牙儿"><a href="#月牙儿" class="headerlink" title="月牙儿"></a>月牙儿</h2><p>时代女性的悲哀。月牙儿是始终贯穿故事的线索。一开始，在我小的时候给我陪伴，在我成长过程中，给我亮光和希望。可是一点云就能把月牙遮住，我又进入了黑暗、空虚、无依无靠。<br>这是一个跌宕起伏的故事，我的心一直为女主揪着，直到文章结束。<br>女主出生在一个幸福家庭，可惜，在她很小的时候，爸爸死了。妈妈没有办法，洗衣辛苦赚钱，可是随着我长大，她赚钱越来越辛苦了，她找了一个续弦，可是没多久他就走了，女主在上学。后爸走了之后，妈妈又很辛苦，所以，她扛不住命运，做了张腿赚钱的妓。女主觉得很不堪，但也理解妈妈的难处。当妓是青春饭，没办法持久，除非女主愿意接替，可是女主在上学，她不愿意。所以，妈妈最后还是得嫁人。妈妈没得挑，一个馒头铺主人愿意要她，她就跟着走了。女主没有随行，（大概）因为她想上学。然后女主就在学校里打工，结果，被一个男生骗了，谎称爱情，其实那个男生有未婚妻。然后，女主伤心离开，可是离开之后又没地赚钱，她去了酒楼当招待，可是她干不来。为了生计，她也只能做这社会留给女生唯一的职业，靠嘴赚钱。一开始，她年轻，还可以挑，后面随便玩玩，她没选，再然后，就是谁愿意上谁上了。<br>讽刺不讽刺？</p>
<h2 id="歪毛儿"><a href="#歪毛儿" class="headerlink" title="歪毛儿"></a>歪毛儿</h2><p>歪毛儿和我是幼时的同学，他白白净净招人喜欢。多年后，我无意与他撞见，他居然十分落魄。我邀请他到家中叙旧，他勉为其难地来了，然后说出了他的秘密。他的眼睛总是能看见人的恶处和弱点，在他的眼里，人总是有两张脸，一张是正常虚伪的脸，另一张是穷凶极恶的脸。他看到了穷凶极恶的脸，认识了这个人的真面目就无比愤怒，非要教训他一顿，结果往往是惨败，所以他在哪里都不能长久。<br>所以，这到底是什么病，他到底要怎么做才正确？是看见了，装作没看见，继续该咋样咋样？还是说，要揭露他的真面目，落得个心理干净？这个社会上，谁不是个斯文败类呢？你我难道就看不到人的两张脸么？表面夫妻恩爱的男性，心理却想着如何折磨妻子？表面和和气气的同时，背地里却一直在说你坏话？表面夸你好看的销售，心理却只想着割韭菜？这样的例子不是身边比比皆是。可是，你我都选择了忍耐和视而不见。因为，我们都不想像歪毛儿一样强出头，与社会格格不入。所以，这样说来，我们还都不如他了。</p>
<h2 id="马裤先生"><a href="#马裤先生" class="headerlink" title="马裤先生"></a>马裤先生</h2><p>这个真的搞笑，让我想起了我的一个小学同学。<br>当群众素质发展跟不上社会进步的脚步，一些啼笑皆非的场面就会出现。<br>每每这个时候，袁隆平爷爷就要拍脑袋说，我为什么要让这么多人吃饱啊。</p>
<h2 id="柳家大院"><a href="#柳家大院" class="headerlink" title="柳家大院"></a>柳家大院</h2><p>又是女人的悲哀，这次这个女生没有去做妓了，却一直被公公、老公和夫妹欺负、拳打脚踢，最后上吊走了。她任劳任怨了很久，却留下了一个凄惨的结局。讽刺的是，公公还一直自称“文明人”在做“文明事”。整个大院都没有人帮这个女生。直到她生命的最后，才有另一个媳妇找她说两句，结果还被污蔑说是让她自杀的始作俑者。<br>书中欺负得最狠的要数夫妹。书上说，一个女人要是看不起另一个女人的，那就是活对头。但是最后，这个夫妹也逃不了要被卖掉的命运。所以啊，女人何苦为难女人。</p>
<h2 id="不成问题的问题"><a href="#不成问题的问题" class="headerlink" title="不成问题的问题"></a>不成问题的问题</h2><p>真真小人当道。之前看过范伟主演的改编自这个故事的同名电影。电影是黑白色调的，当时很多问题没有看明白，这次看了书之后有了更加深刻的理解。<br>尤主任和丁主任强烈地对比，尤主任脚踏实地，老实肯干，丁主任油嘴滑舌，忙于人际关系，我们看书的时候，都知道谁是真正的有识之士，谁是在腐蚀农场的害虫。可是，如果你真的设身处地地想一想，你更愿意和谁合作？无论是上层太太、农场的股东，还是底层的劳动人民，谁都喜欢和丁先生一起共事啊。尤主任努力工作上面人看不见，成果、收益都不是分分钟的事，丁主任就不同啦，忙前忙后的，费尽心机地讨好上面。对下面人他们偷懒，偷鸡摸狗，赚黑钱，丁主任睁一只眼闭一睁眼，尤主任呢，反而要清理游手好闲之人，还不允许底下人拿农场的东西，这能不造反么？<br>所以啊，这两个人物都太极端了。做人就要介于两者之间，你既不能不干事，又不能只知道蒙头干事，你既不能偷鸡摸狗得太厉害，又要随时留一手，常在上头的面前冒冒脑袋。做人难啊！</p>
<h2 id="大悲寺外"><a href="#大悲寺外" class="headerlink" title="大悲寺外"></a>大悲寺外</h2><p>一个善良的老师，非常善良，却早逝于时代的悲哀，被一个学生在学生活动中砸死了，他临死前说：无论是谁砸的，我绝不计较。于是这句话，就成了这个学生一辈子的诅咒。无论他干什么，稍微有点起色了，这句话就会出现，导致他总是失败，又得从头再来。<br>其实，善良的老师并没有诅咒他，是他的良心给他下了蛊，他一辈子也没法挣脱他曾经犯下的罪过，因为这件事已经无法挽回了。</p>
<h2 id="开市大吉"><a href="#开市大吉" class="headerlink" title="开市大吉"></a>开市大吉</h2><p>第三篇搞笑讽刺的文章。三个臭皮匠开医院，骗有钱人。诙谐幽默，浅显易懂，不用赘述啦！</p>
<h2 id="小木头人"><a href="#小木头人" class="headerlink" title="小木头人"></a>小木头人</h2><p>中国童话。</p>
<h2 id="我这一辈子"><a href="#我这一辈子" class="headerlink" title="我这一辈子"></a>我这一辈子</h2><p>我这一辈子就是起起落落落落落起落起落落落落啊。<br>“狗熊耍扁担，混碗儿饭吃”<br>“阎王好做，小鬼难当”</p>
<img  src="../../../../../pics/reading/ml/my-life.jpg"   width="100"><span class="image-caption">我这一辈子</span>]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>南大读本-社会/自然科学卷</title>
    <url>/reading/nju-readings-part1/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>《南大读本》是南京大学悦读经典计划读物，是2016年南京大学统一发的。这书没有条码，也没有售价，完全是免费的，所以也避免了很多版权的问题吧……<br>它分为两本，一个是社会&#x2F;自然科学卷，另一个是人文学科卷。读完真的是比喝涨芝士酸奶还长知识。<br>听起来好像第二个比较有趣，但读完之后，我觉得社会&#x2F;自然科学卷更有趣，果然逻辑思维强的人更可爱，哈哈哈。<br>这个书，一方面，有点速食文化的意思，因为在每本书节选开始之前都会有一位老师，先介绍下作者，然后讲一下这个书主要讲的啥，最后说一下为什么要推荐，以及节选部分的选取理由。有的还会简单介绍一下，节选部分的上下文。<br>另一方面，也很像电影介绍手册，类似预告篇。看完之后，会对某一些书感兴趣，某一些书就对不上感觉。这么一说，也很像《中国式相亲》的婚恋节目，由我来pick书籍。老师会介绍书籍的基本内容，书籍也会很我来一个亲密接触，有感觉的，就进入我的书单，没感觉的，就“谢谢，下一位”。<br>哈哈。大概就是这样，从3月12日开始，我很快速地翻完了这两本书，前前后后也有将近一个月，更何况，我只能说是翻，实在是不能算读，毕竟有很多章节都被我略过了。<br>我在下一部分根据目录，给其中一些我感兴趣的书籍节选做了一些标记说明。由于是手工整理+没钱请校对，可能会有一些错别字，还请指出，我一定及时改正。🙏<br>本来想在一篇文章里写完，可是，刚写完一本就感觉太长了，我担心读者朋友们阅读困难，所以，特意分成了两份。望阅读愉快。</p>
<h1 id="Chapter1-经济与社会"><a href="#Chapter1-经济与社会" class="headerlink" title="Chapter1 经济与社会"></a>Chapter1 经济与社会</h1><h2 id="经济发展理论（Joseph-A-Schumpeter）"><a href="#经济发展理论（Joseph-A-Schumpeter）" class="headerlink" title="经济发展理论（Joseph A. Schumpeter）"></a>经济发展理论（Joseph A. Schumpeter）</h2><p>【哦，我的天哪，我的头看到这本书怎么莫名其妙地开始头痛了呢？天呐，真的太不可思议了！目前对于理论书籍暂时不感兴趣，再见！】</p>
<h2 id="集体行动的逻辑（Mancur-Olson）"><a href="#集体行动的逻辑（Mancur-Olson）" class="headerlink" title="集体行动的逻辑（Mancur Olson）"></a>集体行动的逻辑（Mancur Olson）</h2><p>Olson的主要贡献是开创性地论证了集体行动中普遍存在的搭便车行为和利益集团形成的条件。即任何个人为集团或组织的共同利益做出的（时间、金钱上）牺牲，其收益必然由集团中的所有成员所分享。【经济学真的好“有趣”，虽然我对其探讨内容很感兴趣：集体存在的意义，集体中个人贡献的动力以及由此产生的分利集团等等，但是我真的看不下去🙈】</p>
<h2 id="不平等的代价（Joseph-E-Stiglitz）"><a href="#不平等的代价（Joseph-E-Stiglitz）" class="headerlink" title="不平等的代价（Joseph E. Stiglitz）"></a>不平等的代价（Joseph E. Stiglitz）</h2><p>【略，经过二十多年的体验，我已经充分得感受到了不平等，但确实不太了解其经济学意义，惭愧】</p>
<h2 id="新卖桔者言（Steve-N-S-Chueng-张五常）"><a href="#新卖桔者言（Steve-N-S-Chueng-张五常）" class="headerlink" title="新卖桔者言（Steve. N.S. Chueng, 张五常）"></a>新卖桔者言（Steve. N.S. Chueng, 张五常）</h2><p>非常有趣的一本书！作者是一个经济学家，但是也很像博学家，这本书非常好看，一定安排上原著。<br>和前面严肃的理论书籍不同，这本书是一本文集，主要收录了一些短文。作者从对现实世界的观察，从身边的现象，归纳出人类经济行为。<br>这个作者真的经历丰富，买过桔，养过鱼，种过果数，还卖过玉石，甚至对养生蚝有所了解。<br>作者不仅让深奥的经济学知识浅显易懂，平易近人，更重要的是，读者在阅读过程中可以了解很多新鲜的常识。<br>在海边或者是海上航行，我们常常都会看到灯塔，可是，《科斯的灯塔》带我们思考，灯塔到底是私人承包更合适，还是政府公家管理更合理。<br>《从玉石市场看讯息费用》一文更是让我大开眼界，玉石交易有点和赌博类似，但是盲猜赢的概率几乎为零，即使是专家也常常有看不准的时候。广东道的玉石原件拍卖更是令我叹为观止。<br>节选中的《养蚝的经验》和《佃农专家倒楣记》无不向我们展示着作者对经济学的了解以及对生活的热爱。❤️</p>
<h2 id="现代经济学与中国经济改革（钱颖一）"><a href="#现代经济学与中国经济改革（钱颖一）" class="headerlink" title="现代经济学与中国经济改革（钱颖一）"></a>现代经济学与中国经济改革（钱颖一）</h2><h2 id="旧制度与大革命（Charles-Alexis-de-Tocqueville）"><a href="#旧制度与大革命（Charles-Alexis-de-Tocqueville）" class="headerlink" title="旧制度与大革命（Charles Alexis de Tocqueville）"></a>旧制度与大革命（Charles Alexis de Tocqueville）</h2><h2 id="白领：美国的中产阶级（Charles-Wright-Mills）"><a href="#白领：美国的中产阶级（Charles-Wright-Mills）" class="headerlink" title="白领：美国的中产阶级（Charles Wright Mills）"></a>白领：美国的中产阶级（Charles Wright Mills）</h2><h2 id="资本主义文化矛盾（Daniel-Bell"><a href="#资本主义文化矛盾（Daniel-Bell" class="headerlink" title="资本主义文化矛盾（Daniel Bell)"></a>资本主义文化矛盾（Daniel Bell)</h2><h2 id="中国人（林语堂）"><a href="#中国人（林语堂）" class="headerlink" title="中国人（林语堂）"></a>中国人（林语堂）</h2><p>有趣！一本中国人写中国人的英文书，深刻又有趣地介绍了中国人的文化、性格、社会与文艺，不过这里的是翻译版。<br>节选部分的小标题就是《社会头脑的缺乏》，开篇说中华名族是一个由个人主义所组成的民族。那为啥咱们中国人就缺乏社会头脑嘞？原来从“古有云”就开始了。打”麻将“我们也是各成一派，盯着上家，小心下家，还要防着对家，由此个人主义可见一斑。在中国人眼中，社会工作看起来总是在“管别人的闲事”，人们不能理解他的目的，为啥不帮助自己和家人？最后得出的结论往往是他太年轻或者他异乎常人。而中国社会的根基是家庭和乡村制度。<br>除此之外，节选部分还讨论了家庭制度、特权与平等、社会等级等。最让人惊奇的部分，是作者总结的中国人与中国社会的“阴&#x2F;阳三位一体”。“阳”三位指的是，官绅富，是中国的社会面，而“阴”三位是，面（面子），命（命运），恩（恩惠），是中国的社会心理面。文章说得还是挺直白的，没有给中国人什么面子，哈哈，要是被社会白莲花，爱国瞎看到了，估计会被教育。</p>
<h2 id="乡土中国（费孝通）"><a href="#乡土中国（费孝通）" class="headerlink" title="乡土中国（费孝通）"></a>乡土中国（费孝通）</h2><p>作者用丰富的例子和清新隽永的语言带读者一起了解乡土中国。值得阅读！<br>从基层上看，中国社会是乡土性的。节选是《乡土本色与差序格局》篇章。作者首先说明了中国社会的乡土本色。与游牧民族不同，中国乡村人民大多是以农为生，依靠土地，因此定居是常态。不流动是从人和空间的关系上说的，从人和人在空间的排列关系上说就是孤立和隔膜【小农经济？】。这些特性催生除了“熟悉”的社会，以及很多取代法律的规矩，比如，“打招呼”。可是，这些特性遇到了现代社会就扑街了，因为大家彼此都是陌生人啊，这些个乡土的生活方式就显示出了弊端，大家又开始极端地厌恶它。<br>然后，作者就过渡到了“差序格局”的讨论。中国乡下佬最大的毛病就是“私”。公家的东西，在他们的眼里，差不多就是大家都可以占点便宜的意思，有权利而没有义务。门前有条河，啥垃圾都可以往里倒，没人愿意去管“闲事”。而要讨论这个“私”的问题，就得先看看整个社会结构的格局。西洋社会有团体格局的概念，他们的团体往往界限分明。比如，西方人说，家庭，一定就特指那么几个人，而中国人说的家庭，是一个伸缩自如的概念，可随意变换，一会儿指一个人，一会儿指一批人，甚至还可以，天下成一家。【作者举了一个请客吃饭的例子，还蛮好笑的。】中国人的格局，没有清晰的界限，而是像一块石头击在水面上形成的一圈圈的波澜，在某一时间，某一点所动用的特定的圈子。因为西洋社会的团体界限分明，所以要么在这个团体，要么不在，不可能像薛定谔的猫一样，摇摆不定。在团体里的有一定的资格，如果资格取消了，就得退出团体。西洋社会里争的是权利，不是人情冷热，而我们却喜欢攀关系、讲交情。这种“以一己为中心，社会关系层层外推”就是作者介绍的“差序格局”的概念。</p>
<h1 id="Chapter2-自然与生命"><a href="#Chapter2-自然与生命" class="headerlink" title="Chapter2 自然与生命"></a>Chapter2 自然与生命</h1><h2 id="什么是数学：对思想和方法的基本研究（Richard-Courant）"><a href="#什么是数学：对思想和方法的基本研究（Richard-Courant）" class="headerlink" title="什么是数学：对思想和方法的基本研究（Richard Courant）"></a>什么是数学：对思想和方法的基本研究（Richard Courant）</h2><p>节选部分介绍了素数的特点，一些关于素数的定理及其证明。有点点点点点点点意思，比如，为什么素数有无穷多个？存不存在一个只产生素数的公式？还有一些有趣的猜想，其中比较有名的是哥德巴赫猜想（每一个大于2的偶数都可以表示成两个素数只和）和孪生素数猜想（存在无穷多个素数p，使得p+2也为偶数）。猜想的提出要通过很长时间的观察与思考，但是证明的过程更加曲折离奇。这两个猜想还只是猜想。<br>数学家在我的眼里是严谨，异乎常人的。可能为了证明某一句定理，常常通宵达旦，写满草稿本，但同时他们在我的心里也是很脆弱的一批人，因为他们活在数字中，活在单一的定理间，即使微积分里有大千百变的世界，一旦，有一点点变化，这个精密的世界就会分崩离析了，更不用提上帝掷骰子的玩笑了，如果加上空间、维度的变化，这些定理还能存在么？还会成立么？</p>
<h2 id="时间简史——从大爆炸到黑洞（Stephen-Hawking）"><a href="#时间简史——从大爆炸到黑洞（Stephen-Hawking）" class="headerlink" title="时间简史——从大爆炸到黑洞（Stephen Hawking）"></a>时间简史——从大爆炸到黑洞（Stephen Hawking）</h2><p>节选部分介绍了物理上的变化，从亚里士多德的观念，到伽利略-牛顿，到相对论的变化。亚里士多德的观念里物体存在着绝对静止的状态，而牛顿则指出静止是相对，但他们的局限性还在于一直相信绝对时间的存在，认为时间相对于空间是完全分开并独立的。而在处理以光速或接近光速运动的物体时，这一观念是无效的。<br>相对论变革了我们对于时间和空间的观念，终结了绝对时间的概念。狭义相对论解释了光速是恒定的，并成功地描述了当物体以接近于光速运动时的行为。然而，它与已知的牛顿引力理论不相协调，随后，爱因斯坦在1915年提出广义相对论。其中有两个重要观点，一是，引力是空间-时间不平坦这一事实的后果。因为这个不平坦会让直线看起来像是弯曲了一样，正如三维空间中的直线，在二维空间中的映射是曲线一样。另一个预言是，在像地球这样的大质量的物体附近，时间显得流逝得更慢一些。<br>还有一个长知识的点，物体的速度不可能超过光速。因为质量和能量等价，爱因斯坦著名的公式E&#x3D;mc^2。物体由于运动所具备的能量要加到质量上，要加速它将变得更为困难。<br>有趣是有趣，就是比较费脑子，对于我来说，理解起来还是有薛薛困难的。【惭愧】</p>
<h2 id="漫游诺贝尔奖创造的世界一——化学之旅（李钟镐）"><a href="#漫游诺贝尔奖创造的世界一——化学之旅（李钟镐）" class="headerlink" title="漫游诺贝尔奖创造的世界一——化学之旅（李钟镐）"></a>漫游诺贝尔奖创造的世界一——化学之旅（李钟镐）</h2><p>很有趣！<br>这位韩国专家从日常生活的角度系统介绍诺贝尔奖，带领读者了解其发明创造给生活带来的诸多便利，以及获奖者的非凡经历。<br>节选部分，第一节讲的是塑料的诞生及其应用。有机合成的重要性在化学领域首屈一指。在很久以前，人们曾经认为有机物必须借助生命体才能够生成，但后来人们可以开始在实验室合成有机物了。由此，塑料登上了历史的舞台，有人戏称它为“造物主创世的唯一遗憾”。很多学者推断，如果没有塑料，地球上森林和铁的埋藏量将会减半，全球的人口数量也会因此减半。【虽然我不是很相信这句话，但也可以看出塑料的重要性。】无数科学家参与了塑料的合成和改进，其中有一些是偶然发现，也有一些是潜心研究，无数次的实验。【作者的重点就在讲述这其中的故事。但我在这里就略过了。】现在，环境问题的严重，使得塑料被推上了风口浪尖。但是，塑料成为公害与其是否容易腐烂无关，而是因为人们的随意丢弃，商人们只顾追求眼前利益。塑料没有被好好地循环利用。“解铃还须系铃人”，研究人员正在开发新一代能够自动分解的塑料。<br>随着对塑料批判的升温和陶瓷等新材料的迅速出现，塑料的前景面临着危机。第二次塑料革命正在进行之中，包括了工程塑料，功能性高分子等各种特殊的新型材料，其中最具代表性的是导电塑料。<br>第二节讲的是合成香料。香水起源于猎人，他们从植物和动物中取得。当今香水中不可或缺的四种重要成分最初都来源于动物：麝香、龙涎（xian）香、麝猫香和海狸香。后来人们就开始在实验室中尝试合成，然后就真的合成了。后来还碰巧发明了燃料。<br>题外话，在这一篇章的导言部分，老师就直接指出国人的“诺贝尔奖焦虑”实际上是对我国缺乏引领现代科学技术发展的核心理论和技术、国家缺乏核心竞争力的焦虑。而当代高等教育容易培养出的是具有一定技能和谋生手段的、非理性的、精致的利己主义者，更不用说“创新型人才”了。阅读这本书，能够了解诺贝尔奖获奖者的发明小故事，说不定也可以为同学们提供创新思路。:)</p>
<h2 id="千亿个太阳——恒星的诞生、演变和衰亡（鲁道夫）"><a href="#千亿个太阳——恒星的诞生、演变和衰亡（鲁道夫）" class="headerlink" title="千亿个太阳——恒星的诞生、演变和衰亡（鲁道夫）"></a>千亿个太阳——恒星的诞生、演变和衰亡（鲁道夫）</h2><p>是一本有趣的天体物理科普书籍。作者运用了很多生动的比喻，还有有趣的插图，让天体物理变得平易近人。虽然，我对外星、天体物理不太感兴趣，但是这本书还是可读的。【由于略深奥，一句话说不明白，这里就不赘述了。】</p>
<h2 id="中国自然地理纲要（任美锷）"><a href="#中国自然地理纲要（任美锷）" class="headerlink" title="中国自然地理纲要（任美锷）"></a>中国自然地理纲要（任美锷）</h2><h2 id="物种起源（达尔文）"><a href="#物种起源（达尔文）" class="headerlink" title="物种起源（达尔文）"></a>物种起源（达尔文）</h2><h2 id="信息简史（James-Gleick）"><a href="#信息简史（James-Gleick）" class="headerlink" title="信息简史（James Gleick）"></a>信息简史（James Gleick）</h2><p>书籍讲述了人类与信息遭遇的历史。James从非洲的鼓语讲起（第1章），后续章节进而讲述了这段历史上凡个影响深远的关键事件，包括文字的发明、罗伯特·考德里的第一本英语词典到沙普兄弟的信号塔与摩尔斯电码(第2-5章)。但人类开始自觉地理解和利用信息始于克劳德·香农在1948年创立的信息论(第6、7章)。香农的信息论不仅推动了信息技术的发展，也改变了人们对于诸如麦克斯韦妖、生命的编码等(第9-13章)的理解。现如今，信息如洪流般淹没了我们，而维基百科、Google(第14、15章)便是我们的应对之一。书中细致还原了历史细节，通俗解释了各种理论，还生动刻画了几位人物，是一本值得阅读学习的书籍。</p>
<h2 id="大流感——最致命瘟疫的史诗（约翰·M·巴里）"><a href="#大流感——最致命瘟疫的史诗（约翰·M·巴里）" class="headerlink" title="大流感——最致命瘟疫的史诗（约翰·M·巴里）"></a>大流感——最致命瘟疫的史诗（约翰·M·巴里）</h2><p>如今这个环境下看这本书，真的是分外应景。这是一本备受好评的书籍，还在2005年被美国科学院评为年度最佳科学&#x2F;医学类图书。<br>大流感指的是1918-1919年横扫世界的那次流感大流行，过去估计全球死亡人数约2000万，最新的权威估计数字为5000万-1亿。这个数字不仅高于历年来命丧艾滋病的人数总和，更远超中世纪黑死病所造成的死亡人数。本书作者依据大量的历史资料和数据，重绘1918年的惨状，为我们再现了这场最致命瘟疫发生、发展及其肆虐全球的过程。在本书中，作者多线索展开论述，纵横交错地记述了有史以来最具毁灭性的流感故事，以及20世纪科学与医学发展的历史。本书细致入微地描写了科学、政治与疾病传播互动的过程，并述及传统医学演化至现代医学的重要里程碑，以及当年科学家、医学工作者等在巨大压力下所显示出的勇气或怯懦，信仰、价值观、研究态度和方法……这部著作不只是简单讲述1918年发生的事件，它同时也是一部权威性的有关科学、政治和文化的传奇。</p>
<h2 id="量子之谜——物理学遇到意识（布鲁斯·罗森布鲁姆）"><a href="#量子之谜——物理学遇到意识（布鲁斯·罗森布鲁姆）" class="headerlink" title="量子之谜——物理学遇到意识（布鲁斯·罗森布鲁姆）"></a>量子之谜——物理学遇到意识（布鲁斯·罗森布鲁姆）</h2><p>为理解原子结构，物理学家提出了量子力学这一科学上最为成功的理论。量子力学获得了惊人的成功，至今没有一项理论预言是错的。目前，这一理论已成为全球经济三分之一生产力的基础。然而，量子力学还是显得迷雾重重。<br>它告诉我们，物理实在是由观察产生的，并且这种“幽灵作用”能够在两个相距遥远的事件之间瞬时传递–无须借助物理力。作者在书里描述了一些无可争议的实验事实以及量子理论对它们的公认解释，用非专业术语浅显明了地阐述了现今各种各样的解释以及每一种这类解释如何遇到意识上的困境，同时介绍了近年来对量子力学的基础和奥秘的研究和应用的最新进展。《量子之谜》对量子实验事实的描述，以及量子理论对这些事实的解释，是无可争辩的。但要对所有这些事实给出统一的说明则将产生激烈争论。而且，量子物理的每一个说明都牵扯到意识。因此，罗森布鲁姆和库特纳转而去探索意识本身及其与量子力学的遭遇。由此，自由意志和人择原理变得重要起来。某些顶级量子宇宙学家提出的意识与宇宙之间联系的概念非常值得玩味。所以，到底是客观恒定的物理世界还是主观意识的精神世界？量子力学，将两者联系在一起。<br>量子理论也否定了常识性的物理，证明牛顿世界观在根本上是有缺陷的。“牛顿物理学”只是一种用来描述比分子大得多的物体的绝好的近似理论，是一种近似处理，对于原子构成的微观世界，无能为力。<br>粗略来说，量子理论告诉我们，对一物的观察可以瞬间影响到遥远距离之外的另一个物体的行为（<strong>纠缠</strong>），即使两者间没有任何连接。另外，一个物体可以同时出现在两个地方（<strong>叠加态</strong>），只有在对其<strong>观察</strong>后我们才能发现它恰好在某个特定的地方（<strong>坍缩</strong>），这个发现会触发历史，时间倒退。因此，量子理论否认存在一个独立于观察的物理实在世界。为了使叠加态发生坍缩，量子理论需要一个有意识的观察者。</p>
<h2 id="科学研究的艺术（William-Ian-Beardmore-Beveridge）"><a href="#科学研究的艺术（William-Ian-Beardmore-Beveridge）" class="headerlink" title="科学研究的艺术（William Ian Beardmore Beveridge）"></a>科学研究的艺术（William Ian Beardmore Beveridge）</h2><p>这是一本论述科学研究的实践与思维技巧的书，分析了在科学上作出新发现的方法，总结了经验教训，还提出了指导原则与技巧建议。作者把这些知识顺理成章，并成文记录，是很值得敬佩的。推荐做研究的朋友阅读。</p>
<h1 id="Chapter3-全球化与领导力"><a href="#Chapter3-全球化与领导力" class="headerlink" title="Chapter3 全球化与领导力"></a>Chapter3 全球化与领导力</h1><h2 id="世界是平的——21世纪简史（托马斯·弗里德曼）"><a href="#世界是平的——21世纪简史（托马斯·弗里德曼）" class="headerlink" title="世界是平的——21世纪简史（托马斯·弗里德曼）"></a>世界是平的——21世纪简史（托马斯·弗里德曼）</h2><p>首先这个作者很有趣，他的著作有：《从贝鲁特到耶路撒冷：美国记者中东见闻录》、《凌志车与橄榄树：理解全球化》、《世界是平的–21世纪简史》、《世界又热又平又挤》等等。他非常擅长以小见大，作品生动形象。<br>选文部分是《第五大扁平理论–外包：Y2K》，带我们重现历史，了解印度在21世纪的科技崛起。<br>印度几乎没有自然资源，这也令它特别注重开发国民的脑力资本。印度有很多高等学府，以严格的标准，比哈佛、麻省理工更激励的竞争，生产和出口工程、计算机和软件人才。20世纪90年代中期，印度不能提供很好的工作机会，于是美国成了印度科技人才的第二买家。印度纳税人培养出来的人才极大地丰富了美国的头脑。<br>然而，在20世纪末，全球光纤电缆的铺设让世界变平坦了，印度人民可以待在家里，出口脑力劳动了。而这笔不小的基建费用，美国帮印度买单了。美国股东发现，印度具有大量的人才，于是他们开始把一些IT工作外包给印度的科技公司。不仅成本下降，而且速度、效率都大大提升了。美国和印度之间12小时的时差，让印度人可以在美国人睡觉的时候工作。但是，印度真正证明自己的实力，并登上世界科技的舞台表演，是从Y2K计算机危机–“千年虫”开始的【就问你精不精彩？】。当时的计算机系统普遍用6位数字表示时间，yymmdd。所以到了1999年12月31日，危机就来了。日期变成了000101，但是计算机无法区别1900年以及2000年。所以大量的计算机需要调整内部时钟和相关系统。这是一个一次性的工作，而且非常的单调乏味。西方公司不想做，他们想以很低的价格外包出去。那么，谁可以完成这项庞大而繁琐的工程呢？印度人。Y2K过去之后，电子商务又带来了新的商机。印度外包公司和美国科技工作又一次更加紧密地携手。更大的机遇在美国网络泡沫破裂，股市滑坡，投资资金短缺。美国幸存的公司要在没有钱的情况下，也把活给干了。咋办？找质优价廉的印度小伙伴啊。并且，有很多本来出口到美国的印度小伙伴，因为泡沫破裂回到了印度。<br>印度的IT公司也开始有了新的想法，它们不在局限于Y2K这种简单的活，开始了解美国公司的业务流程以及后台开发。他们不仅仅满足于帮他们解决问题，还开始开发自己的产品，从维修公司开始转型到产品公司，并提供一系列的服务和咨询。他们不仅保持着价格优势，还学习能力和动力超强，不断诱惑美国公司购买他们的产品及服务。<br>印度的技术崛起离不开Y2K的机遇，更少不了他们辛勤的工作、良好的教育和老一代领导人的正确决策。</p>
<h2 id="帝国——全球化的政治秩序（Michael-Hardt-Antonio-Negri）"><a href="#帝国——全球化的政治秩序（Michael-Hardt-Antonio-Negri）" class="headerlink" title="帝国——全球化的政治秩序（Michael Hardt &amp; Antonio Negri）"></a>帝国——全球化的政治秩序（Michael Hardt &amp; Antonio Negri）</h2><p>【不感兴趣，拜拜】</p>
<h2 id="文化与组织心理软件的力量（吉尔特·霍夫斯泰德-格特·杨·霍夫斯泰德【父子】）"><a href="#文化与组织心理软件的力量（吉尔特·霍夫斯泰德-格特·杨·霍夫斯泰德【父子】）" class="headerlink" title="文化与组织心理软件的力量（吉尔特·霍夫斯泰德 &amp; 格特·杨·霍夫斯泰德【父子】）"></a>文化与组织心理软件的力量（吉尔特·霍夫斯泰德 &amp; 格特·杨·霍夫斯泰德【父子】）</h2><p>该书详细介绍了国家文化差异的五维度模型：权力距离、个体主义-集体主义、不确定性规避、阳刚气质-阴柔气质和短期导向-长期导向。它以大量的数据和事实，分析了全球70多个国家和地区在五个维度上的差异，并运用该模型剖析了政治体制、经济发展、社会生活、法律制度等的文化根源（第二至六章）。第七、八章阐述了国家文化与组织文化的差别以及国家文化差异对组织职能和组织文化的影响。最后两章，通过跨文化情境中的文化碰撞和融合点明了本书希望带给读者的启发意义：在多元文化的世界中求同存异。<br>【可能有趣吧，但节选剪辑无爱了】</p>
<h2 id="文明的冲突与世界秩序的重建（塞缪尔·亨廷顿）"><a href="#文明的冲突与世界秩序的重建（塞缪尔·亨廷顿）" class="headerlink" title="文明的冲突与世界秩序的重建（塞缪尔·亨廷顿）"></a>文明的冲突与世界秩序的重建（塞缪尔·亨廷顿）</h2><h2 id="从传统人到现代人——六个发展中国家的个人变化（阿历克斯·英格尔斯-戴维·H·史密斯）"><a href="#从传统人到现代人——六个发展中国家的个人变化（阿历克斯·英格尔斯-戴维·H·史密斯）" class="headerlink" title="从传统人到现代人——六个发展中国家的个人变化（阿历克斯·英格尔斯 &amp; 戴维·H·史密斯）"></a>从传统人到现代人——六个发展中国家的个人变化（阿历克斯·英格尔斯 &amp; 戴维·H·史密斯）</h2><h2 id="控制论：或关于在动物和机器中控制和通讯的科学（Noebert-Wiener）"><a href="#控制论：或关于在动物和机器中控制和通讯的科学（Noebert-Wiener）" class="headerlink" title="控制论：或关于在动物和机器中控制和通讯的科学（Noebert Wiener）"></a>控制论：或关于在动物和机器中控制和通讯的科学（Noebert Wiener）</h2><h2 id="卓有成效的管理者（彼得·德鲁克）"><a href="#卓有成效的管理者（彼得·德鲁克）" class="headerlink" title="卓有成效的管理者（彼得·德鲁克）"></a>卓有成效的管理者（彼得·德鲁克）</h2><p>是一本传授读者如何管理自己的经验和技巧的书籍，也许值得一读，此处略过。</p>
<h2 id="变革的力量领导与管理的差异"><a href="#变革的力量领导与管理的差异" class="headerlink" title="变革的力量领导与管理的差异"></a>变革的力量领导与管理的差异</h2><p>节选部分告诉我领导和管理有很大的区别，一个公司的成功，两者不可缺其一。但我还是觉得光有理论，没有机会实践是没有用的，所以，比起我，这本书更适合各位老板阅读。</p>
<h2 id="个人和组织的未来（Charles-Handy）"><a href="#个人和组织的未来（Charles-Handy）" class="headerlink" title="个人和组织的未来（Charles Handy）"></a>个人和组织的未来（Charles Handy）</h2><p>也许值得一读，此处略过。</p>
<h2 id="《孙子兵法》译注（郭化若）"><a href="#《孙子兵法》译注（郭化若）" class="headerlink" title="《孙子兵法》译注（郭化若）"></a>《孙子兵法》译注（郭化若）</h2><p>《孙子兵法》内在的逻辑体系分为四层：第一层是兵战起于危，落于利，其最高境界是“全胜”，即“不战而胜”、“不战而屈人之兵”；第二层是“先知”，未战必先“计谋”，而“计谋”必“用间”，要从知道敌人情况的人那里获得情报，并以此进行“庙算”；第三层是“知胜”，“知胜有五”，这五个方面是胜利的必要条件；第四层次是“为胜”，通过“诡道”、“神速”、“以迂为直”等战术，从而“致人而不致于人”，以谋取胜利。<br>《孙子兵法》可用九个字表达，利危一&gt;先知一&gt;知胜一&gt;为胜-&gt;胜（全胜）。利危是兵战任何行动的准则，贯彻行动始终；未战必须先算，必须先知；先知而后知战道，知战略；战略通过一系列为胜之战术，获取整个战役一个接一个的局部的战场胜利；不论是整个战役，还是局部战场，“兵贵胜”， 但“不战而胜”是兵家为战最高境界。全胜者即不战而胜者，是优秀将军中的最优秀者。</p>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>我目前为止，写得最长的一篇读书笔记了，可能这个记录还会保持很久的时间。<br>写这个笔记的时候，我又把书重新读了一篇，真的是每一遍都有新的发现。宝藏！</p>
<h3 id="当前排行榜："><a href="#当前排行榜：" class="headerlink" title="当前排行榜："></a>当前排行榜：</h3><ul>
<li><a href="./#%E4%B8%96%E7%95%8C%E6%98%AF%E5%B9%B3%E7%9A%84%E2%80%94%E2%80%9421%E4%B8%96%E7%BA%AA%E7%AE%80%E5%8F%B2%EF%BC%88%E6%89%98%E9%A9%AC%E6%96%AF%C2%B7%E5%BC%97%E9%87%8C%E5%BE%B7%E6%9B%BC%EF%BC%89">世界是平的——21世纪简史（托马斯·弗里德曼）</a></li>
<li><a href="./#%E6%96%B0%E5%8D%96%E6%A1%94%E8%80%85%E8%A8%80%EF%BC%88Steve-N-S-Chueng-%E5%BC%A0%E4%BA%94%E5%B8%B8%EF%BC%89">新卖桔者言（Steve. N.S. Chueng, 张五常）</a></li>
<li><a href="./#%E9%87%8F%E5%AD%90%E4%B9%8B%E8%B0%9C%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%AD%A6%E9%81%87%E5%88%B0%E6%84%8F%E8%AF%86%EF%BC%88%E5%B8%83%E9%B2%81%E6%96%AF%C2%B7%E7%BD%97%E6%A3%AE%E5%B8%83%E9%B2%81%E5%A7%86%EF%BC%89">量子之谜——物理学遇到意识（布鲁斯·罗森布鲁姆）</a></li>
<li><a href="./#%E6%BC%AB%E6%B8%B8%E8%AF%BA%E8%B4%9D%E5%B0%94%E5%A5%96%E5%88%9B%E9%80%A0%E7%9A%84%E4%B8%96%E7%95%8C%E4%B8%80%E2%80%94%E2%80%94%E5%8C%96%E5%AD%A6%E4%B9%8B%E6%97%85%EF%BC%88%E6%9D%8E%E9%92%9F%E9%95%90%EF%BC%89">漫游诺贝尔奖创造的世界一——化学之旅（李钟镐）</a></li>
<li><a href="./#%E4%B8%AD%E5%9B%BD%E4%BA%BA%EF%BC%88%E6%9E%97%E8%AF%AD%E5%A0%82%EF%BC%89">中国人（林语堂）</a></li>
<li><a href="./#%E4%BF%A1%E6%81%AF%E7%AE%80%E5%8F%B2%EF%BC%88James-Gleick%EF%BC%89">信息简史（James Gleick）</a></li>
<li><a href="./#%E4%B9%A1%E5%9C%9F%E4%B8%AD%E5%9B%BD%EF%BC%88%E8%B4%B9%E5%AD%9D%E9%80%9A%EF%BC%89">乡土中国（费孝通）</a></li>
<li><a href="./#%E6%97%B6%E9%97%B4%E7%AE%80%E5%8F%B2%E2%80%94%E2%80%94%E4%BB%8E%E5%A4%A7%E7%88%86%E7%82%B8%E5%88%B0%E9%BB%91%E6%B4%9E%EF%BC%88Stephen-Hawking%EF%BC%89">时间简史——从大爆炸到黑洞（Stephen Hawking）</a></li>
<li><a href="./#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E5%AD%A6%EF%BC%9A%E5%AF%B9%E6%80%9D%E6%83%B3%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A0%94%E7%A9%B6%EF%BC%88Richard-Courant%EF%BC%89">什么是数学：对思想和方法的基本研究（Richard Courant）</a></li>
<li><a href="./#%E5%A4%A7%E6%B5%81%E6%84%9F%E2%80%94%E2%80%94%E6%9C%80%E8%87%B4%E5%91%BD%E7%98%9F%E7%96%AB%E7%9A%84%E5%8F%B2%E8%AF%97%EF%BC%88%E7%BA%A6%E7%BF%B0%C2%B7M%C2%B7%E5%B7%B4%E9%87%8C%EF%BC%89">大流感——最致命瘟疫的史诗（约翰·M·巴里）</a></li>
<li><a href="./#%E5%8D%83%E4%BA%BF%E4%B8%AA%E5%A4%AA%E9%98%B3%E2%80%94%E2%80%94%E6%81%92%E6%98%9F%E7%9A%84%E8%AF%9E%E7%94%9F%E3%80%81%E6%BC%94%E5%8F%98%E5%92%8C%E8%A1%B0%E4%BA%A1%EF%BC%88%E9%B2%81%E9%81%93%E5%A4%AB%EF%BC%89">千亿个太阳——恒星的诞生、演变和衰亡（鲁道夫）</a></li>
</ul>
<img  src="../../../../../pics/reading/nrp/nju-readings-part1.jpg"   width="100"><span class="image-caption">南大读本-社会/自然科学卷</span>

<h1 id="See-you-next-book"><a href="#See-you-next-book" class="headerlink" title="See you next book!"></a>See you next book!</h1>]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>穷查理宝典-查理·芒格的智慧箴言录</title>
    <url>/reading/poor-charlies-almanack/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>这本书是借来的，借书给我向来有不还的风险。读书人借书不还，能叫老赖么？<br>主要还是因为不爱读书，书读得太慢了。好歹是借来的书，没读完不好意思还给人家啊。<br>而且借来的书，阅读的机会只有一次当然要好好珍惜。<br>这本书借了大概有三四年，如今终于全篇读完，开始写读后感了。<br>除去前序的序言、鸣谢和导读，全书共分五章。第一章主要是查理·芒格的传略，介绍一下这个人，他的一些特点，和周围人对于他的评价，会小小剧透后面的一些观点。这章还有一篇在我看来有些乱入的 <strong>《歌颂长者：芒格论晚年-受西塞罗&lt;论老年&gt;启发》</strong> ，我特别喜欢，我觉得所有老年人和拥有年龄焦虑的人都应该读一下这篇文章，找了两个链接，一个是体验感满分的<a href="https://www.zhihu.com/pub/reader/119564333/chapter/964877467132059648">知乎读书的链接</a>，还有一个备用，<a href="https://www.douban.com/group/topic/29066331/">豆瓣鹅手打的章节</a>。第二章是说芒格的生活、学习和决策方法。第三章是芒格主义，一次查理的即席谈话。第四章，查理十一讲，是本书的重中之重，占了最多的篇幅，也是内容和干货最多的地方。第五章是一些文章、报道与评论，有芒格写的，也有别人写他的。</p>
<p>我是想要提炼一下最精华的部分，可是全书信息量太大，最后写的读后感也超长，所以在此再斗胆总结一下，查理思想最重要的部分是：</p>
<ol>
<li>多元思维模型，不要做手拿铁锤的人</li>
<li>运用好思维清单，时刻检查、自省，避免遗漏重要部分</li>
<li>逆向思维</li>
<li>了解基本心理学模型，提防陷阱，巧妙利用</li>
<li>思考与美德</li>
</ol>
<p>最后，希望1924年出生的查理老爷爷继续超长待机。</p>
<h1 id="第一讲：在哈佛学校毕业典礼上的演讲"><a href="#第一讲：在哈佛学校毕业典礼上的演讲" class="headerlink" title="第一讲：在哈佛学校毕业典礼上的演讲"></a>第一讲：在哈佛学校毕业典礼上的演讲</h1><p>确保痛苦生活的处方：</p>
<ul>
<li>为了改变心情或者感觉而使用化学物质</li>
<li>妒忌</li>
<li>怨恨</li>
<li>反复无常，不要虔诚地做你正在做的事情，不要成为一个<strong>可靠</strong>的人</li>
<li>尽可能从自身的经验获得知识，尽量别从其他人成功或失败的经验中广泛地吸取教训，不管他们是古人还是今人。别去钻研那些前辈的最好成果</li>
<li>当人生的战场上遭遇第一、第二或者第三次严重的失败时，请意志消沉，从此一蹶不振吧</li>
<li>别考虑逆向思维</li>
<li>尽可能地减少客观性，减少获得世俗好处所需作出的让步以及所要承受的负担，从而在无知的道路上越走越远</li>
</ul>
<p>漫长的人生要日日以避免失败为目标而成长。</p>
<h1 id="第二讲：论基本的、普世的智慧，及其与投资管理和商业的关系"><a href="#第二讲：论基本的、普世的智慧，及其与投资管理和商业的关系" class="headerlink" title="第二讲：论基本的、普世的智慧，及其与投资管理和商业的关系"></a>第二讲：论基本的、普世的智慧，及其与投资管理和商业的关系</h1><p><img  src="/../../../../../pics/reading/pca/poor-charlies-almanack-0.png"  ><span class="image-caption">读书笔记-第二讲</span></p>
<p>有趣的小节选：</p>
<blockquote>
<p>例如，以前我们做过纺织品生意，那是个非常糟糕的无特性商品行业，我们当时生产的是低端的纺织品——那是真正的无特性商品。有一天，有个人对沃伦说：“有人发明了一种新的纺织机，我们认为它的效率是旧纺织机的两倍。”沃伦说：“天哪,我希望这种新机器没这么厉害——因为如果它确实这么厉害的话，我就要把工厂关掉了。”他并不是在开玩笑。<br>他是怎么想的呢？他的想法是这样的：“这是很糟糕的生意。我们的利润率很低，我们让它开着，是为了照顾那些年纪大的工人。但我们不会再投入巨额的资本给一家糟糕的企业了。”<br>他知道，更好的机器能极大地提高生产力，但最终受益的是那些购买纺织品的人。厂家什么好处也得不到。<br>这个道理很浅显——有好些各式新发明虽然很棒，但只会让你们花冤枉钱，你们的企业就算采用了它们也改变不了江河日下的命运。因为钱不会落到你手里。改善生产带来的所有好处都流向消费者了。<br>与之相反,如果你拥有奥斯科什惟一的报纸，有人发明了更为有效的排版技术，然后你甩掉旧的技术，买进花哨的新电脑之类的，那么你的钱不会白花，节约下来的成本还是会回到你手上。<br>总之，那些推销机器的人——甚至是企业内部那些催促你购买设备的员工——会跟你说使用新技术将会为你节省多少成本。然而，他们并没有进行第二步分析——也就是弄清楚有多少钱会落在你手里，多少钱会流向消费者。我从来没有见到有哪个人提出过这第二步分析。我总是遇到这些人，他们总是说：“你只要购买这些新技术，三年之内就能把成本收回来。”<br>所以你不断地购买一些三年内可以收回成本的新玩意，这么做了20年之后，你获得的年均回报率只有不到4%。这就是纺织业。<br>并不是说那些机器不好，只是节省下来的钱没有落到你手里。成本确实降低了，但那个购买设备的家伙并没有得到成本降低带来的好处。这个道理很简单，很初级，可是却经常被人忘记。</p>
</blockquote>
<blockquote>
<p>帕特森是个小零售商，没赚到什么钱。有一天，有人卖给他一台早期的收款机，他把它放到商店的收银台。这台收款机立刻让他扭亏为盈，因为有了它之后，店里的职员想偷钱就难多了。但帕特森是个聪明人，他并没有想：“这对我的零售店有帮助。”他的想法是：“我要做收款机的生意。”自然，他创办了国民收款机公司，并且飞黄腾达了。</p>
</blockquote>
<blockquote>
<p>我曾经遇到一个卖鱼钩的家伙。我问他：“天哪，你这些鱼钩居然是绿色的和紫色的。鱼真的会上钩么？”他说：“先生，我又不是卖给鱼的。”所以，决定行为的是决策者的激励机制，制定正确的激励机制是非常非常重要的。</p>
</blockquote>
<blockquote>
<p>年轻人在工作中应该追求什么？<br>三个基本原则，要努力尝试：</p>
<ul>
<li>别兜售你自己不会购买的东西</li>
<li>别为你不尊敬和钦佩的人工作</li>
<li>只跟你喜欢的人同事</li>
</ul>
</blockquote>
<blockquote>
<p>你对年轻人有什么人生建议？<br>每天起床的时候，争取变得比从前更聪明一点。认真地、出色地完成你的任务。<br>人生在不同阶段会遇到不同的难题，非常棘手的难题。我认为有三点有助于应付这些困难：</p>
<ul>
<li>期望别太高</li>
<li>拥有幽默感</li>
<li>让自己置身于朋友和家人的爱之中。<br>  最重要的是，要适应生活的变化。</li>
</ul>
</blockquote>
<h1 id="第三讲：论基本的、普世的智慧（修正稿）"><a href="#第三讲：论基本的、普世的智慧（修正稿）" class="headerlink" title="第三讲：论基本的、普世的智慧（修正稿）"></a>第三讲：论基本的、普世的智慧（修正稿）</h1><p>需要在头脑里形成一个由各种思维模型构成的框架，然后将实际经验和间接经验悬挂在这个强大的思维模型架上。</p>
<ol>
<li>必须掌握跨学科的、全面的技能</li>
<li>思考问题时，正反面都要考虑</li>
<li>自我训练，把自己训练得更加客观</li>
<li>警惕严重的意识形态偏见，别把自己的观点当作不可动摇的真理</li>
<li>掌握所有主要的心理学模型，作为检查清单，用来审视各种复杂系统的结果</li>
</ol>
<p>有趣的小节选：</p>
<blockquote>
<p>从前有个人卖的鱼肉叫卡奈森鱼肉。商标的名字叫卡奈森，与大食品公司卡奈森相似。所以卡奈森公司想收购他的品牌。每次卡奈森公司的人跑去和他说：“我们愿意给你25万美元。”他说：“我要40万美元。”四年之后，他们说：“我们愿意给你100万。”他说：“我要200万。”他们就一直讨价还价，没有达成交易。最后，卡奈森公司的人无奈地去和那个人说：“我们打算派遣我们的质量检查员到你的鱼肉厂，以确保你生产的鱼肉都是完美的，所有的费用由我们承担。”那人非常开心，很快就同意了，他的鱼肉厂得到了免费的质量管理服务。由此，如果你给某个家伙一个商标，你就创造了巨大的激励机制。</p>
</blockquote>
<blockquote>
<p>库克船长生前经常远行。那个年代，远行的克星是坏血病。库克船长发现荷兰船上的坏血病没有英国船上的严重。于是，他询问、比较发现荷兰船上有很多酸泡菜。英国人讨厌“泡菜”，如何让他们吃泡菜，又不告诉他们这是一次有坏血病感染风险的远航？他是这么做的：他召集所有官员聚集，吃酸泡菜，并且可以被普通水手看见，但不让普通水手吃。经过一段长时间后，库克准许普通水手每周有一天可以吃酸泡菜。这样挽救了很多人的生命。</p>
</blockquote>
<blockquote>
<p>与其创立一些有漏洞的制度，还不如就不要创建了。有一个得克萨斯州的一家制造工业产品的工厂，利润微薄，艰难维持。工厂里有很多炸伤骗保的事情，导致每年支付的赔偿金达到了总薪酬支出的一成多。而工人们的工作并没有啥风险。厂长哀求工会：“你们不能再这么做了。这种产品的利润还没你们到手的钱多。”但每个人已经习惯了这么做，这是默认的额外收入，每个人都在这么做。工会代表很难告诉所有人这种容易到手的钱再也没有了。因为，当人们听到坏消息，它们会讨厌带来消息的人。所以，后面这家工厂关闭了，厂长在其他地方重振旗鼓。这种悲剧是由容许作恶的态度引起的。如果不及时采取行动，及早制止作恶，那么制止人们继续作恶和到的败坏是很难的。</p>
</blockquote>
<blockquote>
<p>在使用哪些装备了基本的心理学力量的技巧之前，人们必须依据道德规范来调整自己的行为，并不是懂得如何操控人们之后，就可以随心所欲地去操控他们。</p>
</blockquote>
<blockquote>
<p>学习是为了少犯一些错误，也能够在犯错之后，更快地纠正错误。但既要过上富足的生活，又不犯很多错误是不可能的。实际上，生活要求我们会处理错误。生活有时候就像扑克游戏，有时候即使拿到一把非常喜欢的牌，但也必须学会放弃。</p>
</blockquote>
<blockquote>
<p>当你不了解、也没有相关的才能时，不要害怕说出来。有些人总是很自信地回答他们其实并不了解的问题，就像那只乱跳舞的蜜蜂，只会把整个蜂窝搞得乱哄哄的。</p>
</blockquote>
<h1 id="第四讲：关于现实思维的现实思考？"><a href="#第四讲：关于现实思维的现实思考？" class="headerlink" title="第四讲：关于现实思维的现实思考？"></a>第四讲：关于现实思维的现实思考？</h1><p>五个超级简单的普遍观念：</p>
<ol>
<li>简化任务的最佳方法是先解决那些答案显而易见的大问题</li>
<li>数学运算能力对日常生活非常重要</li>
<li>正面思考有局限，必须进行反面思考</li>
<li>最好的、最具有实践性的智慧是基本的学术智慧，熟练掌握各学科的基本概念，以跨学科的方式思考，解决问题的方法将不会受到限制，相反，从利益角度出发，潜意识的偏见会导致认知缺陷，带来麻烦</li>
<li>真正的大效应通常在几种因素的共同作用下才会出现</li>
</ol>
<p>有趣的小节选：</p>
<blockquote>
<p>爱因斯坦自述，他的成就取决于四个因素：自我批评；好奇心；专注；毅力。</p>
</blockquote>
<blockquote>
<p>“需要新的机器而尚未购买的公司，其实已经在为它花钱了。”</p>
</blockquote>
<h1 id="第五讲：专业人士需要更多的跨学科技能"><a href="#第五讲：专业人士需要更多的跨学科技能" class="headerlink" title="第五讲：专业人士需要更多的跨学科技能"></a>第五讲：专业人士需要更多的跨学科技能</h1><p><img  src="/../../../../../pics/reading/pca/poor-charlies-almanack-1.png"  ><span class="image-caption">读书笔记-第五讲</span></p>
<h1 id="第六讲：一流慈善基金的投资实践"><a href="#第六讲：一流慈善基金的投资实践" class="headerlink" title="第六讲：一流慈善基金的投资实践"></a>第六讲：一流慈善基金的投资实践</h1><h1 id="第七讲：在慈善圆桌会议早餐会上的讲话"><a href="#第七讲：在慈善圆桌会议早餐会上的讲话" class="headerlink" title="第七讲：在慈善圆桌会议早餐会上的讲话"></a>第七讲：在慈善圆桌会议早餐会上的讲话</h1><p>太过专业了，在这两讲中，查理批评了慈善基金现在投资的一下做法，并给出了一些投资的建议。他认为个人产生的微观的错误投资会给宏观经济带来伤害。</p>
<h1 id="第八讲：2003年的金融大丑闻"><a href="#第八讲：2003年的金融大丑闻" class="headerlink" title="第八讲：2003年的金融大丑闻"></a>第八讲：2003年的金融大丑闻</h1><p>这是一篇查理在2000年写下的寓言。它讲述了一个宽特科技公司的故事。前期，创始人宽特苦心经营，创造了一个道德高尚的黄金时代。可是，后期，由于更换管理层，新的管理层采用现代的金融工程技巧，而毁掉公司名望，最后关门大吉的故事。其中最大的错误是新的管理层启用了股票期权的激励制度却没有将股票期权算作公司成本。查理认为，做假账无异于在盖高层公寓楼的时候把钢筋从水泥中抽走，涉及到的行业和国家必将学到惨痛的教训。可惜的是，给人们带来好处的罪恶很难被消除，因为大量的人认为，一件事只要能给他们带来利润，就不可能是罪恶的。<br>整篇故事的叙述非常幽默，尤其是结局之后，查理从上帝的视角去追责的过程，我们可以一层一层深入探索错误源头。十分有趣。<br><img  src="/../../../../../pics/reading/pca/poor-charlies-almanack-2.png"  ><span class="image-caption">读书笔记-第八讲</span></p>
<h1 id="第九讲：论学院经济派：考虑跨学科需求之后的优点和缺点"><a href="#第九讲：论学院经济派：考虑跨学科需求之后的优点和缺点" class="headerlink" title="第九讲：论学院经济派：考虑跨学科需求之后的优点和缺点"></a>第九讲：论学院经济派：考虑跨学科需求之后的优点和缺点</h1><p>优点：</p>
<ol>
<li>生逢其时，生逢其地：<ul>
<li>人均产值快速增长</li>
<li>计划经济崩溃，自由市场&#x2F;半自由市场经济蓬勃发展</li>
<li>市场与经济学相互促进发展</li>
</ul>
</li>
<li>更加强调跨学科研究<ul>
<li>机会成本</li>
<li>激励机制</li>
<li>“公用品悲剧”</li>
</ul>
</li>
<li>拥有最优秀的人才<ul>
<li>入世深</li>
<li>历史长</li>
<li>伟大的作家</li>
</ul>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>致命的自闭——“铁锤人综合症”<br> 拥有全套工具（检查清单）VS 只有一把铁锤</li>
<li>没有采用硬科学的全归因治学方法<br> 吸收了其他学科的知识，却没有指出知识来源 &#x3D; 糟糕的文档归类方法<br> “拿来主义”</li>
<li>物理学妒忌<br> 过于教条和期待精准理论，e.g. 采用有效市场理论</li>
<li>太过强调宏观经济学，轻视微观经济学<ul>
<li>微观经济学有助于帮助理解宏观经济学</li>
<li>宏观经济学不够准确</li>
<li>极度成功的原因<ol>
<li>将一到两个因素最大化或最小化，e.g. 好市多</li>
<li>增加一些成功的因素，以便取得非线性的成效提高</li>
<li>将几个优点发挥得淋漓尽致，e.g. 丰田</li>
<li>顺应某些重大的潮流，e.g. 甲骨文</li>
</ol>
</li>
</ul>
</li>
<li>经济学的综合太少<ul>
<li>人们很少综合地思考经济学问题</li>
<li>综合考虑问题往往能找到关键的解决方法</li>
</ul>
</li>
<li>对心理学的极度物质及其造成的负面后果</li>
<li>对二级或者更高级别的效应关注太少<ul>
<li>为了得出答案，而过度简化问题的错误</li>
<li>事实上，所有社会制度都会被钻空子</li>
</ul>
</li>
<li>对“捞灰金”的概念关注太少<ul>
<li>“捞灰金”是一个最简单、最基本的数学原理</li>
</ul>
</li>
<li>对美德效应和恶行效应不够重视<ul>
<li>对整体公平的制度对个体不一定公平 &#x3D;&gt; 容忍对某些人不公平，可以换取对所有人的公平</li>
<li>恶行对经济产生了巨大影响，欺诈和愚蠢造成的经济泡沫无处不在</li>
<li>人们执迷不悟地坚持错误的观念和做法</li>
<li>爱因斯坦成功的理论：好奇、专注、毅力和自省</li>
<li>粗略的正确好过精准的错误</li>
</ul>
</li>
</ol>
<blockquote>
<p>我曾经向两个不同的商学院班级提出下面这个问题。我说：“你们已经学习了供给和需求曲线。你们懂得在一般情况下，当你们提高商品的价格，这种商品的销量就会下跌；当你们降低价格，销量就会上升。对吧？你们学过这个理论吧？”他们全都点头表示同意。然后我说：“现在向我举几个例子，说明你们要是想提高销量，正确的做法是提高价格。”他们沉默了非常久。在我提出这个问题的两所商学院里，也许50个人里面有一个能够举出一个例子。但在这两所现代的商学院，50个人里面居然只有一个人能够举出一个例子——其中一所还是很难考上的斯坦福商学院。而且没有一个人能够给出我欣赏的主要答案。<br>这个问题有四类答案。少数人知道第一类答案，但他们基本上不知道其他类。</p>
<ol>
<li>奢侈品：提高价格能够改善奢侈品的“炫耀”功能，例如，奢侈品提高价格之后，在某些存在炫耀心理的消费者看来，它的性能也随之改善了。此外，人们往往认为价格高等于质量好，这有时也能促进销量的增加。</li>
<li>非奢侈品：和上面提到的第二个因素相同，消费者看到价格更高的商品，往往不是认为它卖贵了，而是认为更高的价格意味着更好的质量。这种办法对那些耐用性的工业品而言尤为适用。</li>
<li>提高价格，把额外的利润以合法的方式用于改善产品的性能或者改善销售系统。</li>
<li>提高价格，把额外的利润以非法或者不道德的方式来促进销售，比如说通过贿赂交易经纪人，或者其他对终端消费者有害的做法——例如开放式基金的销售回扣。（这个答案是我最喜欢的，但我从来没有听到。）</li>
</ol>
</blockquote>
<blockquote>
<p>有一个人白手起家，创立了一个铁钉厂，他辛苦奋斗，终于铁钉厂很成功。在他妻子的见一下，他决定放手去休息，把铁钉厂交给儿子。于是，他去了另一个州生活。他每周还是会关注公司的财务报告，发现情况很糟糕，公司的状况急转直下。他很着急，立刻坐飞机回去查看情况。在他从机场到工厂的路上，看到一块巨大的户外灯箱广告牌，广告牌上是被钉在十字架上的耶稣。耶稣下面有一行文字：“他们使用了利伯维茨牌铁钉。”他气急败坏地感到工厂，对他儿子说：“你这个白痴！你知不知道你在干什么？这家工厂花了我50年的心血！”他儿子说：“爸爸，相信我。我会解决这个问题的。”于是，他又飞回度假区。结果，经营情况持续恶化。他又登上了飞机。路上，他又看到了那块巨大的灯箱广告牌，现在上面是一个空的十字架，耶稣趴在十字架下面的地上，广告语写着：“他们没有用利伯维茨牌铁钉。”</p>
</blockquote>
<h1 id="第十讲：在南加州大学GOULD法学院的毕业典礼上的演讲"><a href="#第十讲：在南加州大学GOULD法学院的毕业典礼上的演讲" class="headerlink" title="第十讲：在南加州大学GOULD法学院的毕业典礼上的演讲"></a>第十讲：在南加州大学GOULD法学院的毕业典礼上的演讲</h1><p>关于人生的简单道理：</p>
<ol>
<li>要得到你想要的某样东西，最可靠的办法是让自己配得上它。己所不欲，勿施于人</li>
<li>正确的爱应该以仰慕为基础，而且我们应该去爱那些对我们有教育意义的先贤</li>
<li>获得智慧是一种道德责任，必须终身学习，人类社会只有发明了发明的方法之后，才能发展，同样的道理，人只有学习了学习的方法之后才能进步</li>
<li>跨学科学习每个学科95%分量的真正重要的大道理，并持续练习，掌握、运用它们</li>
<li>逆向思维</li>
<li>不要懒惰和言而无信</li>
<li>拒绝极端强烈的意识形态，拒绝妒忌、怨憎、仇恨和自恋、偏执</li>
<li>如果你想要说服别人，诉诸利益，而非诉诸理性</li>
<li>避免变态的激励系统，避免变态的工作关系 -&gt; 避免在你们不崇敬或者不想像他一样的人手下干活</li>
<li>养成一些让你能够保持客观公正的习惯，提高认知</li>
<li>培养核对检查清单的习惯 -&gt; 把掌握广泛的基础知识列成一张检查清单</li>
<li>将不平等最大化通常能收到奇效，生活就像比赛，充满竞争，让最有能力和最愿意成为学习机器的人发挥最大的作用</li>
<li>如果真的想要在某个领域做得很出色，那么，必须对它有强烈的兴趣</li>
<li>非常勤奋</li>
<li>做好迎接麻烦的准备</li>
</ol>
<h1 id="第十一讲：人类误判心理学"><a href="#第十一讲：人类误判心理学" class="headerlink" title="第十一讲：人类误判心理学"></a>第十一讲：人类误判心理学</h1><p><img  src="/../../../../../pics/reading/pca/poor-charlies-almanack-3.png"  ><span class="image-caption">读书笔记-第十一讲1</span></p>
<p>这讲的内容非常丰富，查理列举了很多有意义的例子。并且，各种倾向不是相互独立的，他们类似、息息相关、相互促进，同时，又有看似矛盾的部分。当他们综合作用时，又产生了奇妙的效果。我想要通过一些图表展示它们之间的关系，几经尝试之后，最后放弃了，如果读者感兴趣，可以着重读一下干货满满的这一讲。</p>
<p>有趣的小节选：</p>
<blockquote>
<p>一. 奖励和惩罚, 超级反应倾向<br>内布拉斯加州的林肯市，有个外科医生，他手术做得非常好，年复一年地将大量的正常胆囊送到该市最好的医院的病理学实验室。这名医生为什么这么做？难道他心里认为这么做可以证明医术高明？每年通过把正常胆囊切掉来谋害几个病人能让他过上高质量的生活？不是的，真实的原因是，他认为胆囊是所有疾病的祸根，而且如果你真的爱护病人，就应该尽快把这个器官切除掉。</p>
</blockquote>
<blockquote>
<p>寿衣没有口袋</p>
</blockquote>
<blockquote>
<p>谁给我面包吃，我就给谁唱歌</p>
</blockquote>
<blockquote>
<p>五. 避免不一致性倾向<br>本杰明·富兰克林原本是费城一个默默无闻的小人物，当时他想得到某个重要人物的垂青，于是经常设法请那个人帮他一些无关紧要的小忙，比如说借一本书给他之类的。从那以后，那个大人物就更加欣赏和信任富兰克林了，因为一个不值得欣赏、不值得信任的富兰克林与他借书给富兰克林的行为中暗示的赞许并不一致。富兰克林这种操纵别人帮自己忙、从而令别人对自己产生好感的做法，如果反过来使用，也会产生非常变态的效果。如果有个人受到操控，故意不停地去伤害另外一个人，那么他就会倾向于贬低甚至憎恨那个人。这种避免不一致性倾向造成的效应解释了那句谚语所含的道理:“人永远不会忘记自己做过的坏事。”</p>
</blockquote>
<blockquote>
<p>八. 艳羡&#x2F;妒忌倾向<br>驱动世界的不是贪婪，而是妒忌</p>
</blockquote>
<h1 id="查理的检查清单-四种基本的检查清单-（P338）"><a href="#查理的检查清单-四种基本的检查清单-（P338）" class="headerlink" title="查理的检查清单 - 四种基本的检查清单 （P338）"></a>查理的检查清单 - 四种基本的检查清单 （P338）</h1><h2 id="1-双轨分析："><a href="#1-双轨分析：" class="headerlink" title="1. 双轨分析："></a>1. 双轨分析：</h2><ul>
<li>理性地看，哪些因素真正煮到了牵涉到的利益？（例如，宏观的和微观的经济因素）</li>
<li>当大脑处于潜意识状态时，有哪些潜意识因素会自动以各种方式形成虽然有用但往往失灵的结论？（本能、情绪、贪婪等等的影响）</li>
</ul>
<h2 id="2-超级简单的普通观念"><a href="#2-超级简单的普通观念" class="headerlink" title="2. 超级简单的普通观念"></a>2. 超级简单的普通观念</h2><ul>
<li>先解决那些答案显而易见的问题</li>
<li>利用数学运算能力</li>
<li>逆向思考</li>
<li>应用基本的跨学科智慧，永远不要完全依赖他人</li>
<li>注意多种因素的共同作用——也就是lollapalooza效应</li>
</ul>
<h2 id="3-基于心理学的倾向——人类误判的25个标准原因"><a href="#3-基于心理学的倾向——人类误判的25个标准原因" class="headerlink" title="3. 基于心理学的倾向——人类误判的25个标准原因"></a>3. 基于心理学的倾向——人类误判的25个标准原因</h2><h2 id="4-投资和决策检查清单"><a href="#4-投资和决策检查清单" class="headerlink" title="4. 投资和决策检查清单"></a>4. 投资和决策检查清单</h2><ul>
<li>风险 —— 所有投资评估应该从测量风险（尤其是信用的风险）开始<ul>
<li>测算合适的安全边际</li>
<li>避免和道德品质有问题的人交易</li>
<li>坚持为预定的风险要求合适的补偿</li>
<li>永远记住通货膨胀和利率的风险</li>
<li>避免犯下大错；避免资本金持续亏损</li>
</ul>
</li>
<li>独立 —— “唯有在童话中，皇帝才会被告知自己没穿衣服”<ul>
<li>客观和理性的态度需要独立思考</li>
<li>记住，你是对是错，并不取决于别人同意你还是反对你——惟一重要的是你的分析和判断是否正确</li>
<li>随大流只会让你往平均值靠近（只能获得中等的业绩）</li>
</ul>
</li>
<li>准备 —— “惟一的获胜方法是工作、工作、工作、工作，并希望拥有一点洞察力。”<ul>
<li>通过广泛的阅读把自己培养成一个终生自学者；培养好奇心，每天努力使自己聪明一点点</li>
<li>比求胜的意愿更重要的是做好准备的意愿</li>
<li>熟练地掌握各大学科的思维模型</li>
<li>如果你想要变得聪明，你必须不停地追问的问题是“为什么，为什么，为什么”</li>
</ul>
</li>
<li>谦虚 —— 承认自己的无知是智慧的开端<ul>
<li>只在自己明确界定的能力圈内行事</li>
<li>辨认和核查否定性的证据</li>
<li>抵制追求虚假的精确和错误的确定性的欲望</li>
<li>最重要的是，别愚弄你自己，而且要记住，你是最容易被自己愚弄的人</li>
</ul>
</li>
<li>严格分析 —— 使用科学方法和有效的检查清单能够最大限度地减少错误和疏忽<ul>
<li>区分价值和价格、过程和行动、财富和规模</li>
<li>记住浅显的好过掌握深奥的</li>
<li>成为一名商业分析家，而不是市场、宏观经济或者证券分析家</li>
<li>考虑总体的风险和效益，永远关注潜在的二阶效应和更高层次的影响</li>
<li>要朝前想、往后想——反过来想，总是反过来想</li>
</ul>
</li>
<li>配置 —— 正确地配置资本是投资者最重要的工作<ul>
<li>记住，最好的用途总是由第二好的用途衡量出来的（机会成本）</li>
<li>好主意特别少——当时机对你有利时，狠狠地下赌注吧（配置资本）</li>
<li>别“爱上”投资项目——要依情况而定，照机会而行</li>
</ul>
</li>
<li>耐心 —— 克制人类天生爱行动的偏好<ul>
<li>“复利是世界第八大奇迹”（爱因斯坦），不到必要的时候，别去打断它</li>
<li>避免多余的交易税和摩擦成本，永远别为了行动而行动</li>
<li>幸运来临时要保持头脑清醒</li>
<li>享受结果，也享受过程，因为你活在过程当中</li>
</ul>
</li>
<li>决心 —— 当合适的时机出现时，要坚决地采取行动<ul>
<li>当别人贪婪时，要害怕；当别人害怕时，要贪婪</li>
<li>机会来临的次数不多，所以当它来临时，抓住它</li>
<li>机会只眷顾有准备的人：投资就是这样的游戏</li>
</ul>
</li>
<li>改变 —— 在生活中要学会改变和接受无法消除的复杂性<ul>
<li>认识和适应你身边的世界的真实本质，别指望它来适应你</li>
<li>不断地挑战和主动地修正你“最爱的观念”</li>
<li>正视现实，即使你并不喜欢它——尤其当你不喜欢它的时候</li>
</ul>
</li>
<li>专注 —— 别把事情搞复杂，记住你原来要做的事<ul>
<li>记住，声誉和正直是你最有价值的财产——而且能够在瞬间化为乌有</li>
<li>避免妄自尊大和厌倦无聊的情绪</li>
<li>别因为过度关心细节而忽略了显而易见的东西</li>
<li>千万要排除不需要的信息：“千里之堤，溃于蚁穴”</li>
<li>直面你的大问题，别把它们藏起来</li>
</ul>
</li>
</ul>
<h1 id="怎样变得幸福、富裕，以及其他建议"><a href="#怎样变得幸福、富裕，以及其他建议" class="headerlink" title="怎样变得幸福、富裕，以及其他建议"></a>怎样变得幸福、富裕，以及其他建议</h1><h3 id="如何获得幸福和成功"><a href="#如何获得幸福和成功" class="headerlink" title="如何获得幸福和成功"></a>如何获得幸福和成功</h3><p>生活不仅仅是精明地积累财富，生活和生意上的大多数成功来自你知道应该避免哪些事情：</p>
<ul>
<li>过早死亡、糟糕的婚姻等等。</li>
<li>避免染上艾滋病、在路口和火车抢道以及吸毒。</li>
<li>培养良好的心理习惯。</li>
<li>避免邪恶之人，尤其是那些性感诱人的异性。</li>
<li>如果因为你的特立独行而在周围人中不受欢迎……那你就随他们去吧。</li>
</ul>
<h3 id="满足于你已经拥有的"><a href="#满足于你已经拥有的" class="headerlink" title="满足于你已经拥有的"></a>满足于你已经拥有的</h3><p>总是会有人的财富增长速度比你快。</p>
<h3 id="提防妒忌"><a href="#提防妒忌" class="headerlink" title="提防妒忌"></a>提防妒忌</h3><p>关注别人赚钱（比你）更快的想法是一种致命的罪行。妒忌真的是一种愚蠢的罪行，因为它是仅有的一种你不可能得到任何乐趣的罪行。它只会让你痛苦不堪，不会给你带来任何乐趣。你为什么要妒忌呢？</p>
<h3 id="如何致富"><a href="#如何致富" class="headerlink" title="如何致富"></a>如何致富</h3><p>许多年轻的生意人都问我们这个问题。这是一个聪明的问题：你看见某个有钱的老头，然后问他：“我要怎样才能变得像你一样呢？”<br>每天起床的时候，争取变得比你从前更聪明一点。认真地、出色地完成你的任务。慢慢地，你会有所进步，但这种进步不一定很快。但你这样能够为快速进步打好基础……每天慢慢向前挪一点。到最后——如果你足够长寿的话——大多数人得到了他们应得的东西。</p>
<h3 id="如何找到好配偶"><a href="#如何找到好配偶" class="headerlink" title="如何找到好配偶"></a>如何找到好配偶</h3><p>惟一的最佳方法是你首先必须值得拥有好配偶，因为从定义上来说，好配偶可绝不是傻瓜。</p>
<h3 id="阅读的重要性"><a href="#阅读的重要性" class="headerlink" title="阅读的重要性"></a>阅读的重要性</h3><p>我这辈子遇到的聪明人（来自各行各业的聪明人）没有不每天阅读的，一个都没有。沃伦读书之多，我读书之多，可能会让你感到吃惊。我的孩子们都笑话我。他们觉得我是一本长了两条腿的书。<br>我本人是个传记书迷。我觉得你要是想让人们认识有用的伟大概念，最好是将这些概念和提出它们的伟人的生活和个性联系起来。我想你要是能够和亚当·斯密交朋友，那你的经济学肯定可以学得更好。和“已逝的伟人”交朋友，这听起来很好玩，但如果你确实在生活中与已逝的伟人成为朋友，那么我认为你会过上更好的生活，得到更好的教育。这种方法比简单地给出一些基本概念好得多。</p>
<h3 id="减少物质需求"><a href="#减少物质需求" class="headerlink" title="减少物质需求"></a>减少物质需求</h3><p>大多数人将会发现回报率下降了（由于通货膨胀）。如果你担心通货膨胀，最好的预防手段之一就是在你的生活中别拥有大量愚蠢的需求——你不需要很多物质的商品。</p>
<h3 id="慈善"><a href="#慈善" class="headerlink" title="慈善"></a>慈善</h3><p>（沃伦和我）觉得我们这些非常幸运的人有责任反馈社会。至于是像我这样在活着的时候捐赠大量的钱，还是像沃伦那样，先捐一点，（等去世之后）再捐很多，那是个人喜好的问题。我恐怕不会喜欢人们整天问我要钱。沃伦更无法忍受这种情况。</p>
<h3 id="避免欠债"><a href="#避免欠债" class="headerlink" title="避免欠债"></a>避免欠债</h3><p>你一旦走进负债的怪圈，就很难走出来。千万别欠信用卡的钱。你无法在支付18%的利息的情况下取得进展。</p>
<h3 id="公立学校的衰落"><a href="#公立学校的衰落" class="headerlink" title="公立学校的衰落"></a>公立学校的衰落</h3><p>你完全可以说这（公立学校的衰落）是我们时代的主要灾难之一。我们将地球史上最大的成功之一变成了地球史上最大的灾难之一。</p>
<h3 id="日本的经济衰退"><a href="#日本的经济衰退" class="headerlink" title="日本的经济衰退"></a>日本的经济衰退</h3><p>日本的经济衰退足以令每个人大惊失色，它持续了十年，尽管利率低于1%。政府把所有的货币政策游戏都玩过了，但毫无用处。如果你向哈佛大学的经济学家描绘这种情况，他们会说这是不可能的。然而与此同时，香港却出现了资产泡沫。为什么？因为日本和中国拥有两种非常不同的文化。中国人喜欢赌博。<br>这个经典的例子说明了为什么成功的投资者必须吸取各个学科的知识。想像一下有个经济学家在经济学研讨大会上站起来说出我的解释。那将会是政治不正确！但经济学的工具无法解释现实的情况。</p>
<h1 id="我们成功的关键"><a href="#我们成功的关键" class="headerlink" title="我们成功的关键"></a>我们成功的关键</h1><ol>
<li><p>如果乌龟能够吸取它那些最棒前辈的已经被实践所证明的洞见，有时候它也能跑赢那些追求独创性的兔子或者跑赢宁愿跻身那些忽略前人最优秀的工作的蠢货之列的兔子。乌龟若能找到某些特别有效的方法来应用前人最伟大的工作，或者只要能避免犯下常见的错误，这种情况就会发生。我们赚钱，靠的是记住浅显的，而不是掌握深奥的。我们从来不去试图成为非常聪明的人，而是持续地试图别变成蠢货，久而久之，我们这种人便能获得非常大的优势。</p>
</li>
<li><p>我们并不自称是道德高尚的人，但至少有很多即便合法的事情，也是我们不屑去做的。我们不会去做那些事情。目前美国有种文化认为，所有不会把你送进监狱的事情都是可以做的事情。</p>
</li>
</ol>
<p>我们认为，在你应该做的事情和就算你做了也不会受到法律制裁的事情之间应该有一条巨大的鸿沟。我想你应该远离那条线。我觉得我们不应该由此而得到太多的赞誉。这样做事的原则帮我们赚到更多的钱。我相信就算这种经营方式没有给我们赚这么多钱，我们也不会做坏事。但更多的时候，我们由于做正确的事情而赚到更多的钱。</p>
<p>记住路易斯·文森狄的规则：说真话，你将无须记住你的谎言。就是这么简单的一个概念。</p>
<img  src="../../../../../pics/reading/pca/poor-charlies-almanack.jpeg"   width="100"><span class="image-caption">穷查理宝典-查理·芒格的智慧箴言录</span>
]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>搞定II:提升工作与生活效率的52项原则</title>
    <url>/reading/ready-for-anything/</url>
    <content><![CDATA[<h1 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h1><h1 id="工作流程的5个阶段"><a href="#工作流程的5个阶段" class="headerlink" title="工作流程的5个阶段"></a>工作流程的5个阶段</h1><p>“横向”控制的操作指南——怎样掌握、认识并处理好自己的全部任务</p>
<h3 id="1-收集"><a href="#1-收集" class="headerlink" title="1. 收集"></a>1. 收集</h3><ul>
<li>捕获吸引注意力的一切外部事务（工作篮、电子邮件、笔记本、语音邮件等），并将其从大脑的短期记忆中清空。</li>
<li>根据需要尽量减少收集工具的数量。</li>
<li>通过处理和组织整理（参考下文)）定期清空收集工具。</li>
</ul>
<h3 id="2-处理"><a href="#2-处理" class="headerlink" title="2. 处理"></a>2. 处理</h3><ul>
<li>处理收集到的项目（决定如何处理收集到的材料）。</li>
<li>如果不需要采取行动<br>  -&gt; 抛开;<br>  -&gt; “存入备忘录”留待日后处理，或者将其归档备查。</li>
<li>如果需要采取行动，那就确定随后采取的具体行动<br>  -&gt; 亲自处理（如果两分钟内可以完成）<br>  -&gt; 要么委派他人（并通过“等待”清单跟踪进展情况）<br>  -&gt; 推迟执行（列入行动提示清单或行动文件夹）<br>  -&gt; 如果一次行动无法完成某项工作，那么把这项工作当项目对待，列入项目提示清单。</li>
</ul>
<h3 id="3-组织整理"><a href="#3-组织整理" class="headerlink" title="3. 组织整理"></a>3. 组织整理</h3><ul>
<li>把收集到的输入信息结果分成恰当的可检索、可检查的类别。4种主要的行动类别分别是：<ul>
<li>项目（决定实施的项目）</li>
<li>日程表（具体某一天或某个时刻需要采取的行动）</li>
<li>下一步行动（需要尽早采取的行动）</li>
<li>等待（其他人承担的项目和采取的行动，但你要加以关注）</li>
</ul>
</li>
<li>增加有利于工作的次级类别清单（例如”电话“清单、”杂事“清单、”家“请单、”电脑“清单等)</li>
<li>添加对你有影响的长远目标和价值清单。</li>
<li>添加需要时可能有用的核査清单（工作职责、“引子”清单、组织结构图等）。</li>
<li>针对无须采取行动但需要能检索的信息和材料，建立一般性参考资料归档系统。</li>
<li>针对以后可能采取行动的“引子”，建立一种存储系统（“将来&#x2F;也许”清单、日程表、备忘录）。</li>
<li>必要时,为项目建立辅助信息文件（可以存储在参考系统或待处理领域）。</li>
</ul>
<h3 id="4-回顾"><a href="#4-回顾" class="headerlink" title="4. 回顾"></a>4. 回顾</h3><ul>
<li>每天（或者时间方便可以回顾其中某一项时）回顾日程表和行动清单。</li>
<li>每周进行一次定期回顾，清理、更新、维持和提高你的系统（参考“每周回顾”部分）。</li>
<li>尽量多回顾目标、价值观和愿景方面的长远清单，确保清单完整而且与进展合拍。</li>
</ul>
<h3 id="5-执行"><a href="#5-执行" class="headerlink" title="5. 执行"></a>5. 执行</h3><ul>
<li>根据情境、时间、精力以及事情的重要性作出行动选择。</li>
<li>通过建立随时可供审查的“全生命”行动提示系统保持自身的灵活性，在各种决策过程中相信自己的直觉。</li>
<li>坚持不懈、有规律地关注重要事项，确保作出最优秀的直觉选择。（“做这件事不做那件事对我有什么价值?”）每隔适当的时间，重新审视和调整一下自己在生活和工作各个层面承担的事务：<ul>
<li>跑道——当前行动（每天）</li>
<li>1万英尺——当前项目（每周）</li>
<li>2万英尺——当前职责（每月）</li>
<li>3万英尺——1~2年目标（每季度）</li>
<li>4万英尺——3~5年目标（每年）</li>
<li>5万英尺以上——事业、目标、生活方式（1年以上）</li>
</ul>
</li>
</ul>
<img  src="../../../../../pics/reading/rfa/ready-for-anything-working-process-5-parts.jpg"  ><span class="image-caption">工作流程的5个阶段</span>

<h1 id="自然式计划模式"><a href="#自然式计划模式" class="headerlink" title="自然式计划模式"></a>自然式计划模式</h1><p>“纵向”控制的操作指南——多层面关注、评估单个具体项目或场景</p>
<h3 id="1-目的-指导原则"><a href="#1-目的-指导原则" class="headerlink" title="1. 目的&#x2F;指导原则"></a>1. 目的&#x2F;指导原则</h3><ul>
<li>为什么要做这件事？“有目的”究竟是什么意思？</li>
<li>为项目作出决策、采取行动时，我们应该遵循哪些关键标准？遵守哪些规则？</li>
<li>目的和原则是项目决策的指导性标准。</li>
</ul>
<h3 id="2-使命-愿景-目标-成功的结果"><a href="#2-使命-愿景-目标-成功的结果" class="headerlink" title="2. 使命&#x2F;愿景&#x2F;目标&#x2F;成功的结果"></a>2. 使命&#x2F;愿景&#x2F;目标&#x2F;成功的结果</h3><ul>
<li>如果事情大获成功，将会是什么情况？我怎么知道这种情况？</li>
<li>利益相关方会如何看待和感受那种成功呢？</li>
</ul>
<h3 id="3-头脑风暴"><a href="#3-头脑风暴" class="headerlink" title="3. 头脑风暴"></a>3. 头脑风暴</h3><ul>
<li>关于这件事情，我有哪些想法？现实情况如何？</li>
<li>我知道哪些情况？哪些情况我还不清楚？应该考虑什么？还没考虑什么？等等。</li>
<li>全盘考虑，坦诚相见，不持偏见，拒绝批判性分析。</li>
<li>多角度分析。</li>
</ul>
<h3 id="4-组织整理"><a href="#4-组织整理" class="headerlink" title="4. 组织整理"></a>4. 组织整理</h3><ul>
<li>搞清组成要素（次级项目）、先后顺序，以及&#x2F;或者轻重缓急。</li>
<li>撰写提纲、创建符号列表，或者根据需要创建组织结构图供审査及控制。</li>
</ul>
<h3 id="5-下ー步行动"><a href="#5-下ー步行动" class="headerlink" title="5. 下ー步行动"></a>5. 下ー步行动</h3><ul>
<li>确定对当前的独立组成要素要采取的下一步行动。（随后应该做什么？谁去做？）</li>
<li>如果需要进一步计划，那么就确定具体时间制订进一步的计划。</li>
</ul>
<h3 id="必要的话，把对项目的关注层次作如下调整："><a href="#必要的话，把对项目的关注层次作如下调整：" class="headerlink" title="必要的话，把对项目的关注层次作如下调整："></a>必要的话，把对项目的关注层次作如下调整：</h3><p>如果项目需要进一步加以明确，那么提升关注层面（例如从行动转到计划、从计划转到头脑风暴、从愿景转到目的）。<br>如果项目需要做更多的具体事情，那么降低关注层面（例如从愿景转到头脑风暴、从计划转到行动）。</p>
<h3 id="需要多少规划工作呢？"><a href="#需要多少规划工作呢？" class="headerlink" title="需要多少规划工作呢？"></a>需要多少规划工作呢？</h3><p>如果你已经把项目从头脑中抛开，那说明计划很充分。<br>如果项目还在你头脑中萦绕，那就坚持继续使用这种模式，直到项目变得明朗。</p>
<h1 id="每周回顾指南"><a href="#每周回顾指南" class="headerlink" title="每周回顾指南"></a>每周回顾指南</h1><h3 id="散落的纸片"><a href="#散落的纸片" class="headerlink" title="散落的纸片"></a>散落的纸片</h3><ul>
<li>搜罗各种零碎纸片、名片、收据和各类文件，放进工作篮等候处理。</li>
</ul>
<h3 id="整理笔记"><a href="#整理笔记" class="headerlink" title="整理笔记"></a>整理笔记</h3><ul>
<li>回顾一下日志&#x2F;笔记本上的记录、会议记录和笔记本活页纸上潦草写下的各种笔记，分门别类地记录任务、项目、待处理事项等。</li>
</ul>
<h3 id="清空大脑"><a href="#清空大脑" class="headerlink" title="清空大脑"></a>清空大脑</h3><ul>
<li>（按照合适的类别）写下还没有掌握的所有新项目、任务、待处理事项、将来&#x2F;也许会处理的事项等。</li>
</ul>
<h3 id="回顾“行动”清单"><a href="#回顾“行动”清单" class="headerlink" title="回顾“行动”清单"></a>回顾“行动”清单</h3><ul>
<li>标出完成的行动，查看将要执行的行动的提示信息。</li>
</ul>
<h3 id="回顾“等待”清单"><a href="#回顾“等待”清单" class="headerlink" title="回顾“等待”清单"></a>回顾“等待”清单</h3><ul>
<li>记录为后续措施采取的适当行动，检査标出最近收到的反馈。</li>
</ul>
<h3 id="回顾“项目-及更重大的结果-”清单"><a href="#回顾“项目-及更重大的结果-”清单" class="headerlink" title="回顾“项目(及更重大的结果)”清单"></a>回顾“项目(及更重大的结果)”清单</h3><ul>
<li>依次评估项目、目标和结果的当前情况，确保对每一项都采取了行动。浏览工作进度辅助材料，构想新的行动、要完成的任务和待处理工作等。</li>
</ul>
<h3 id="回顾以往的日程表"><a href="#回顾以往的日程表" class="headerlink" title="回顾以往的日程表"></a>回顾以往的日程表</h3><ul>
<li>仔细查看以往的日程表，搜寻未完成的工作，有用参考数据等，将其纳入当前系统中。</li>
</ul>
<h3 id="回顾将来的日程表"><a href="#回顾将来的日程表" class="headerlink" title="回顾将来的日程表"></a>回顾将来的日程表</h3><ul>
<li>浏览一下将来的日程安排——包括长期和短期安排，记住需要采取的行动。</li>
</ul>
<h3 id="回顾相关的核查清单"><a href="#回顾相关的核查清单" class="headerlink" title="回顾相关的核查清单"></a>回顾相关的核查清单</h3><ul>
<li>以此作为采取新行动的引子。</li>
</ul>
<h3 id="回顾“将来-也许”清单"><a href="#回顾“将来-也许”清单" class="headerlink" title="回顾“将来&#x2F;也许”清单"></a>回顾“将来&#x2F;也许”清单</h3><ul>
<li>查看一下哪些项目现在或许可以开展了，将其转移到项目清单上，清除不再感兴趣的项目。</li>
</ul>
<h3 id="发挥创造力和勇气"><a href="#发挥创造力和勇气" class="headerlink" title="发挥创造力和勇气"></a>发挥创造力和勇气</h3><ul>
<li>你是否有一些新奇、精彩、超越常规、富有创造力、发人深省、大胆冒险的创意可以添加到自己的系统中?</li>
</ul>
<h1 id="重要内容"><a href="#重要内容" class="headerlink" title="重要内容"></a>重要内容</h1><img  src="../../../../../pics/reading/rfa/ready-for-anything-working-content.png"  ><span class="image-caption">搞定II:提升工作与生活效率的52项原则</span>

<img  src="../../../../../pics/reading/rfa/ready-for-anything.png"   width="100"><span class="image-caption">搞定II:提升工作与生活效率的52项原则</span>
]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>断舍离</title>
    <url>/reading/the-life-changing-magic-of-tidying-up/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>每天上下班的时候，在拥挤的地铁里看这本小书，我还挺享受的。大概花了一个礼拜看完，这种书看起来真的蛮轻松的。<br>现在码着字的我，其实距离看完这本书，已经有两个礼拜了。一直说着要写总结的我，终于提笔了。【感人。。。</p>
<p>这本书一直是畅销书，已经出版很多年了。有一次，京东书籍打折，我就随便买了几本书，在看这本书之前，那几本书都没有读，连塑料层都没有拆开。这本书被选中，作为『读书101』的开始，只是因为它很小，很轻，很薄。作者在前言里说，许多人在接受「断舍离」的概念之后，不仅住所发生里变化，在人际关系，生活上也有惊人的变化。当时，我是有轻微地不屑，但是，后面读着读着，就感觉有蛮多共鸣的，好像有一些想法，我在生活中也有发现。现在，读完两个礼拜之后，重新翻看整理，真的觉得有很多感悟和整理的经验，是可以用在各个方面的。比如书里强调的，把心力留给当下的自己，不要留恋或者浪费在不需要、过去或者未来的事物上。我整理出来的内容，我觉得很重要，很值得参考，但是整体篇幅，还是略长。所以，我就<strong>加粗</strong>了一些我认为很实用，非看不可的核心句子，希望能给没有时间的朋友们一点启发。</p>
<p>自我感觉来说，我的房间还算干净，物品也算流动，除了最爱的布朗熊之外，应该也没啥执念。我自省在了解这个概念之前，已经做得不错了，在了解之后，希望可以更好地整理自己。</p>
<p>最后，记住断舍离的目标是让物品都能各得其所，被使用，不浪费。<br>开放借书，与君共勉。</p>
<h1 id="跟着目录看内容"><a href="#跟着目录看内容" class="headerlink" title="跟着目录看内容"></a>跟着目录看内容</h1><p>全书一共五章<br>第一章说明了什么是断舍离，它的机制是啥<br>第二章在讲为什么要断舍离，能给我们带来什么<br>三四章是如何做到断舍离，三是思想指导，而四是行动指南<br>第五章讨论断舍离的意义，以及它的可持续</p>
<h2 id="前言-什么是断舍离"><a href="#前言-什么是断舍离" class="headerlink" title="前言 什么是断舍离"></a>前言 什么是断舍离</h2><p>【现在来看这段，就是非常精简地总结了全书内容】<br>断 &#x3D; 短剧想要进入自己家的不需要的东西。<br>舍 &#x3D; 舍弃家里到处泛滥的破烂儿。<br>离 &#x3D; 脱离对物品的执念，处于游刃有余的自在的空间。<br>断舍离的主角永远是自己（使用者），而不是物品（被使用），时间轴永远是现在，方法是减法而不是加法。<br>行动 &#x3D;&gt; 心灵的变化</p>
<h2 id="第一章-只要了解个中奥妙，就能激发干劲——断舍离的机制"><a href="#第一章-只要了解个中奥妙，就能激发干劲——断舍离的机制" class="headerlink" title="第一章 只要了解个中奥妙，就能激发干劲——断舍离的机制"></a>第一章 只要了解个中奥妙，就能激发干劲——断舍离的机制</h2><p>断舍离是不收拾的收拾法</p>
<ul>
<li>从关系轴和时间轴看物品<br><strong>只有对当下的自己合适且必需，也确实有用的东西，才应该留在你的空间里。</strong><br>-&gt; 时时更新，三思而后行 -&gt; 断 &amp; 舍</li>
<li>为了维持好心情而收拾<br><img  src="/../../../../../pics/reading/tlcmotu/dsl-chapter-1-1.jpg"  ><span class="image-caption">断舍离的机制</span><br>与整理术、收纳术有什么不一样</li>
<li>筛减物品带来的自我察觉<br><strong>你的真实想法，可以通过物品反映出来。</strong><br>你用的东西，映射出你的形象，自我认知。</li>
<li>夺回被占据的空间和能量<br>不适合的东西会占据空间和你的能量，可以说是浪费。<br>从衣柜开始，来一场自我改革吧！</li>
<li>从不穿的衣服着手，去除自己的执念</li>
<li>筛减物品的同时，也改变了人际关系<br>动手实践，意识也能获得转变</li>
<li>和物品成为好朋友<br>家的形象：仓库 -&gt; 住所 -&gt; 自在空间<br><img  src="/../../../../../pics/reading/tlcmotu/dsl-chapter-1-2.jpg"  ><span class="image-caption">断舍离带来的意识、环境、气场变化</span></li>
<li>磨砺内在的感应力</li>
<li>东西要用才有价值<br>要通过有意识的选择让物品自然而然地回归它应该在的地方，回归到需要它的地方。</li>
</ul>
<h2 id="第二章-我们为什么没办法收拾——无法丢弃的理由"><a href="#第二章-我们为什么没办法收拾——无法丢弃的理由" class="headerlink" title="第二章 我们为什么没办法收拾——无法丢弃的理由"></a>第二章 我们为什么没办法收拾——无法丢弃的理由</h2><p>物质过度泛滥的社会</p>
<ul>
<li>捡便宜心理和折扣的陷阱</li>
<li>入口是“断”的闸门，出口是“舍”的闸门<br>来自外部的物质的压力，加上贪便宜和商家的折扣陷阱，入口的闸门常常是打开的，而出口的闸门需要自我有意识的努力。</li>
<li>香鱼变成鲶鱼了吗<br>家就好像一个鱼塘，堆的物品越多，流动性越少，水就会变得浑浊，我们就像鱼儿，因为清水变少，活动的空间就会越来越少。“断”的闸门承受着物质的压力，被迫打开，不断有物品涌入，而“舍”的闸门上布满“扔不掉”的铁锈，物品出不去，无法流动，我们就像被困其中的鲶鱼，喘不过气来。<br>三种“扔不掉东西”的人</li>
<li>“总之我就是不想待在家里！”——逃避现实型</li>
<li>“那些回不去的幸福时光”——执着过去型</li>
<li>“没有了就会很不安”——担忧未来型</li>
<li>对“现在”的界定因人而异<br>找到最适合自己的现在</li>
<li>扔不掉就是不想扔<br>“不需要、不合适、不舒服”的东西，不扔往往是因为执念。其实他们已经成为了垃圾，池塘里的污泥。<br>认清自己与物品之间的关系</li>
<li>没有收拾的屋子就像“便秘”</li>
<li>代表停滞和腐朽运的灰尘与杂物</li>
<li>破烂儿还可以分三类<br>不用的东西：已经被遗忘在一旁的，却还被扔掉的物品<br>还在用的东西：在用，但是不喜欢，随便用着的物品<br>充满回忆的东西<br>当杂物占据了空间</li>
<li>时间轴要锁定在“现在”</li>
<li>不要把重点放在“非日常”上</li>
<li>找回对自己的信任<br><img  src="/../../../../../pics/reading/tlcmotu/dsl-chapter-2-1.jpg"  ><span class="image-caption">现在区·过去与未来区</span></li>
<li>由减分法变成加分法</li>
<li>由忽视和否定而来的能量<br>被忽视、被遗忘，被否定的物品，不仅被浪费，还会散发负面的影响</li>
<li>让房间变乱的心理<br>重新思考住所的意义</li>
<li>断舍离以“住育”为目标</li>
<li>提升对居住环境的意识</li>
<li>让家成为最棒的放松地</li>
</ul>
<h2 id="第三章-先从整理头脑开始——断舍离的思考法则"><a href="#第三章-先从整理头脑开始——断舍离的思考法则" class="headerlink" title="第三章 先从整理头脑开始——断舍离的思考法则"></a>第三章 先从整理头脑开始——断舍离的思考法则</h2><p>以自我为轴心，把时间轴放在“当下”</p>
<ul>
<li>“自我轴心”的窍门——注意提问时的主语<br>物品被我用时，才有价值<br><strong>考虑物品是否应该被留下时，思考的主语是“我”，而不是物品</strong></li>
<li>将物品比作人际关系，了解“当下”的含义<br><strong>和物品做朋友，越用越熟悉，否则就是陌生人包围。</strong><br>选择对当下的我来说最必要的朋友。<br>理清扫除的整体概念<br><img  src="/../../../../../pics/reading/tlcmotu/dsl-chapter-3-1.jpg"  ><span class="image-caption">断舍离中扫除的概念图</span><br>关注不扔东西造成的损失<br>别人的东西都是垃圾吗：先不管别人，高高兴兴地收拾自己的东西<br>将周围人卷入断舍离的漩涡：<br>从信息过多到知行合一</li>
<li>“相”的世界与意识世界</li>
<li>勤做练习，做到知行合一<br>“可惜”的两种含义<br>  “可惜”不是不用扔东西的赦免令，而是对物品的爱惜之情，要让它成为物品循环的原动力。</li>
<li>活着就是不断选择的过程</li>
<li>给还是觉得“扔不掉”、“没法送人”的你<br>物品是一面能映射出真实的自己的镜子，直面物品就是直面真实的自己</li>
</ul>
<h2 id="第四章-身体开始行动——断舍离的实践方法"><a href="#第四章-身体开始行动——断舍离的实践方法" class="headerlink" title="第四章 身体开始行动——断舍离的实践方法"></a>第四章 身体开始行动——断舍离的实践方法</h2><p>提高收拾动机的方法</p>
<ul>
<li>只集中于一点，把它搞完美，以此提高动机<br><strong>从一个小地方开始，比如一个抽屉，打开收拾的突破口</strong></li>
<li>根据目的选择不同的场所<br>一切都从扔东西开始</li>
<li>从“怎么看都是垃圾”的东西开始下手</li>
<li>垃圾分类这道墙</li>
<li>垃圾的三大类：可回收、不可回收、一般垃圾</li>
<li>扔的时候要说“对不起”和“谢谢”<br>对物品保持敬畏之心，做朋友</li>
<li>把东西送给别人时，要说“请收下”<br>循环物品，不浪费<br><strong>将大、中、小“三分法”用到整理收纳上</strong></li>
<li>厨房里的“三分法”：食材、烹调器具和餐具</li>
<li>为什么分成三类刚刚好<br>不要一下子就细致分类，浪费精力，而且没必要，类似“快速排序”<br>不断重复三分法，可以避免整理物品时所造成的混乱<br><strong>利用七、五、一的总量限制原则，打造充裕的空间</strong></li>
<li>从空间里限制物品数量<br>把空间想象成停车场，必须留有余地，车辆才能顺畅出入，物品才会拿取方便<br><strong>看不见的收纳空间：只放七成物品</strong>，例如：衣柜，抽屉<br><strong>看得见的收纳空间：只放五成物品</strong>，例如：开放碗柜、餐具架<br><strong>装饰性的收纳空间：只放一成物品</strong>，例如：墙面</li>
<li><strong>伴随总量限制原则的“替换原则”</strong><br>“新欢”换“旧人”，控制物品的总量，总是留下最好的n件<br>通过限制总量，更加严格地筛选出自己喜欢的物品，自然而然地提升品位。<br>打造物品外观形态的两大原则</li>
<li>只需一个动作原则<br>取放都靠一个动作完成，来减少偷懒的理由</li>
<li>自立、自由、自在法则<br>自立：存放时不会互相依赖，拿取时不影响别的物品 -&gt; 取用方便，省时间<br>自由：同一种物品的不同种类，分类放好，拿取时有选择的自由<br>自在：物品不会散开</li>
<li>“每次主义”就挺好<br>不良品库存 &#x3D; 负债，所以 物品的数量 &#x3D; 每次刚好需要 是最好的状态</li>
</ul>
<h2 id="第五章-前所未有的畅快和解放感——看不见的世界在变化"><a href="#第五章-前所未有的畅快和解放感——看不见的世界在变化" class="headerlink" title="第五章 前所未有的畅快和解放感——看不见的世界在变化"></a>第五章 前所未有的畅快和解放感——看不见的世界在变化</h2><p>自动法则：启动自动整理的机制</p>
<ul>
<li>自动整理的机制</li>
<li>断舍离与自动化<br>训练成为能够依赖的自己，最终彻底脱离“没法收拾的自己”<br>利用物品不断提升自己</li>
<li>存留下的物品是自观的途径</li>
<li>试着使用高于自我形象的物品<br>每天都在用的东西，非常容易作用于潜意识</li>
<li>断舍离并非要提倡清简的生活<br>而是要使用最适合的，最当季的<br>更多“看不见的变化”会发生</li>
<li>从自力到外力的加速变</li>
<li>关于“碍事”这个词</li>
<li>接受来自未知世界的支援<br><img  src="/../../../../../pics/reading/tlcmotu/dsl-chapter-5-1.jpg"  ><span class="image-caption">看得见的世界、看不见的世界、更加看不见的世界</span></li>
<li>从“拥有”这种观念中解放出来</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>物品要用才有价值–断<br>物品在此时、当下，应出现在需要它的地方–舍<br>物品处于恰当的位置，才能展现美感–离</p>
<img  src="../../../../../pics/reading/tlcmotu/dsl.jpg"   width="100"><span class="image-caption">断舍离</span>

<h1 id="See-you-next-book"><a href="#See-you-next-book" class="headerlink" title="See you next book!"></a>See you next book!</h1>]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>学校没教，但一定要懂的金钱观</title>
    <url>/reading/xue-xiao-mei-jiao-dan-yi-ding-yao-dong-de-jin-qian-guan/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>失踪人口终于回归啦！忙完婚礼大事之后，终于又有时间来看书啦。<br>这门书，是在家门口的图书馆借的，是台版的，竖排版+反着翻，读起来稍稍有点不习惯。<br>这门书内容基础，读者定位是高中生。</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><img  src="../../../../../pics/reading/xxmjdydyddjqg/notes.jpg"  ><span class="image-caption">读书笔记</span>

<img  src="../../../../../pics/reading/xxmjdydyddjqg/cover.PNG"   width="100"><span class="image-caption">学校没教，但一定要懂的金钱观</span>]]></content>
      <tags>
        <tag>Reading</tag>
        <tag>Reading101</tag>
      </tags>
  </entry>
  <entry>
    <title>Pitch Building Blocks</title>
    <url>/skills/pitch-building-blocks/</url>
    <content><![CDATA[<h1 id="PITCH"><a href="#PITCH" class="headerlink" title="PITCH"></a>PITCH</h1><p>A pitch typically serves 4 purposes:</p>
<ol>
<li>To grab investors’attention with a “sneak preview” of your company.</li>
<li>To explain to the audience in a clear and simple way what it is that you actually do.</li>
<li>To create the WOW factor! To inspire people to become your supporters.</li>
<li>To help you gain the confidence to talk about your company in front of large scale audiences.</li>
</ol>
<p>Keep in mind that the blocks are not slides.<br>Instead they are identifiable areas that later on can be broken down in<br>various slides according to the script flow you build.</p>
<h1 id="BLOCKS"><a href="#BLOCKS" class="headerlink" title="BLOCKS"></a>BLOCKS</h1><p><strong>Intro</strong> | <strong>Product Demo</strong> | Investment + Milestones<br><strong>Problem</strong> | Market | Competition<br><strong>Why</strong> | Business Model + Rollout Plan | Team + Advisory Board<br><strong>Solution + USP</strong> | Traction + Validation (Partnerships, Customers, etc.) | <strong>Call to Action</strong></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h4 id="Purpose"><a href="#Purpose" class="headerlink" title="Purpose"></a>Purpose</h4><ul>
<li>Set expectation</li>
<li>Strong impression<br>This is where you briefly explain who you are and what you do. Although you may not use all of this information in your pitch, you’ll still need a short description for websites, one-pagers, etc.</li>
</ul>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>Amber Mobility is creating the first feasible alternative to car ownership. Through the combination of our mobile app and our ultra-efficient, modular electric car designed specifically to be shared, Amber provides you with the ulfimate freedom : mobility, guaranteed.</p>
<h4 id="Ways"><a href="#Ways" class="headerlink" title="Ways"></a>Ways</h4><ul>
<li>Direct introduction + A nice product picture</li>
<li>One sentence</li>
<li>A story</li>
</ul>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h4 id="Purpose-1"><a href="#Purpose-1" class="headerlink" title="Purpose"></a>Purpose</h4><p>This is where you can make the strongest argument for the existence of your product. Investors want to see that you are addressing a real and current need in the market.<br>Don’t talk about broad industry problems here. Think about the pain points of the individuals in your target market.<br>How big is your problem, quantified in money and time?</p>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>Currently, 60% of 3D printers go unused. That’s 150,000 printers, resulting in about 2,000 tons of waste per year.</p>
<h4 id="Ways-1"><a href="#Ways-1" class="headerlink" title="Ways"></a>Ways</h4><ul>
<li>Give a shocking numbers</li>
<li>Invlove audience in your story, put them into shoes</li>
</ul>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><h4 id="Purpose-2"><a href="#Purpose-2" class="headerlink" title="Purpose"></a>Purpose</h4><p>This is where you can explain your authentic connection to the problem, connecting to your audience based on values and emotions. This is what makes your story a story! WHY can be a hook &amp; bait.<br>Why you? Why now? Why this?<br>为什么你要去解决？你对这个问题有什么特殊的背景故事, 或者是关联吗？使命感从哪里来?<br>But be BRIEF.</p>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h4><p>A few years ago, I lost my sister to [terrible disease]. Ever since then, I’ve been working tirelessly to find a cure for this disease…</p>
<h4 id="Ways-2"><a href="#Ways-2" class="headerlink" title="Ways"></a>Ways</h4><ul>
<li>Provide a vision</li>
<li>What if …?</li>
</ul>
<h2 id="Solution-USP"><a href="#Solution-USP" class="headerlink" title="Solution + USP"></a>Solution + USP</h2><h4 id="Purpose-3"><a href="#Purpose-3" class="headerlink" title="Purpose"></a>Purpose</h4><p>This is where you <strong>simply and concisely</strong> explain what your solution is to the problem you’ve described and why it’s great.<br>Some questions you can answer:</p>
<ul>
<li>What is it?</li>
<li>What does it do?</li>
<li>How does my solution solve my early adopter target market’s problem?</li>
<li>What’s our USP (unique selling proposition)?</li>
</ul>
<h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h4><p>Amber Mobility combines Guaranteed Mobility with the Amber One. Guaranteed Mobility is a unique app-based service that guarantees the availability of a car at all times and within walking distance. The Amber One is our efficient, modular, and customizable electric car designed specifically for car sharing.<br>USPs<br>More convenient, affordable, and environmentally friendly than any other mobility service currently available.</p>
<h2 id="Product-Demo"><a href="#Product-Demo" class="headerlink" title="Product Demo"></a>Product Demo</h2><h4 id="Purpose-4"><a href="#Purpose-4" class="headerlink" title="Purpose"></a>Purpose</h4><p>This story block is especially relevant for hardware startups, but it can also be useful for web- and app-based startups.<br>In this section, you would show your product (either on a slide, in real-life, or both) and describe some of its most relevant features.</p>
<h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h4><p>You can check out Usono’s Co-founder and COO Victor Donker present his product on stage at XL Day in September, 2016 via this youtube link: …</p>
<h2 id="Call-to-Action"><a href="#Call-to-Action" class="headerlink" title="Call to Action"></a>Call to Action</h2><h4 id="Purpose-5"><a href="#Purpose-5" class="headerlink" title="Purpose"></a>Purpose</h4><p>What do you want the audience to remember or do? This can be a more direct call to action or something more subtle.</p>
<h4 id="Example-5"><a href="#Example-5" class="headerlink" title="Example"></a>Example</h4><p>You can see the Co-founder of the Finance Navigator WoutBobbink’s inspiring call to action at the end of his presentation at XL Day, September 2016 via this link<br><a href="https://www.youtube.com/watch?v=tJoMbdNxCbA">https://www.youtube.com/watch?v=tJoMbdNxCbA</a></p>
<h4 id="Ways-3"><a href="#Ways-3" class="headerlink" title="Ways"></a>Ways</h4><ul>
<li>Sign up to succeed</li>
</ul>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="Check-Stage"><a href="#Check-Stage" class="headerlink" title="Check Stage"></a>Check Stage</h2><h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><ol>
<li>Know your audience</li>
<li>What’s in it for me? What’s in it for the audience?</li>
<li>Create emotional connection with the audience: unlerability, storytelling</li>
<li>Beginning &amp; ending of your presentation: What is the most impact? How do they connect?</li>
</ol>
<h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h3><p>4 key elements in your pitch:</p>
<ol>
<li>Hooking intro</li>
<li>Clear problem (numbers, shocking effect)</li>
<li>Concise solution</li>
<li>WOW! call to action<br>Plus, how will you delivery them<br>Identify and write down how you will build para-verbal and non-verbal focus during these points. When you drop your solution, will you slow down for dramatic effect? For your CTA, will you step towards the crowd to engage them?</li>
</ol>
<h3 id="Delivery"><a href="#Delivery" class="headerlink" title="Delivery"></a>Delivery</h3><ul>
<li>Pauses</li>
<li>Eye contact</li>
<li>Smiling</li>
<li>Speak loud</li>
<li>Speak slow and steady</li>
</ul>
<h3 id="Form-Body-Language"><a href="#Form-Body-Language" class="headerlink" title="Form &amp; Body Language"></a>Form &amp; Body Language</h3><p>Be self-aware and focus on giving each other advice on the following points:</p>
<ul>
<li>Straight back</li>
<li>Owning the territory</li>
<li>Head up</li>
<li>Face the crowd</li>
</ul>
<h2 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h2><h3 id="Do’s"><a href="#Do’s" class="headerlink" title="Do’s"></a>Do’s</h3><ul>
<li>Simplify! Cut it down to the most essential details that will enhance your story.</li>
<li>Create a basic outline of your story and pitch it to a few people to get initial comments and feedback before you dive into the actual design (does it make sense to them?)</li>
<li>Enhance the emotional aspect of the presentation by using a personal story (create an emotional connection)</li>
<li>Use quantifiable data (example: we are 30% faster; we are 80% more energy efficient).</li>
<li>Be aware of the intent-impact gap (we judge ourselves and the messagewe produce based on our intent, but our audience judges us based on what they experience).</li>
<li>Empower the presentation with quotes from international acclaimed organizations &#x2F; institutions &#x2F; academics etc,</li>
<li>When the presentation is almost ready, write down your script in the comments section of every slide. When you do that you will realize the actual gaps and contradictions, if any on your story line</li>
</ul>
<h3 id="Don’ts"><a href="#Don’ts" class="headerlink" title="Don’ts"></a>Don’ts</h3><ul>
<li>Don’t talk about things that are not on your slides. The audience needs to see and hear the same message in consistency.</li>
<li>Don’t make vague statements. Support with facts!</li>
<li>Don’t forget to connect all the story blocks together in a logical flow.</li>
<li>Don’t underestimate the size of the intent-impact gap, and don’t blame your audience for the impact they experience.</li>
</ul>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="Do’s-1"><a href="#Do’s-1" class="headerlink" title="Do’s"></a>Do’s</h3><ul>
<li>Know your brand assets and how to use them.</li>
<li>Decide on the general aesthetic of your presentation (colors &#x2F; fonts &#x2F; sizes &#x2F; image or graphic oriented)</li>
<li>Always keep a duplicated copy of the presentation on the drive or an external hard disk just in case</li>
<li>Use the minimum amount of text on the slides (it’s a pitch - NOT a presentation).</li>
<li>Maximize visual contrast on your slides (usually projectors fade colors)</li>
<li>Have a fun slide (a good joke always connects you and engages the audience more)</li>
<li>Bigger is almost always better :)</li>
<li>Aim in consistency.</li>
<li>A carefully selected image can substitute a lot of text.</li>
<li>When you use unsafe or custom fonts be sure that they are installed on the source you are presenting from.</li>
</ul>
<h3 id="Don’ts-1"><a href="#Don’ts-1" class="headerlink" title="Don’ts"></a>Don’ts</h3><ul>
<li>Don’t use your logo and page numbering on all the slides</li>
<li>Don’t use small or handwritten fonts &#x2F; asterisks with small text explanations (except if needed for specific purposes)</li>
<li>Don’t place readable light colored text on dark background (always dothe opposite)</li>
<li>Don’t use too much text &#x2F; too many different elements &#x2F; too many numbers (keep it clean, lean and consistent throughout)</li>
<li>Don’t use detailed graphs (find a different, cleaner way to show this information)</li>
<li>Don’t create templates with master slides (many software and hardware conflict and might mess-up your slides)</li>
<li>Avoid using too obvious, generic images (shutterstock). Be creative</li>
<li>Avoid using too many animations and clicks on your slides. (something might go wrong on the event or you can get “clicker happy” and mess up your presentation) use only if there’s added value for the slide or storyline</li>
<li>Don’t shadow black or dark colored fonts (makes the text fuzzy)</li>
<li>Don’t overbrand everything. It’s the era of de-branding.</li>
</ul>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>Skills</tag>
      </tags>
  </entry>
  <entry>
    <title>SAP01</title>
    <url>/skills/sap01/</url>
    <content><![CDATA[<p>迭代：<br>卖萌的弱智版本 到 怪兽哥斯拉<br>公司: 三大报表（资产覆盖表、损溢表、现金流量表）的最小单位<br>四大版：<br>SAP Business Suite + SAP ERP（面向500强）<br>SAP Business All-in-One（最受欢迎，预先配置）<br>SAP Business ByDesign（失败产品）<br>SAP Business One（专业面向中小客户）<br>菜单：<br><img  src="/../../../../../pics/skills/s/menu.png"  ><span class="image-caption">menu</span></p>
<p>Mm01 Create Material 创建物料<br>Co01 Create Production Order 创建产品订单<br>Me21n Create Purchase Order 创建采购订单<br>Spro SAP后台配置</p>
<p>F1 帮助</p>
<p>Client：<br>DEV-&gt;100<br>QAD-&gt;300, 500, 600 独立数据，可以有多个，测试用<br>PRD-&gt;800 正式系统，只能有一个</p>
<p>Client<br>Controlling Area<br>Company Code<br>1线：<br>Plant MRP节点<br>Storage Location 库存地点，逻辑上共同存放东西的地点，每一个物理地点可以对应多个库存点</p>
<p>2线：<br>Sales Organization：负责不同产品的销售<br>Distribution Channel：分销渠道<br>Division：产品组&#x2F;部门 具体产品分类</p>
<p>HR线：<br>Organization Unit<br>Career Path</p>
<p>采购：</p>
<ol>
<li>demand determination</li>
<li>Source determination</li>
<li>Supplier selection</li>
<li>Purchase order processing(从采购申请[me51n&#x2F;自动生成]中转换过来)</li>
<li>Order monitoring</li>
<li>Goods receipt</li>
<li>Invoice verification</li>
<li>Payment processing</li>
</ol>
<p>有借必有贷，借贷必相等<br>左资产，右负债（所有者权益）<br>购买：借：库存，贷：GR&#x2F;IR<br>收货：借（Debit）：GR（货物清单）&#x2F;IR，贷（Credit）：应付账款<br>实际付款 借：应付账款，贷：现金</p>
<p>SRM 采购系统和供应商集合</p>
<p>移动平均法<br>移动加权平均法<br>一阶指数平滑法<br>二阶指数平滑法<br>最小二乘法<br>趋势模型<br>趋势季节模型</p>
<p>MRP|<br>Planned Order | PR<br>Capacity Levelity<br>PU<br>Production Order</p>
<p>|           MRP          |<br>|—|—|<br>|   Planned Order   | PR |<br>| Capacity Levelity | PU |<br>| Production Order  |    |</p>
<h1 id="Production-Manufacturing1-Production-planning2-Order-creation3-Order-release4-Order-printing5-Material-staging6-Order-execution7-Confirmations-报工，实际成本8-Goods-receiptBill-of-Material-是PP阶段的关键-Routing-供应路线，成本所在"><a href="#Production-Manufacturing1-Production-planning2-Order-creation3-Order-release4-Order-printing5-Material-staging6-Order-execution7-Confirmations-报工，实际成本8-Goods-receiptBill-of-Material-是PP阶段的关键-Routing-供应路线，成本所在" class="headerlink" title="Production - Manufacturing1. Production planning2. Order creation3. Order release4. Order printing5. Material staging6. Order execution7. Confirmations 报工，实际成本8. Goods receiptBill of Material 是PP阶段的关键+Routing 供应路线，成本所在"></a>Production - Manufacturing<br>1. Production planning<br>2. Order creation<br>3. Order release<br>4. Order printing<br>5. Material staging<br>6. Order execution<br>7. Confirmations 报工，实际成本<br>8. Goods receipt<br><br>Bill of Material 是PP阶段的关键<br>+<br>Routing 供应路线，成本所在</h1><p>计划成本</p>
<p>收货的时候，借：库存，贷：订单（收货的时候，订单尚未结算，成本未知）</p>
<p>SCM最最最难！！！<br>Supply Chain Management<br>最优化资源</p>
<p>销售：<br>三部：销售订单-&gt; 交货 -&gt; 开票</p>
<ol>
<li>Sales order</li>
<li>Availiability check</li>
<li>Outbound belivery 捡货出库</li>
<li>Transportation</li>
<li>Picking</li>
<li>Goods issue</li>
<li>Billing 开票收钱</li>
<li>Payment process</li>
</ol>
<p>出库：借：销售成本；贷：库存<br>开票：借：应收账款（SAP系统中-客户）；贷：主营业务收入<br>收钱：借：现金；贷：应收账款（SAP系统中-客户）</p>
<p>五大核心模块<br>FI CO SD PP MM<br>衍生模块<br>HR CS PM PS VMS DBM WM</p>
<p>PLM &#x3D; ECM(工程管理) + PM(设备管理，企业内部资产) + QM(质量管理) + PS(项目管理，各阶段预算成本资源) + EHS(环境健康安全)</p>
<p>财务</p>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>Skills</tag>
      </tags>
  </entry>
  <entry>
    <title>Texas Hold’em</title>
    <url>/skills/texas-hold%E2%80%99em/</url>
    <content><![CDATA[<h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><p>德州扑克采用52张扑克牌（除去两张王牌）,游戏玩家人数限制在2~9人。在牌局开始时,荷官会给每个玩家发2张“底牌”（只有个人看到）,桌面上会分三次陆续发出3张、1张、1张（共5张）的公共牌,在经过四轮的“加注”、“跟注”和“弃牌”等押注圈操作后,若牌局存在至少两名玩家仍然没有弃牌的情况下,进入“摊牌”阶段,把自己的2张底牌和5张公共牌力挑选出最大的5张组合,按照牌型大小规则分出胜负,赢家拿下“底池”全部筹码。<br>德州扑克是指无限注德州扑克(NLHM, No Limit Texas Hold’em)；玩法上又分为常规桌(Cash, 现金局)，单桌赛(SNG)和多桌锦标赛(MTT)。一般采用的是无限下注（No-Limit），指每轮下注过程中，下注额将没有任何限制，但最低限度要等于该押注圈的注限，而且你如果要加注，<strong>加注额至少要是你前面玩家下注额的两倍</strong>。</p>
<h1 id="牌型-（从大到小）"><a href="#牌型-（从大到小）" class="headerlink" title="牌型 （从大到小）"></a>牌型 （从大到小）</h1><p>皇家同花顺 Royal Flush<br>同花顺 Straight Flush<br>四条 Four of a Kind<br>葫芦 Full House<br>同花 Flush<br>顺子 Straight<br>三条 Three of a Kind<br>两队 Two Pairs<br>一队 One Pair<br>高牌 High Card</p>
<h1 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h1><p><strong>庄家 Button&#x2F;Btn</strong>：按钮位，全场最有利的位置，它决定了牌圈行动顺序<br><strong>小盲注 Small Blind&#x2F;SB</strong>：庄家位置左手边第一个位置，强制下注，下注额为大盲注的一半<br><strong>大盲注 Big Blind&#x2F;BB</strong>：庄家位置左手边第二个位置，强制下注，下注额为当前牌圈的底注<br><strong>枪口位 Under The Gun&#x2F;UTG</strong>：大盲注左手边第一个位置，翻牌前最先行动，是最被动的玩家，起手牌的要求比其他位置要高，往往会弃牌<br><strong>中间位 Middle Position&#x2F;MP</strong>：枪口位之后，行动灵活收放自如，进可加注、咋唬，退可跟注、弃牌。<br><strong>关煞位 Cut Off&#x2F;CO</strong>：庄家右手，行动灵活收放自如，进可加注、咋唬，退可跟注、弃牌。<br><strong>行动顺序</strong>：</p>
<ul>
<li>（翻牌前）按顺时针排列为枪口位，中间位，关煞位，庄位，小盲注，大盲注</li>
<li>（翻牌后）小盲注，大盲注，枪口位，中间位，关煞位，庄位<br>九人桌相比于六人桌，区别在于枪口位和庄位之间加入UTG+1，MP+1，MP+2三个位置。如下图所示,</li>
</ul>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="玩家"><a href="#玩家" class="headerlink" title="玩家"></a>玩家</h2><p><strong>下注 Bet</strong>：用筹码下注，作为注额<br><strong>跟注 Call</strong>：与前一位押下相同注额<br><strong>弃牌 Fold</strong>：放弃继续游戏的机会<br><strong>过牌 Check</strong>：不需要跟注的情况下，把下注机会留给下一位<br><strong>加注 Raise</strong>：提高现有的注额<br><strong>再加注 Re-Raise</strong>：在其他人加注后，再进行加注<br><strong>全下 All in</strong>：将所有筹码作为注额<br><strong>3 Bet</strong>：翻牌前面对对手的加注后进行再次加注，对3 Bet再加注就是4 Bet，以此类推<br><strong>c Bet</strong>： 翻牌后，翻牌前做raise的人持续加注</p>
<h2 id="公共牌"><a href="#公共牌" class="headerlink" title="公共牌"></a>公共牌</h2><p><strong>翻牌前 Pre-flop</strong>：发出底牌后,公共牌出现以前的第一轮叫注阶段<br><strong>翻牌 Flop</strong>：前三张公共牌<br><strong>翻牌圈 Flop-round</strong>：前三张公共牌出现以后的押注圈<br><strong>转牌 Turn</strong>：第四牌公共牌<br><strong>转牌圈 Turn-round</strong>：第四张出现以后的押注圈<br><strong>河牌 River</strong>：第五张公共牌<br><strong>河牌圈 River-round</strong>：第五张出现以后的押注圈</p>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p><strong>咋唬 Bluff</strong>：在低胜率或者零胜率的情况下，通过加大筹码来虚张声势达到吓跑对手的目的<br><strong>鱼 Fish</strong>：指较好的玩家对牌品差的玩家的贬义称呼<br><strong>T</strong>：ten的简写，代表扑克牌中的10<br><strong>坚果 Nuts</strong>：能和公共牌组合成最大的成牌的最强底牌。如K-K-T-5-2公共牌，能和其组成最强成牌四条K的KK就是坚果<br><strong>出路 Outs</strong>：也叫补牌，能够使玩家在某个阶段所有可能获胜的公共牌。如口袋对8的玩家需要再获得一张8来获得，那么他就有两个“出路”（两张不同花色的8）<br><strong>底池 Pot</strong>：当前牌局的筹码总注额<br><strong>彩虹面 Rainbow</strong>：三张翻牌不同花色的情况<br><strong>暗三条 Set</strong>：与公共牌能够组成三条的“口袋对”底牌，如底牌是J-J口袋对，翻牌J-8-2的情况<br><strong>鲨鱼 Shark</strong>：能够稳定赢钱的实力玩家<br><strong>摊牌 Showdown</strong>：最后一圈押注后，仍存在至少两名玩家没有放弃，就把底牌亮出比高低。国际上通用的规则是：“在游戏结束前最后一个下注轮里（可能不是河牌圈），最后一个激进行为的发起者，应该先亮牌。”如果在河牌圈，所有人祥和地过牌，没有激进行为，从小盲注玩家开始，依次亮底牌。后面的玩家如果看到前面亮出的牌大过自己，知道自己牌力不如人，可以选择不亮出自己底牌给大家看<br><strong>上头 Tilt</strong>：一般指情绪不稳定状态，没经过思考、胡乱地玩</p>
<h2 id="其他术语"><a href="#其他术语" class="headerlink" title="其他术语"></a>其他术语</h2><p><strong>♠ 黑桃S spade</strong>：权力<br><strong>♥ 红桃H heart</strong>：爱情<br><strong>♣ 梅花C club</strong>： 幸运<br><strong>◆ 方块D diamond</strong>：财富<br><strong>相同花色 Suited</strong>：如AQs代表AQ两张牌相同花色,包括四种组合<br><strong>不同花色 Off Suit</strong>：如AQo代表AQ两张牌不相同花色,包括十二种组合<br><strong>慢打 Slow Play</strong><br><strong>破绽&#x2F;马脚 Tells</strong>:马脚通常是指玩家下意识露出的习惯性动作，从一定层面上暴露出了他的手牌信息和心理活动<br><strong>爆冷 Bad Beat</strong></p>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><ol>
<li>四二法则<br>先想好自己想要的牌的张数，然后，还有两轮机会就乘4，还有一轮机会就乘2，得到的就是你想要的牌接下来会出现的概率。</li>
<li>比平时更具侵略性<br>当你有一副不错的起手牌，所以要确保在这手牌中，将持有较弱牌的玩家打走，或者迫使他们付出更高代价来留在游戏中。最糟糕的情况莫过于，KK在翻牌前过牌，结果却被持有手牌84的玩家，奇迹般地抽中顺子而击败。应该让弱牌玩家看牌前付出一定的代价，尽早将大多数玩家推挤出底池。 你要知道当底池中有六个玩家时，你获胜的基础几率仅为17％，即使你的手牌是AA，六人底池中你的胜率也不会太高。 而在底池中只有两个的情况下，你的基础胜率上升至50％，若这时你持有AA，你的胜率将上升至76%以上。<br>谨慎打法更糟糕之处在于，它会让你在牌桌上其他玩家心中打上“弱势玩家”的标记。如果你很少下注或加注，你很快便会发现，那些知道你在压力下会弃牌的强势玩家将时刻压榨你。当你大额下注时，其他玩家将立刻知道你手握强牌，所有人都会迅速弃牌，最大限度降低你可赢得的金额。</li>
<li>必须有耐心<br>弃牌次数远多于入池玩牌次数。耐心等待赔率对你有利的情况，然后用你的攻击性去造大底池，最终赢得胜利。</li>
<li>注意观察对手<br>Play the player, not your cards.</li>
<li>考虑“长期”<br>必要时加强攻击性、耐心地谨慎地玩牌、像对待心爱的电影一样研究对手和牌局。这将让你的玩法保持在控制范围内，抵制“上头”的冲动，不要试图用愚蠢的下注拼运气来弥补损失。为每一阶段和长期都设定一笔资金，并坚持下去。</li>
<li>学习知识，提升技术</li>
<li>起手牌概率<br><img  src="/../../../../../pics/skills/th/%E8%B5%B7%E6%89%8B%E7%89%8C.jpeg"  ><span class="image-caption">起手牌</span></li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.moshike.com/a/1011.html">德扑_德州扑克—-学习德扑技巧和德扑策略之家</a></li>
<li><a href="https://pokerclub.co/tips/">德扑基地</a></li>
</ul>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>Skills</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Search 二分查找法</title>
    <url>/tech/binary-search/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>纠结症患者的福音，也算是分治策略的一种吧，逐渐把大问题化小，小问题化无。<br>最早接触二分查找法，是小时候的一道数学题。问有n个球，其中有一个球是残次品，质量略小于其他的球，你有一个天平，没有砝码和刻度，请问，你怎样可以最快找出这个残次球。<br>二分法的思想很简单，但是有很多细节需要考虑。常常同一道题，用二分法的思想，可以写出不同的解法，而且殊途同归，都可以解决问题。一开始我也常常很苦恼，直到真正找到其中的奥秘，有一种拨云见日的感觉。现在遇到二分题，我也不敢说一定能百分百秒杀，至少经过练习，心理上会自信很多。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>二分查找的基本思想是将n个顺序元素分成大致相等的两部分，将查找目标值与分隔中间值进行比较，选择中间值的两边，进行比较，直到范围缩小为1。时间复杂度为O(lgN)，空间复杂度为O(1)。</p>
<h2 id="自用模版"><a href="#自用模版" class="headerlink" title="自用模版"></a>自用模版</h2><p>我在前沿里说了，二分的模版有很多，这里是我最顺手，最常用的模版，它找的是第一个大于等于k的数在数组中的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> k)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = a.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (a[mid] &lt; k) &#123;<br>      l = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      r = mid;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ol>
<li>选择左右指针<br>我习惯用l和r，也有人用l(low)和h(high)来代表左右指针。<br>左指针一般都是0起步，没什么异议，但是对于右指针，我们有的时候会选择为<strong>数组的长度n</strong>，而不是最后一个元素的index。<br>这个选择，取决于答案的范围。例如，最大可能答案是n，那么我们的右指针应当从<strong>数组的长度n</strong>开始。</li>
<li>中间元素index mid的计算<br>一般来说计算方式有如下两种：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// when odd, return the only mid</span><br><span class="hljs-comment">// when even, return the lower mid</span><br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lo + ((hi - lo)/<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// when odd, return the only mid</span><br><span class="hljs-comment">// when even, return the upper mid</span><br><span class="hljs-type">int</span> <span class="hljs-variable">mid2</span> <span class="hljs-operator">=</span> lo + ((hi - lo + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>
如果区间范围内的元素总数为奇数，那么两种方式计算出的mid和mid2都为中间元素，所以并没有区别。<br>但是，如果区间范围内的元素总数为偶数，那么在选取中间元素时，我们就会有较小元素mid，和较大元素mid2，两种选择方式了。<br>此外，为了防止溢出，我们一般不会直接把左右元素相加除以2，而是写成 l+差 这样形式的。</li>
<li>左右指针的移动 &#x3D; if条件<br>写我们100%确定的条件<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-number">100</span>% sure logic) &#123;<br>  left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 100% sure target is to the right of mid</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  right = mid; <br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-number">100</span>% sure logic) &#123;<br>  right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 100% sure target is to the left of mid</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  left = mid;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>循环的出口 &#x3D; while条件<br>有的人会使用<code>l &lt;= r</code>，来作为while的条件。但是，在我的模版中，我们始终使用<code>l &lt; r</code>来作为循环的出口，因为这样我们可以保证，当循环结束时，l和r一定相等。如果需要判断target不存在情况，那么我们可以在循环外判断。</li>
<li>防止无限循环<br>这是一个新手经常会遇到的问题。为啥我的二分法没法结束呢？这时候，你需要检查一下，你的mid值取的是上边界，还是下边界，如果像下面的代码，你的mid值是上边界，而移动左右指针时，又是保持左边界l不变，移动右边界r，那么你可能就会进入无限循环了。<br>解决的诀窍是，考虑当左右边界之间，只有2个元素时的情况下，如何退出循环。<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ❌ The following code results in inifite loop</span><br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> lo + ((hi - lo)/<span class="hljs-number">2</span>); <span class="hljs-comment">// aka the lower mid</span><br><span class="hljs-comment">// We should use:</span><br><span class="hljs-comment">// int mid = lo + ((hi - lo + 1)/2) // aka the upper mid</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-number">100</span>% sure logic) &#123;<br>	right = mid - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>	left = mid <span class="hljs-comment">// &lt;-- note here</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="API-大法"><a href="#API-大法" class="headerlink" title="API 大法"></a>API 大法</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the sort(int[], int, int) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.</span><br><span class="hljs-comment">Params:</span><br><span class="hljs-comment">a – the array to be searched</span><br><span class="hljs-comment">fromIndex – the index of the first element (inclusive) to be searched</span><br><span class="hljs-comment">toIndex – the index of the last element (exclusive) to be searched</span><br><span class="hljs-comment">key – the value to be searched for</span><br><span class="hljs-comment">Returns:</span><br><span class="hljs-comment">index of the search key, if it is contained in the array within the specified range; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or toIndex if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</span><br><span class="hljs-comment">Throws:</span><br><span class="hljs-comment">IllegalArgumentException – if fromIndex &gt; toIndex</span><br><span class="hljs-comment">ArrayIndexOutOfBoundsException – if fromIndex &lt; 0 or toIndex &gt; a.length</span><br><span class="hljs-comment">Since:</span><br><span class="hljs-comment">1.6</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-meta">@Optional</span> <span class="hljs-type">int</span> fromIndex, <span class="hljs-meta">@Optional</span> <span class="hljs-type">int</span> toIndex, <span class="hljs-meta">@Optional</span> <span class="hljs-type">int</span> key)</span> &#123;<br>    rangeCheck(a.length, fromIndex, toIndex);<br>    <span class="hljs-keyword">return</span> binarySearch0(a, fromIndex, toIndex, key);<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><h2 id="精选练习"><a href="#精选练习" class="headerlink" title="精选练习"></a>精选练习</h2><ul>
<li><a href="https://leetcode.com/problems/binary-search/">704.Binary Search</a> 首选练习，不能更直接了</li>
<li><a href="https://leetcode.com/problems/fixed-point/">1064.Fixed Point</a></li>
<li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34.Find First and Last Position of Element in Sorted Array</a></li>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33.Search in Rotated Sorted Array</a></li>
<li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34.Find First and Last Position of Element in Sorted Array</a></li>
</ul>
<h2 id="更多基础练习"><a href="#更多基础练习" class="headerlink" title="更多基础练习"></a>更多基础练习</h2><ul>
<li><a href="https://leetcode.com/problems/search-insert-position/">35.Search Insert Position</a> 注意左右指针的初始选择</li>
<li><a href="https://leetcode.com/problems/sqrtx/">69.Sqrt(x)</a> 注意溢出，if条件的选择</li>
<li><a href="https://leetcode.com/problems/valid-perfect-square/">367.Valid Perfect Square</a> 和上一题很像</li>
<li><a href="https://leetcode.com/problems/first-bad-version/">278.First Bad Version</a> </li>
<li><a href="https://leetcode.com/problems/guess-number-higher-or-lower/">374.Guess Number Higher or Lower</a></li>
<li><a href="https://leetcode.com/problems/binary-search/">704.Binary Search</a> 首选练习，不能更直接了</li>
<li><a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/">852.Peak Index in a Mountain Array</a> 不错的一题，建议练习</li>
<li><a href="https://leetcode.com/problems/fixed-point/">1064.Fixed Point</a> 不错的一题，建议练习</li>
<li><a href="https://leetcode.com/problems/two-sum-less-than-k/">1099.Two Sum Less Than K</a> 小变体</li>
<li><a href="https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/">1150.Check If a Number Is Majority Element in a Sorted Array</a> 小变体</li>
<li><a href="https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/">1337.The K Weakest Rows in a Matrix</a> 坑特别多，值得练习</li>
<li><a href="https://leetcode.com/problems/check-if-n-and-its-double-exist/">1346.Check If N and Its Double Exist</a> 二分法的典型应用，注意负数</li>
<li><a href="https://leetcode.com/problems/search-a-2d-matrix/">74.Search a 2D Matrix</a></li>
<li><a href="https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/">1351.Count Negative Numbers in a Sorted Matrix</a></li>
<li><a href="https://leetcode.com/problems/find-the-distance-value-between-two-arrays/">1385.Find the Distance Value Between Two Arrays</a></li>
<li><a href="https://leetcode.com/problems/kth-missing-positive-number/">1539.Kth Missing Positive Number</a></li>
<li><a href="https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/">1608. Special Array With X Elements Greater Than or Equal X</a></li>
<li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153.Find Minimum in Rotated Sorted Array</a></li>
<li><a href="https://leetcode.com/problems/find-peak-element/">162.Find Peak Element</a></li>
<li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">167.Two Sum II - Input Array Is Sorted</a> 双指针 + 二分查找，如果你已经想到双指针了，那想想是不是可以结合二分查找缩小指针范围呢？</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://leetcode.com/problems/search-insert-position/discuss/423166/Binary-Search-101">Binary Search 101</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Bloomberg 高频面试题</title>
    <url>/tech/bloomberg-coding-questions/</url>
    <content><![CDATA[<h1 id="Top-Questions-in-6-months-in-2022-Aug"><a href="#Top-Questions-in-6-months-in-2022-Aug" class="headerlink" title="Top Questions in 6 months in 2022 Aug"></a>Top Questions in 6 months in 2022 Aug</h1><ul>
<li><a href="https://leetcode.com/problems/design-underground-system">1396.Design Underground System</a></li>
<li><a href="https://leetcode.com/problems/design-an-ordered-stream">1656.Design an Ordered Stream</a> &#x2F;&#x2F; todo</li>
<li><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">380.Insert Delete GetRandom O(1)</a></li>
<li><a href="https://leetcode.com/problems/decode-string">394.Decode String</a></li>
<li><a href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list">430.Flatten a Multilevel Doubly Linked List</a></li>
<li><a href="https://leetcode.com/problems/invalid-transactions">1169.Invalid Transactions</a></li>
<li><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii">1209.Remove All Adjacent Duplicates in String II</a></li>
<li><a href="https://leetcode.com/problems/two-city-scheduling">1029.Two City Scheduling</a></li>
<li><a href="https://leetcode.com/problems/design-a-leaderboard">1244.Design A Leaderboard</a></li>
<li><a href="https://leetcode.com/problems/number-of-ships-in-a-rectangle">1274.Number of Ships in a Rectangle</a></li>
<li><a href="https://leetcode.com/problems/candy-crush">723.Candy Crush</a></li>
<li><a href="https://leetcode.com/problems/design-browser-history">1472.Design Browser History</a></li>
<li><a href="https://leetcode.com/problems/meeting-rooms-ii">253.Meeting Rooms II</a></li>
<li><a href="https://leetcode.com/problems/knight-dialer">935.Knight Dialer</a></li>
<li><a href="https://leetcode.com/problems/word-break-ii">140.Word Break II</a></li>
<li><a href="https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram">1347.Minimum Number of Steps to Make Two Strings Anagram</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/all-paths-from-source-to-target">797.All Paths From Source to Target</a></li>
<li><a href="https://leetcode.com/problems/merge-intervals">56.Merge Intervals</a></li>
<li><a href="https://leetcode.com/problems/lru-cache">146.LRU Cache</a></li>
<li><a href="https://leetcode.com/problems/trapping-rain-water">42.Trapping Rain Water</a></li>
<li><a href="https://leetcode.com/problems/add-two-numbers-ii">445.Add Two Numbers II</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal">314.Binary Tree Vertical Order Traversal</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree">428.Serialize and Deserialize N-ary Tree</a>difficulty&#x3D;2</li>
<li><a href="https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges">1553.Minimum Number of Days to Eat N Oranges</a>difficulty&#x3D;2</li>
<li><a href="https://leetcode.com/problems/word-search">79.Word Search</a></li>
<li><a href="https://leetcode.com/problems/max-stack">716.Max Stack</a></li>
<li><a href="https://leetcode.com/problems/count-unhappy-friends">1583.Count Unhappy Friends</a></li>
<li><a href="https://leetcode.com/problems/construct-target-array-with-multiple-sums">1354.Construct Target Array With Multiple Sums</a></li>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters">3.Longest Substring Without Repeating Characters</a></li>
<li><a href="https://leetcode.com/problems/valid-triangle-number">611.Valid Triangle Number</a></li>
<li><a href="https://leetcode.com/problems/dot-product-of-two-sparse-vectors">1570.Dot Product of Two Sparse Vectors</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/remove-palindromic-subsequences">1332.Remove Palindromic Subsequences</a></li>
<li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii">117.Populating Next Right Pointers in Each Node II</a></li>
<li><a href="https://leetcode.com/problems/number-of-distinct-substrings-in-a-string">1698.Number of Distinct Substrings in a String</a></li>
<li><a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses">1249.Minimum Remove to Make Valid Parentheses</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/sparse-matrix-multiplication">311.Sparse Matrix Multiplication</a></li>
<li><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree">987.Vertical Order Traversal of a Binary Tree</a></li>
<li><a href="https://leetcode.com/problems/rank-transform-of-an-array">1331.Rank Transform of an Array</a></li>
<li><a href="https://leetcode.com/problems/mirror-reflection">858.Mirror Reflection</a></li>
<li><a href="https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal">1790.Check if One String Swap Can Make Strings Equal</a></li>
<li><a href="https://leetcode.com/problems/game-of-life">289.Game of Life</a></li>
<li><a href="https://leetcode.com/problems/count-integers-in-intervals">2276.Count Integers in Intervals</a></li>
<li><a href="https://leetcode.com/problems/valid-parentheses">20.Valid Parentheses</a></li>
<li><a href="https://leetcode.com/problems/strong-password-checker">420.Strong Password Checker</a></li>
<li><a href="https://leetcode.com/problems/meeting-scheduler">1229.Meeting Scheduler</a></li>
<li><a href="https://leetcode.com/problems/string-compression">443.String Compression</a></li>
<li><a href="https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses">1614.Maximum Nesting Depth of the Parentheses</a>difficulty&#x3D;0</li>
<li><a href="https://leetcode.com/problems/burst-balloons">312.Burst Balloons</a></li>
<li><a href="https://leetcode.com/problems/largest-bst-subtree">333.Largest BST Subtree</a></li>
<li><a href="https://leetcode.com/problems/add-two-numbers">2.Add Two Numbers</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock">121.Best Time to Buy and Sell Stock</a></li>
<li><a href="https://leetcode.com/problems/valid-anagram">242.Valid Anagram</a></li>
<li><a href="https://leetcode.com/problems/insert-delete-getrandom-o(1)---duplicates-allowed">381.Insert Delete GetRandom O(1) - Duplicates allowed</a></li>
<li><a href="https://leetcode.com/problems/elimination-game">390.Elimination Game</a></li>
<li><a href="https://leetcode.com/problems/move-zeroes">283.Move Zeroes</a></li>
<li><a href="https://leetcode.com/problems/maximum-population-year">1854.Maximum Population Year</a></li>
<li><a href="https://leetcode.com/problems/score-of-parentheses">856.Score of Parentheses</a></li>
<li><a href="https://leetcode.com/problems/first-unique-character-in-a-string">387.First Unique Character in a String</a>difficulty&#x3D;0</li>
<li><a href="https://leetcode.com/problems/combination-sum">39.Combination Sum</a></li>
<li><a href="https://leetcode.com/problems/construct-the-rectangle">492.Construct the Rectangle</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-paths">257.Binary Tree Paths</a></li>
<li><a href="https://leetcode.com/problems/toeplitz-matrix">766.Toeplitz Matrix</a></li>
<li><a href="https://leetcode.com/problems/next-permutation">31.Next Permutation</a></li>
<li><a href="https://leetcode.com/problems/number-of-substrings-containing-all-three-characters">1358.Number of Substrings Containing All Three Characters</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/non-decreasing-array">665.Non-decreasing Array</a></li>
<li><a href="https://leetcode.com/problems/median-of-two-sorted-arrays">4.Median of Two Sorted Arrays</a></li>
<li><a href="https://leetcode.com/problems/generate-parentheses">22.Generate Parentheses</a></li>
<li><a href="https://leetcode.com/problems/intersection-of-multiple-arrays">2248.Intersection of Multiple Arrays</a></li>
<li><a href="https://leetcode.com/problems/roman-to-integer">13.Roman to Integer</a></li>
<li><a href="https://leetcode.com/problems/boundary-of-binary-tree">545.Boundary of Binary Tree</a></li>
<li><a href="https://leetcode.com/problems/evaluate-division">399.Evaluate Division</a></li>
<li><a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target">744.Find Smallest Letter Greater Than Target</a>difficulty&#x3D;0</li>
<li><a href="https://leetcode.com/problems/split-array-into-consecutive-subsequences">659.Split Array into Consecutive Subsequences</a></li>
<li><a href="https://leetcode.com/problems/maximum-frequency-stack">895.Maximum Frequency Stack</a></li>
<li><a href="https://leetcode.com/problems/boats-to-save-people">881.Boats to Save People</a></li>
<li><a href="https://leetcode.com/problems/subsets">78.Subsets</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring">5.Longest Palindromic Substring</a></li>
<li><a href="https://leetcode.com/problems/minimum-cost-to-cut-a-stick">1547.Minimum Cost to Cut a Stick</a></li>
<li><a href="https://leetcode.com/problems/copy-list-with-random-pointer">138.Copy List with Random Pointer</a></li>
<li><a href="https://leetcode.com/problems/maximize-distance-to-closest-person">849.Maximize Distance to Closest Person</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/degree-of-an-array">697.Degree of an Array</a></li>
<li><a href="https://leetcode.com/problems/critical-connections-in-a-network">1192.Critical Connections in a Network</a>difficulty&#x3D;2</li>
<li><a href="https://leetcode.com/problems/dungeon-game">174.Dungeon Game</a></li>
<li><a href="https://leetcode.com/problems/n-queens">51.N-Queens</a></li>
<li><a href="https://leetcode.com/problems/custom-sort-string">791.Custom Sort String</a></li>
<li><a href="https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique">1647.Minimum Deletions to Make Character Frequencies Unique</a></li>
<li><a href="https://leetcode.com/problems/number-of-islands">200.Number of Islands</a></li>
<li><a href="https://leetcode.com/problems/recover-binary-search-tree">99.Recover Binary Search Tree</a></li>
<li><a href="https://leetcode.com/problems/sort-array-by-increasing-frequency">1636.Sort Array by Increasing Frequency</a>difficulty&#x3D;0</li>
<li><a href="https://leetcode.com/problems/clone-graph">133.Clone Graph</a></li>
<li><a href="https://leetcode.com/problems/find-the-winner-of-the-circular-game">1823.Find the Winner of the Circular Game</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/reduce-array-size-to-the-half">1338.Reduce Array Size to The Half</a></li>
<li><a href="https://leetcode.com/problems/product-of-array-except-self">238.Product of Array Except Self</a></li>
<li><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree">863.All Nodes Distance K in Binary Tree</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/longest-palindromic-subsequence">516.Longest Palindromic Subsequence</a></li>
<li><a href="https://leetcode.com/problems/unique-number-of-occurrences">1207.Unique Number of Occurrences</a></li>
<li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node">116.Populating Next Right Pointers in Each Node</a></li>
<li><a href="https://leetcode.com/problems/max-area-of-island">695.Max Area of Island</a></li>
<li><a href="https://leetcode.com/problems/shortest-bridge">934.Shortest Bridge</a></li>
<li><a href="https://leetcode.com/problems/coin-change">322.Coin Change</a></li>
<li><a href="https://leetcode.com/problems/two-sum">1.Two Sum</a>difficulty&#x3D;0</li>
<li><a href="https://leetcode.com/problems/next-greater-element-i">496.Next Greater Element I</a></li>
<li><a href="https://leetcode.com/problems/intersection-of-two-arrays">349.Intersection of Two Arrays</a></li>
<li><a href="https://leetcode.com/problems/min-stack">155.Min Stack</a></li>
<li><a href="https://leetcode.com/problems/flatten-nested-list-iterator">341.Flatten Nested List Iterator</a></li>
<li><a href="https://leetcode.com/problems/delete-operation-for-two-strings">583.Delete Operation for Two Strings</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array">34.Find First and Last Position of Element in Sorted Array</a></li>
<li><a href="https://leetcode.com/problems/arithmetic-slices">413.Arithmetic Slices</a></li>
<li><a href="https://leetcode.com/problems/reshape-the-matrix">566.Reshape the Matrix</a></li>
<li><a href="https://leetcode.com/problems/text-justification">68.Text Justification</a></li>
<li><a href="https://leetcode.com/problems/alien-dictionary">269.Alien Dictionary</a></li>
<li><a href="https://leetcode.com/problems/word-break">139.Word Break</a></li>
<li><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self">315.Count of Smaller Numbers After Self</a>difficulty&#x3D;2</li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii">123.Best Time to Buy and Sell Stock III</a>difficulty&#x3D;2</li>
<li><a href="https://leetcode.com/problems/path-sum-ii">113.Path Sum II</a></li>
<li><a href="https://leetcode.com/problems/divide-two-integers">29.Divide Two Integers</a></li>
<li><a href="https://leetcode.com/problems/koko-eating-bananas">875.Koko Eating Bananas</a></li>
<li><a href="https://leetcode.com/problems/4sum">18.4Sum</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/validate-binary-search-tree">98.Validate Binary Search Tree</a></li>
<li><a href="https://leetcode.com/problems/transpose-matrix">867.Transpose Matrix</a></li>
<li><a href="https://leetcode.com/problems/path-sum-iii">437.Path Sum III</a></li>
<li><a href="https://leetcode.com/problems/interval-list-intersections">986.Interval List Intersections</a></li>
<li><a href="https://leetcode.com/problems/word-ladder-ii">126.Word Ladder II</a></li>
<li><a href="https://leetcode.com/problems/sort-an-array">912.Sort an Array</a></li>
<li><a href="https://leetcode.com/problems/reconstruct-itinerary">332.Reconstruct Itinerary</a></li>
<li><a href="https://leetcode.com/problems/find-leaves-of-binary-tree">366.Find Leaves of Binary Tree</a></li>
<li><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets">698.Partition to K Equal Sum Subsets</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/edit-distance">72.Edit Distance</a></li>
<li><a href="https://leetcode.com/problems/longest-consecutive-sequence">128.Longest Consecutive Sequence</a></li>
<li><a href="https://leetcode.com/problems/customers-who-never-order">183.Customers Who Never Order</a></li>
<li><a href="https://leetcode.com/problems/reorganize-string">767.Reorganize String</a></li>
<li><a href="https://leetcode.com/problems/partition-list">86.Partition List</a></li>
<li><a href="https://leetcode.com/problems/ugly-number-ii">264.Ugly Number II</a></li>
<li><a href="https://leetcode.com/problems/pacific-atlantic-water-flow">417.Pacific Atlantic Water Flow</a></li>
<li><a href="https://leetcode.com/problems/search-a-2d-matrix-ii">240.Search a 2D Matrix II</a></li>
<li><a href="https://leetcode.com/problems/permutation-sequence">60.Permutation Sequence</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii">122.Best Time to Buy and Sell Stock II</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree">236.Lowest Common Ancestor of a Binary Tree</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/candy">135.Candy</a>difficulty&#x3D;2</li>
<li><a href="https://leetcode.com/problems/arranging-coins">441.Arranging Coins</a></li>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array">33.Search in Rotated Sorted Array</a></li>
<li><a href="https://leetcode.com/problems/reverse-pairs">493.Reverse Pairs</a></li>
<li><a href="https://leetcode.com/problems/word-ladder">127.Word Ladder</a></li>
<li><a href="https://leetcode.com/problems/meeting-rooms">252.Meeting Rooms</a></li>
<li><a href="https://leetcode.com/problems/counting-bits">338.Counting Bits</a></li>
<li><a href="https://leetcode.com/problems/maximum-units-on-a-truck">1710.Maximum Units on a Truck</a></li>
<li><a href="https://leetcode.com/problems/3sum">15.3Sum</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/minimum-path-sum">64.Minimum Path Sum</a></li>
<li><a href="https://leetcode.com/problems/set-matrix-zeroes">73.Set Matrix Zeroes</a></li>
<li><a href="https://leetcode.com/problems/sort-characters-by-frequency">451.Sort Characters By Frequency</a></li>
<li><a href="https://leetcode.com/problems/longest-increasing-subsequence">300.Longest Increasing Subsequence</a></li>
<li><a href="https://leetcode.com/problems/add-digits">258.Add Digits</a></li>
<li><a href="https://leetcode.com/problems/regular-expression-matching">10.Regular Expression Matching</a></li>
<li><a href="https://leetcode.com/problems/contains-duplicate">217.Contains Duplicate</a></li>
<li><a href="https://leetcode.com/problems/largest-number">179.Largest Number</a></li>
<li><a href="https://leetcode.com/problems/delete-node-in-a-bst">450.Delete Node in a BST</a></li>
<li><a href="https://leetcode.com/problems/sum-of-left-leaves">404.Sum of Left Leaves</a></li>
<li><a href="https://leetcode.com/problems/kth-largest-element-in-an-array">215.Kth Largest Element in an Array</a></li>
<li><a href="https://leetcode.com/problems/next-greater-element-ii">503.Next Greater Element II</a></li>
<li><a href="https://leetcode.com/problems/largest-rectangle-in-histogram">84.Largest Rectangle in Histogram</a></li>
<li><a href="https://leetcode.com/problems/nth-highest-salary">177.Nth Highest Salary</a></li>
<li><a href="https://leetcode.com/problems/combination-sum-ii">40.Combination Sum II</a></li>
<li><a href="https://leetcode.com/problems/integer-to-roman">12.Integer to Roman</a></li>
<li><a href="https://leetcode.com/problems/pow(x,-n)">50.Pow(x, n)</a></li>
<li><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii">350.Intersection of Two Arrays II</a></li>
<li><a href="https://leetcode.com/problems/guess-number-higher-or-lower">374.Guess Number Higher or Lower</a></li>
<li><a href="https://leetcode.com/problems/add-binary">67.Add Binary</a></li>
<li><a href="https://leetcode.com/problems/final-value-of-variable-after-performing-operations">2011.Final Value of Variable After Performing Operations</a>difficulty&#x3D;0</li>
<li><a href="https://leetcode.com/problems/sliding-window-maximum">239.Sliding Window Maximum</a></li>
<li><a href="https://leetcode.com/problems/jump-game-ii">45.Jump Game II</a></li>
<li><a href="https://leetcode.com/problems/merge-two-sorted-lists">21.Merge Two Sorted Lists</a></li>
<li><a href="https://leetcode.com/problems/game-play-analysis-i">511.Game Play Analysis I</a></li>
<li><a href="https://leetcode.com/problems/longest-common-subsequence">1143.Longest Common Subsequence</a></li>
<li><a href="https://leetcode.com/problems/wildcard-matching">44.Wildcard Matching</a></li>
<li><a href="https://leetcode.com/problems/gas-station">134.Gas Station</a></li>
<li><a href="https://leetcode.com/problems/house-robber">198.House Robber</a></li>
<li><a href="https://leetcode.com/problems/employees-earning-more-than-their-managers">181.Employees Earning More Than Their Managers</a></li>
<li><a href="https://leetcode.com/problems/min-cost-climbing-stairs">746.Min Cost Climbing Stairs</a></li>
<li><a href="https://leetcode.com/problems/coin-change-2">518.Coin Change 2</a></li>
<li><a href="https://leetcode.com/problems/longest-valid-parentheses">32.Longest Valid Parentheses</a></li>
<li><a href="https://leetcode.com/problems/shuffle-the-array">1470.Shuffle the Array</a></li>
<li><a href="https://leetcode.com/problems/flood-fill">733.Flood Fill</a></li>
<li><a href="https://leetcode.com/problems/permutations-ii">47.Permutations II</a></li>
<li><a href="https://leetcode.com/problems/word-search-ii">212.Word Search II</a></li>
<li><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number">17.Letter Combinations of a Phone Number</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/reverse-linked-list">206.Reverse Linked List</a></li>
<li><a href="https://leetcode.com/problems/top-k-frequent-words">692.Top K Frequent Words</a></li>
<li><a href="https://leetcode.com/problems/pascal's-triangle">118.Pascal’s Triangle</a></li>
<li><a href="https://leetcode.com/problems/diameter-of-binary-tree">543.Diameter of Binary Tree</a></li>
<li><a href="https://leetcode.com/problems/01-matrix">542.01 Matrix</a></li>
<li><a href="https://leetcode.com/problems/permutations">46.Permutations</a></li>
<li><a href="https://leetcode.com/problems/find-median-from-data-stream">295.Find Median from Data Stream</a></li>
<li><a href="https://leetcode.com/problems/backspace-string-compare">844.Backspace String Compare</a></li>
<li><a href="https://leetcode.com/problems/multiply-strings">43.Multiply Strings</a></li>
<li><a href="https://leetcode.com/problems/minimum-size-subarray-sum">209.Minimum Size Subarray Sum</a></li>
<li><a href="https://leetcode.com/problems/power-of-three">326.Power of Three</a></li>
<li><a href="https://leetcode.com/problems/palindrome-linked-list">234.Palindrome Linked List</a></li>
<li><a href="https://leetcode.com/problems/top-k-frequent-elements">347.Top K Frequent Elements</a></li>
<li><a href="https://leetcode.com/problems/subsets-ii">90.Subsets II</a></li>
<li><a href="https://leetcode.com/problems/house-robber-ii">213.House Robber II</a></li>
<li><a href="https://leetcode.com/problems/delete-node-in-a-linked-list">237.Delete Node in a Linked List</a></li>
<li><a href="https://leetcode.com/problems/3sum-closest">16.3Sum Closest</a></li>
<li><a href="https://leetcode.com/problems/maximum-subarray">53.Maximum Subarray</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal">145.Binary Tree Postorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/group-anagrams">49.Group Anagrams</a></li>
<li><a href="https://leetcode.com/problems/palindrome-number">9.Palindrome Number</a></li>
<li><a href="https://leetcode.com/problems/find-peak-element">162.Find Peak Element</a></li>
<li><a href="https://leetcode.com/problems/find-pivot-index">724.Find Pivot Index</a></li>
<li><a href="https://leetcode.com/problems/intersection-of-two-linked-lists">160.Intersection of Two Linked Lists</a>difficulty&#x3D;0</li>
<li><a href="https://leetcode.com/problems/binary-tree-right-side-view">199.Binary Tree Right Side View</a></li>
<li><a href="https://leetcode.com/problems/search-insert-position">35.Search Insert Position</a></li>
<li><a href="https://leetcode.com/problems/power-of-two">231.Power of Two</a></li>
<li><a href="https://leetcode.com/problems/valid-palindrome">125.Valid Palindrome</a></li>
<li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list">83.Remove Duplicates from Sorted List</a>difficulty&#x3D;0</li>
<li><a href="https://leetcode.com/problems/reverse-integer">7.Reverse Integer</a></li>
<li><a href="https://leetcode.com/problems/happy-number">202.Happy Number</a></li>
<li><a href="https://leetcode.com/problems/spiral-matrix">54.Spiral Matrix</a></li>
<li><a href="https://leetcode.com/problems/number-of-1-bits">191.Number of 1 Bits</a></li>
<li><a href="https://leetcode.com/problems/is-subsequence">392.Is Subsequence</a></li>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree">235.Lowest Common Ancestor of a Binary Search Tree</a></li>
<li><a href="https://leetcode.com/problems/missing-number">268.Missing Number</a></li>
<li><a href="https://leetcode.com/problems/course-schedule">207.Course Schedule</a></li>
<li><a href="https://leetcode.com/problems/unique-paths">62.Unique Paths</a></li>
<li><a href="https://leetcode.com/problems/two-sum-ii---input-array-is-sorted">167.Two Sum II - Input Array Is Sorted</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/majority-element">169.Majority Element</a></li>
<li><a href="https://leetcode.com/problems/search-a-2d-matrix">74.Search a 2D Matrix</a></li>
<li><a href="https://leetcode.com/problems/fibonacci-number">509.Fibonacci Number</a></li>
<li><a href="https://leetcode.com/problems/invert-binary-tree">226.Invert Binary Tree</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal">102.Binary Tree Level Order Traversal</a>difficulty&#x3D;1</li>
<li><a href="https://leetcode.com/problems/merge-sorted-array">88.Merge Sorted Array</a></li>
<li><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list">19.Remove Nth Node From End of List</a></li>
<li><a href="https://leetcode.com/problems/container-with-most-water">11.Container With Most Water</a></li>
<li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array">26.Remove Duplicates from Sorted Array</a>difficulty&#x3D;0</li>
<li><a href="https://leetcode.com/problems/longest-common-prefix">14.Longest Common Prefix</a></li>
<li><a href="https://leetcode.com/problems/binary-search">704.Binary Search</a></li>
<li><a href="https://leetcode.com/problems/rotate-image">48.Rotate Image</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Use Hexo Build Bolg in Github and Connect to your website</title>
    <url>/tech/build-bolg-in-github-and-connect-to-your-website/</url>
    <content><![CDATA[<p><strong>Recommend read the whole article throught before taking actions</strong></p>
<h1 id="What-do-you-need"><a href="#What-do-you-need" class="headerlink" title="What do you need?"></a>What do you need?</h1><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><ul>
<li>An account in <a href="https://github.com/">Github</a></li>
<li>Git in your computer</li>
<li>Node.js</li>
</ul>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><ul>
<li>Your own personalized domain, like: LycheeX.com </li>
<li>An account in <a href="https://www.cloudflare.com/">Cloudflare</a> for certification (<strong>https</strong> looks really cool!)</li>
<li><a href="https://travis-ci.org/">Travis-ci</a> for continuious integration</li>
</ul>
<h1 id="Step-by-Step-Guidance"><a href="#Step-by-Step-Guidance" class="headerlink" title="Step by Step Guidance"></a>Step by Step Guidance</h1><h2 id="Follow-the-step-in-Hexo-Doc-to-install-Git-Node-js-and-Hexo"><a href="#Follow-the-step-in-Hexo-Doc-to-install-Git-Node-js-and-Hexo" class="headerlink" title="Follow the step in Hexo Doc to install Git, Node.js and Hexo"></a>Follow the step in <a href="https://hexo.io/docs/">Hexo Doc</a> to install Git, Node.js and Hexo</h2><p>The doc gives a short and clear introduction in Hexo as well as detailed guidance of installation of Node.js and Git Tool.</p>
<h3 id="Special-for-Mac-User"><a href="#Special-for-Mac-User" class="headerlink" title="Special for Mac User:"></a>Special for Mac User:</h3><p>Installing Node.js® and NPM is pretty straightforward using Homebrew. Homebrew handles downloading, unpacking and installing Node and NPM on your system. The whole process (after you have Homebrew installed) should only take you a few minutes.</p>
<p><strong>Installation Steps:</strong><br>Open the Terminal app and type </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew update</span> <br>// This updates Homebrew with a list of the latest version of Node<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install node</span> <br>// Tell Homebrew to install Node<br></code></pre></td></tr></table></figure>

<p><strong>Test:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">node -v</span> <br>// This should print the version number of node, ike v0.10.31<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm -v</span> <br>// This should print the version number of npm like this 1.4.27<br></code></pre></td></tr></table></figure>

<h2 id="Genernate-Hexo-Blog"><a href="#Genernate-Hexo-Blog" class="headerlink" title="Genernate Hexo Blog"></a>Genernate Hexo Blog</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo init [folder]</span> <br>// Initializes a website. If no folder is provided, Hexo will set up the website in the current directory<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo generate</span> <br>// Generates static files<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo server</span> <br>// Starts a local server. By default, this is at http://localhost:4000/<br>Open http://localhost:4000 and enjoy<br></code></pre></td></tr></table></figure>

<p>More command information, you can refet to <a href="https://hexo.io/docs/commands.html">Hexo Command Doc</a></p>
<h2 id="Choose-a-theme"><a href="#Choose-a-theme" class="headerlink" title="Choose a theme"></a>Choose a theme</h2><p>Lots of developers donated their theme to Hexo, which can save us plenty of time for designing and developing. It’s nice and easy to use. Of course, you can develop your own theme if you want to. I am not sure about the detailed information, but it can be found in the website.</p>
<p>As for me, I chose the theme <a href="https://github.com/gabithume/cactus-light">Cactus Light</a>. Normally, the theme repository on github provides you the steps of add them to your hexo project. </p>
<p>Genernally, following things:</p>
<ol>
<li>In the root directory of your project:</li>
</ol>
<p><code>$ git clone &lt;theme-git-location&gt; themes/&lt;theme-name&gt; </code></p>
<ol start="2">
<li><p>Change the theme property in the _config.yml file under your project</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># theme: landscape</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">cactus-light</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>Enter ‘theme&#x2F;<theme-name>‘ folder and change _config.yml file to configure your information to the template</p>
</li>
<li><p>Run: <code>$ hexo generate</code> and <code>$ hexo server</code></p>
</li>
</ol>
<h2 id="Create-a-new-article"><a href="#Create-a-new-article" class="headerlink" title="Create a new article"></a>Create a new article</h2><p><code>hexo new [layout] &lt;title&gt;</code><br>This command is used to create a new article. If no layout is provided, Hexo will use the default_layout from _config.yml. If the title contains spaces, surround it with quotation marks.<br>Then a new .md file will be created in ‘<your-project>&#x2F;source&#x2F;_posts’ folder.<br>Use any tool you like to edit it. After that, use the following steps:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo clean</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo generate</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo deploy</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo server</span><br></code></pre></td></tr></table></figure>
<p>Now, you are able to see your new blog in <a href="http://localhost:4000/">http://localhost:4000</a>.</p>
<h2 id="Put-it-online-using-Github"><a href="#Put-it-online-using-Github" class="headerlink" title="Put it online using Github"></a>Put it online using Github</h2><p>You need to have a github account. Registering one is as easy as creating an account in Weibo.</p>
<p>Then, you need to create a repository using the name ‘<your-user-name>.github.io’.</p>
<p>Now, let’s get back to your local environment from the web world. </p>
<p>Edit ‘_config.yml’ file in the root directory of your project.<br>Change the deploy node like this:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>     <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>     <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/&lt;your-user-name&gt;/&lt;your-user-name&gt;.github.io.git</span><br>     <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure>

<p>Now, it’s time to deploy to the website.</p>
<p>Hold on, type following code when you are ready.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br>// This is install a package for deploying, you only need to type this once.<br>hexo deploy<br></code></pre></td></tr></table></figure>

<p>Then, open the http:&#x2F;&#x2F;<your-user-name>.github.io to enjoy your website. It should look the same with <a href="http://localhost:4000/">http://localhost:4000</a>.</p>
<h2 id="Connect-to-your-own-domain"><a href="#Connect-to-your-own-domain" class="headerlink" title="Connect to your own domain."></a>Connect to your own domain.</h2><p>Go to the setting page in the respository.<br><img  src="/../../../../../pics/tech/bbigactyw/github-setting.png"  ><span class="image-caption">Github Setting</span><br>Enter your domain in the input and click save.<br><img  src="/../../../../../pics/tech/bbigactyw/add-a-domain.png"  ><span class="image-caption">Add a Domain</span><br>After that, you can visit your website and see the blog.</p>
<h2 id="Connect-to-github"><a href="#Connect-to-github" class="headerlink" title="Connect to github"></a>Connect to github</h2><p>Now all the work is done. You can visit your website from anywhere, add a new article or editing an existing one.<br>However, now you can only edit it in your computer. If you want to put the sources online and edit it anywhere, github is a good help.</p>
<p>Create another repository in Github, give it any name you like. Here, I will use ‘you-like’ as an Example.</p>
<p>In the root directory of your project， type：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br>// this will change your project to a git one.<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote add origin &lt;your-repositoy-location&gt;</span><br>// &lt;your-repositoy-location&gt; should be git@github.com:&lt;your-username&gt;/&lt;your-repository-name&gt;.git<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add *</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;First Commit&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push</span><br></code></pre></td></tr></table></figure>

<p>If you meet some authentication problems during the process, you can check that if you have connected your coputer to Github. Follow the steps in <a href="https://help.github.com/articles/connecting-to-github-with-ssh/">Connecting to GitHub with SSH</a> to solve the problems.</p>
<p>Now you have pushed your original resource to the website. Which means you no longer need to worry about the loss of your project. Every time you change something, just commit them to the Github.</p>
<p>Check the project in github, the folder of the theme that you added may be empty. It is skipped by git because it contains another git log. So the easiest solution is to delete the .git folder and then commit again.</p>
<h2 id="Using-Travis-ci-to-deploy-the-project-on-commit"><a href="#Using-Travis-ci-to-deploy-the-project-on-commit" class="headerlink" title="Using Travis-ci to deploy the project on commit"></a>Using Travis-ci to deploy the project on commit</h2><p>CI is short for Continuous Integration. <a href="https://travis-ci.org/">Travis-ci</a> is one of the most popular website for CI. You could login with your github account and then it will get all your reporsitory.<br><img  src="/../../../../../pics/tech/bbigactyw/travis-ci.png"  ><span class="image-caption">travis-ci</span><br>Switch on the repository of your project and enter the setting of the repository in travis-ci.<br><img  src="/../../../../../pics/tech/bbigactyw/travis-ci-setting.png"  ><span class="image-caption">travid-ci-setting</span><br>Switch on the ‘Build only if .travis.yml is present’.</p>
<p>Now, let’s get back to the repositroy in your computer.<br>Add a new file ‘.travis.yml’ in the root direction. This is for configuration of travis-ci.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><br><span class="hljs-attr">node_js:</span> <span class="hljs-string">stable</span><br><span class="hljs-attr">install:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br><span class="hljs-attr">before_install:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">submodule</span> <span class="hljs-string">update</span> <span class="hljs-string">--init</span> <span class="hljs-string">--remote</span> <span class="hljs-string">--recursive</span><br><span class="hljs-attr">script:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><br><span class="hljs-attr">after_script:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.email</span> <span class="hljs-string">&quot;&lt;your-user-email-in-github&gt;&quot;</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.name</span> <span class="hljs-string">&quot;&lt;your-user-name-in-github&gt;&quot;</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">sed</span> <span class="hljs-string">-i&#x27;&#x27;</span> <span class="hljs-string">&quot;/^ *repo/s~github\.com~$&#123;GH_TOKEN&#125;@github.com~&quot;</span> <span class="hljs-string">_config.yml</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">deploy</span><br><span class="hljs-string">//</span> <span class="hljs-string">The</span> <span class="hljs-string">following</span> <span class="hljs-string">is</span> <span class="hljs-string">required</span> <span class="hljs-string">only</span> <span class="hljs-string">when</span> <span class="hljs-string">you</span> <span class="hljs-string">need</span> <span class="hljs-string">to</span> <span class="hljs-string">use</span> <span class="hljs-string">your</span> <span class="hljs-string">own</span> <span class="hljs-string">domain</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">/home/travis/build/&lt;your-user-name-in-github&gt;/&lt;your-hexo-repository-name-in-github&gt;/.deploy_git/</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;&lt;your-domain&gt;.com&quot;</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">CNAME</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">add</span> <span class="hljs-string">CNAME</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-string">-m</span> <span class="hljs-string">&quot;Add CNAME&quot;</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">push</span> <span class="hljs-string">https://$&#123;GH_TOKEN&#125;@github.com/&lt;your-user-name-in-github&gt;/&lt;your-user-name-in-github&gt;.github.io.git</span><br></code></pre></td></tr></table></figure>


<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><ol>
<li><a href="http://troyyang.com/2017/05/21/Add_Free_Certification_In_Blog_Step_By_Step/">Add Free Certification In Blog Step By Step</a></li>
<li><a href="https://hexo.io/docs/commands.html">Hexo Command Doc</a></li>
</ol>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Dynamic Programming 动态规划</title>
    <url>/tech/dp/</url>
    <content><![CDATA[<h1 id="开篇废话"><a href="#开篇废话" class="headerlink" title="开篇废话"></a>开篇废话</h1><p>时隔一年，又开始了我的算法生涯。唉，苦海无边，人生有涯啊。<br>这次先来看看DP，DP难在找到递归式和边界值。</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>动态规划问题的一般形式就是求最值，求解的核心问题是穷举，然后找最值。<br>动态规划的一般流程就是三步：暴力的递归解法 -&gt; 带备忘录的递归解法 -&gt; 迭代的动态规划解法<br>具体来说，利用递归思维列出正确的 <strong>「状态转移方程」</strong>，判断算法问题是否具备 <strong>「最优子结构」</strong>，即能否通过子问题的最值得到原问题的最值，再判断是否需要用「备忘录」或者「DP table」来优化穷举过程，解决 <strong>「重叠子问题」</strong>。<br>思考步骤：明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组&#x2F;函数的含义</p>
<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自顶向下递归的动态规划</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">状态<span class="hljs-number">1</span>, 状态<span class="hljs-number">2</span>, ...</span>):<br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 所有可能的选择:<br>        <span class="hljs-comment"># 此时的状态已经因为做了选择而改变</span><br>        result = 求最值(result, dp(状态<span class="hljs-number">1</span>, 状态<span class="hljs-number">2</span>, ...))<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-comment"># 自底向上迭代的动态规划</span><br><span class="hljs-comment"># 初始化 base case</span><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][...] = base <span class="hljs-keyword">case</span><br><span class="hljs-comment"># 进行状态转移</span><br><span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">1</span>的所有取值：<br>    <span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> 状态<span class="hljs-number">2</span>的所有取值：<br>        <span class="hljs-keyword">for</span> ...<br>            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 求最值(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2.</span>..)<br></code></pre></td></tr></table></figure>

<h1 id="单串经典问题"><a href="#单串经典问题" class="headerlink" title="单串经典问题"></a>单串经典问题</h1><h2 id="最长递增子序列（Longest-Increasing-Subsequence，LIS）"><a href="#最长递增子序列（Longest-Increasing-Subsequence，LIS）" class="headerlink" title="最长递增子序列（Longest Increasing Subsequence，LIS）"></a>最长递增子序列（Longest Increasing Subsequence，LIS）</h2><h3 id="模版-1"><a href="#模版-1" class="headerlink" title="模版"></a>模版</h3><ol>
<li>嵌套遍历</li>
<li>binary search<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">## 朴素版<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    dp[index] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (dp[index] &lt; nums[i]) &#123;<br>            dp[++index] = nums[i];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = index;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (dp[mid] &lt; nums[i]) &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid;<br>                &#125;<br>            &#125;<br>            dp[l] = nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> index + <span class="hljs-number">1</span>;<br>&#125;<br>## API版本<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Arrays.binarySearch(dp, <span class="hljs-number">0</span>, len, num);<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>            i = -(i + <span class="hljs-number">1</span>);<br>        &#125;<br>        dp[i] = num;<br>        <span class="hljs-keyword">if</span> (i == len) &#123;<br>            len++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><a href="https://leetcode.com/problems/longest-increasing-subsequence">300.Longest Increasing Subsequence</a></li>
<li><a href="https://leetcode.com/problems/number-of-longest-increasing-subsequence">673.Number of Longest Increasing Subsequence</a></li>
<li><a href="https://leetcode.com/problems/russian-doll-envelopes">354.Russian Doll Envelopes</a></li>
<li><a href="https://leetcode.com/problems/largest-divisible-subset">368.Largest Divisible Subset</a></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/labuladong/fucking-algorithm/blob/e94b84cdd1271fceb0cd96172b512169500e6e43/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md">拉不拉东讲解</a></li>
</ul>
<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><h3 id="模版-2"><a href="#模版-2" class="headerlink" title="模版"></a>模版</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Kadane&#x27;s algorithm</span><br>max = cur = <span class="hljs-title class_">None</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-attr">A</span>:<br>    cur = x + <span class="hljs-title function_">max</span>(cur, <span class="hljs-number">0</span>)<br>    max = <span class="hljs-title function_">max</span>(max, cur)<br><span class="hljs-keyword">return</span> max<br></code></pre></td></tr></table></figure>
<p>矩阵的话，方法类似：算出每一列的前缀和，然后遍历所有情况的行组合。O(n^2m)</p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li><a href="https://leetcode.com/problems/maximum-subarray">53.Maximum Subarray</a></li>
<li><a href="https://leetcode.com/problems/maximum-product-subarray">152.Maximum Product Subarray</a></li>
<li><a href="https://leetcode.com/problems/maximum-sum-circular-subarray">918.Maximum Sum Circular Subarray</a></li>
<li><a href="https://leetcode.cn/problems/max-submatrix-lcci/">面试题 17.24. Max Submatrix LCCI</a> </li>
<li><a href="https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/">363. Max Sum of Rectangle No Larger Than K</a></li>
</ul>
<h2 id="最大子数组和变体：House-Robber"><a href="#最大子数组和变体：House-Robber" class="headerlink" title="最大子数组和变体：House Robber"></a>最大子数组和变体：House Robber</h2><h3 id="模版-3"><a href="#模版-3" class="headerlink" title="模版"></a>模版</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">pre1 = pre2 = max = cur = <span class="hljs-title class_">None</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-attr">A</span>:<br>    cur = x + <span class="hljs-title function_">max</span>(pre2, <span class="hljs-number">0</span>)<br>    pre2 = pre1<br>    pre1 = <span class="hljs-title function_">max</span>(pre1, cur)<br>    max = <span class="hljs-title function_">max</span>(max, cur);<br><span class="hljs-keyword">return</span> max<br></code></pre></td></tr></table></figure>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><ul>
<li><a href="https://leetcode.com/problems/house-robber">198.House Robber</a></li>
<li><a href="https://leetcode.com/problems/house-robber-ii">213.House Robber II</a></li>
<li><a href="https://leetcode.com/problems/house-robber-iii">337.House Robber III</a></li>
<li><a href="https://leetcode.com/problems/delete-and-earn">740.Delete and Earn</a></li>
<li><a href="https://leetcode.com/problems/pizza-with-3n-slices/">1388. Pizza With 3n Slices</a></li>
</ul>
<h2 id="需要两个位置的情况"><a href="#需要两个位置的情况" class="headerlink" title="需要两个位置的情况"></a>需要两个位置的情况</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><ul>
<li><a href="https://leetcode.com/problems/length-of-longest-fibonacci-subsequence">873.Length of Longest Fibonacci Subsequence</a></li>
<li><a href="https://leetcode.com/problems/longest-arithmetic-subsequence">1027.Longest Arithmetic Subsequence</a></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><ul>
<li><a href="https://leetcode.com/problems/shortest-way-to-form-string">1055.Shortest Way to Form String</a></li>
<li><a href="https://leetcode.com/problems/longest-valid-parentheses">32.Longest Valid Parentheses</a> 两种方法，空间复杂度O(n)和O(1)</li>
<li><a href="https://leetcode.com/problems/arithmetic-slices/">413. Arithmetic Slices</a></li>
<li><a href="https://leetcode.com/problems/decode-ways">91.Decode Ways</a> 考虑各种情况</li>
<li><a href="https://leetcode.com/problems/palindrome-partitioning-ii">132.Palindrome Partitioning II</a></li>
<li><a href="https://leetcode.com/problems/delete-operation-for-two-strings">583.Delete Operation for Two Strings</a> Edit Distance</li>
<li><a href="https://leetcode.com/problems/counting-bits">338.Counting Bits</a></li>
<li><a href="https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing">801.Minimum Swaps To Make Sequences Increasing</a></li>
<li><a href="https://leetcode.com/problems/minimum-number-of-refueling-stops">871.Minimum Number of Refueling Stops</a> 贪心比较容易想，但是dp的话，还是有点复杂的</li>
</ul>
<h2 id="带维度的单串！！"><a href="#带维度的单串！！" class="headerlink" title="带维度的单串！！"></a>带维度的单串！！</h2><p>增加维度，通常用 k 表示，k 随着题目的不同，可以表示长度，个数，次数，颜色等，同时 k 这个维度的枚举和转移可能涉及到二分，贪心等算法</p>
<h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h3><ul>
<li><a href="https://leetcode.com/problems/paint-house/">256. Paint House</a></li>
<li><a href="https://leetcode.com/problems/paint-house-ii/">265. Paint House II</a></li>
<li><a href="https://leetcode.com/problems/paint-house-iii">1473.Paint House III</a></li>
<li><a href="https://leetcode.com/problems/largest-sum-of-averages">813.Largest Sum of Averages</a> 这题并不难，就是很烦</li>
<li><hl><a href="https://leetcode.com/problems/super-egg-drop">887.Super Egg Drop</a> 测试题</hl></li>
<li><a href="https://leetcode.com/problems/odd-even-jump">975.Odd Even Jump</a> TreeMap</li>
<li><a href="https://leetcode.com/problems/frog-jump">403.Frog Jump</a></li>
<li><a href="https://leetcode.com/problems/allocate-mailboxes">1478.Allocate Mailboxes</a> 搞不定啊！能想到大概思路，但是实现有困难</li>
<li><a href="https://leetcode.com/problems/toss-strange-coins/">1230. Toss Strange Coins</a> 太多细节啦</li>
</ul>
<h2 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h2><ul>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock">121.Best Time to Buy and Sell Stock</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii">122.Best Time to Buy and Sell Stock II</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii">123.Best Time to Buy and Sell Stock III</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv">188.Best Time to Buy and Sell Stock IV</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">309.Best Time to Buy and Sell Stock with Cooldown</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">714.Best Time to Buy and Sell Stock with Transaction Fee</a></li>
</ul>
<h1 id="双串经典问题"><a href="#双串经典问题" class="headerlink" title="双串经典问题"></a>双串经典问题</h1><h2 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h2><ul>
<li><a href="https://leetcode.com/problems/longest-common-subsequence">1143.Longest Common Subsequence</a></li>
<li><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/">712. Minimum ASCII Delete Sum for Two Strings</a></li>
<li><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray">718.Maximum Length of Repeated Subarray</a></li>
<li><a href="https://leetcode.com/problems/edit-distance">72.Edit Distance</a></li>
<li><a href="https://leetcode.com/problems/wildcard-matching">44.Wildcard Matching</a></li>
<li><a href="https://leetcode.com/problems/regular-expression-matching">10.Regular Expression Matching</a> &#x2F;&#x2F; todo</li>
</ul>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h3><ul>
<li><a href="https://leetcode.com/problems/interleaving-string/">97. Interleaving String</a></li>
<li><a href="https://leetcode.com/problems/distinct-subsequences/">115. Distinct Subsequences</a></li>
</ul>
<h2 id="矩阵问题"><a href="#矩阵问题" class="headerlink" title="矩阵问题"></a>矩阵问题</h2><ul>
<li><a href="https://leetcode.com/problems/triangle">120.Triangle</a></li>
<li><a href="https://leetcode.com/problems/minimum-path-sum">64.Minimum Path Sum</a></li>
<li><a href="https://leetcode.com/problems/dungeon-game">174.Dungeon Game</a></li>
<li><a href="https://leetcode.com/problems/maximal-square">221.Maximal Square</a></li>
<li><a href="https://leetcode.com/problems/minimum-falling-path-sum">931.Minimum Falling Path Sum</a></li>
</ul>
<h1 id="无串问题"><a href="#无串问题" class="headerlink" title="无串问题"></a>无串问题</h1><ul>
<li><a href="https://leetcode.com/problems/2-keys-keyboard/">650. 2 Keys Keyboard</a></li>
<li><a href="https://leetcode.com/problems/ugly-number-ii">264.Ugly Number II</a></li>
<li><a href="https://leetcode.com/problems/perfect-squares">279.Perfect Squares</a></li>
<li><a href="https://leetcode.com/problems/integer-break">343.Integer Break</a></li>
</ul>
<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="单纯实现"><a href="#单纯实现" class="headerlink" title="单纯实现"></a>单纯实现</h2><h3 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h3><ul>
<li><a href="https://leetcode.com/problems/range-sum-query-immutable/">303. Range Sum Query - Immutable</a></li>
<li><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/">304. Range Sum Query 2D - Immutable</a></li>
</ul>
<h2 id="数据结构维护前缀和"><a href="#数据结构维护前缀和" class="headerlink" title="数据结构维护前缀和"></a>数据结构维护前缀和</h2><h3 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h3><ul>
<li>哈希表<ul>
<li>键是前缀和（状态）的值，值为第一次出现时的索引</li>
<li>键是前缀和（前缀状态）的值，值为出现次数</li>
<li>键是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模K）</li>
</ul>
</li>
<li>二维数组</li>
<li>线段树</li>
<li>其他：<ul>
<li>前缀和（积）与后缀和（积）均需要</li>
<li>二维前缀和</li>
</ul>
</li>
</ul>
<h3 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h3><ul>
<li><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/">325. Maximum Size Subarray Sum Equals k</a></li>
<li><a href="https://leetcode.com/problems/contiguous-array/">525. Contiguous Array</a></li>
<li><a href="https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts">1371. Find the Longest Substring Containing Vowels in Even Counts</a></li>
<li><a href="https://leetcode.com/problems/subarray-sum-equals-k/">560. Subarray Sum Equals K</a></li>
<li><a href="https://leetcode.com/problems/count-number-of-nice-subarrays/">1248. Count Number of Nice Subarrays</a></li>
<li><a href="https://leetcode.com/problems/continuous-subarray-sum/">523. Continuous Subarray Sum</a></li>
<li><a href="https://leetcode.com/problems/subarray-sums-divisible-by-k/">974. Subarray Sums Divisible by K</a></li>
<li><a href="https://leetcode.com/problems/product-of-array-except-self/">238. Product of Array Except Self</a></li>
<li><a href="https://leetcode.com/problems/find-pivot-index/">724. Find Pivot Index</a></li>
<li><a href="https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">1477. Find Two Non-overlapping Sub-arrays Each With Target Sum</a></li>
<li><a href="https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/">1074. Number of Submatrices That Sum to Target</a></li>
<li><a href="https://leetcode.com/problems/matrix-block-sum/">1314. Matrix Block Sum</a></li>
<li><a href="https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/">363. Max Sum of Rectangle No Larger Than K</a></li>
<li><a href="https://leetcode.com/problems/maximum-product-subarray/">152. Maximum Product Subarray</a></li>
<li><a href="https://leetcode.com/problems/subarray-product-less-than-k/">713. Subarray Product Less Than K</a></li>
<li><a href="https://leetcode.com/problems/product-of-the-last-k-numbers/">1352. Product of the Last K Numbers</a></li>
<li><a href="https://leetcode.com/problems/xor-queries-of-a-subarray/">1310. XOR Queries of a Subarray</a></li>
<li><a href="https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">1442. Count Triplets That Can Form Two Arrays of Equal XOR</a></li>
<li><a href="https://leetcode.com/problems/range-addition/">370. Range Addition</a></li>
</ul>
<h1 id="区间动态规划"><a href="#区间动态规划" class="headerlink" title="区间动态规划"></a>区间动态规划</h1><h2 id="回文系列"><a href="#回文系列" class="headerlink" title="回文系列"></a>回文系列</h2><ul>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring">5.Longest Palindromic Substring</a> &#x2F;&#x2F; todo: classic</li>
<li><a href="https://leetcode.com/problems/palindromic-substrings">647.Palindromic Substrings</a></li>
<li><a href="https://leetcode.com/problems/longest-palindromic-subsequence">516.Longest Palindromic Subsequence</a> &#x2F;&#x2F; todo: classic</li>
<li><a href="https://leetcode.com/problems/count-different-palindromic-subsequences">730.Count Different Palindromic Subsequences</a> &#x2F;&#x2F; todo: 地狱模式</li>
<li><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome">1312.Minimum Insertion Steps to Make a String Palindrome</a></li>
<li><a href="https://leetcode.com/problems/longest-chunked-palindrome-decomposition/">1147. Longest Chunked Palindrome Decomposition</a> &#x2F;&#x2F; todo: 地狱模式</li>
<li><a href="https://leetcode.com/problems/valid-palindrome-iii">1216.Valid Palindrome III</a></li>
</ul>
<h2 id="下面的我一道都不会，被自己蠢哭了【放弃。想转行了"><a href="#下面的我一道都不会，被自己蠢哭了【放弃。想转行了" class="headerlink" title="下面的我一道都不会，被自己蠢哭了【放弃。想转行了"></a>下面的我一道都不会，被自己蠢哭了【放弃。想转行了</h2><h1 id="未归类，我还没做，等慢慢做吧"><a href="#未归类，我还没做，等慢慢做吧" class="headerlink" title="未归类，我还没做，等慢慢做吧"></a>未归类，我还没做，等慢慢做吧</h1><ul>
<li><a href="https://leetcode.com/problems/trapping-rain-water">42.Trapping Rain Water</a></li>
<li><a href="https://leetcode.com/problems/race-car">818.Race Car</a></li>
<li><a href="https://leetcode.com/problems/substring-with-largest-variance">2272.Substring With Largest Variance</a></li>
<li><a href="https://leetcode.com/problems/valid-permutations-for-di-sequence">903.Valid Permutations for DI Sequence</a></li>
<li><a href="https://leetcode.com/problems/generate-parentheses">22.Generate Parentheses</a></li>
<li><a href="https://leetcode.com/problems/k-inverse-pairs-array">629.K Inverse Pairs Array</a></li>
<li><a href="https://leetcode.com/problems/poor-pigs">458.Poor Pigs</a></li>
<li><a href="https://leetcode.com/problems/pascal's-triangle">118.Pascal’s Triangle</a></li>
<li><a href="https://leetcode.com/problems/longest-string-chain">1048.Longest String Chain</a></li>
<li><a href="https://leetcode.com/problems/split-array-largest-sum">410.Split Array Largest Sum</a></li>
<li><a href="https://leetcode.com/problems/binary-trees-with-factors">823.Binary Trees With Factors</a></li>
<li><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix">329.Longest Increasing Path in a Matrix</a></li>
<li><a href="https://leetcode.com/problems/coin-change">322.Coin Change</a></li>
<li><a href="https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string">828.Count Unique Characters of All Substrings of a Given String</a></li>
<li><a href="https://leetcode.com/problems/unique-paths">62.Unique Paths</a></li>
<li><a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling">1235.Maximum Profit in Job Scheduling</a></li>
<li><a href="https://leetcode.com/problems/concatenated-words">472.Concatenated Words</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-cameras">968.Binary Tree Cameras</a></li>
<li><a href="https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary">1639.Number of Ways to Form a Target String Given a Dictionary</a></li>
<li><a href="https://leetcode.com/problems/beautiful-arrangement">526.Beautiful Arrangement</a></li>
<li><a href="https://leetcode.com/problems/climbing-stairs">70.Climbing Stairs</a></li>
<li><a href="https://leetcode.com/problems/word-break">139.Word Break</a></li>
<li><a href="https://leetcode.com/problems/fibonacci-number">509.Fibonacci Number</a></li>
<li><a href="https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares">1240.Tiling a Rectangle with the Fewest Squares</a></li>
<li><a href="https://leetcode.com/problems/jump-game">55.Jump Game</a></li>
<li><a href="https://leetcode.com/problems/count-vowels-permutation">1220.Count Vowels Permutation</a></li>
<li><a href="https://leetcode.com/problems/matchsticks-to-square">473.Matchsticks to Square</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum">124.Binary Tree Maximum Path Sum</a></li>
<li><a href="https://leetcode.com/problems/jump-game-ii">45.Jump Game II</a></li>
<li><a href="https://leetcode.com/problems/word-break-ii">140.Word Break II</a></li>
<li><a href="https://leetcode.com/problems/jump-game-vi">1696.Jump Game VI</a></li>
<li><a href="https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden">1326.Minimum Number of Taps to Open to Water a Garden</a></li>
<li><a href="https://leetcode.com/problems/interleaving-string">97.Interleaving String</a></li>
<li><a href="https://leetcode.com/problems/optimal-account-balancing">465.Optimal Account Balancing</a></li>
<li><a href="https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference">2035.Partition Array Into Two Arrays to Minimize Sum Difference</a></li>
<li><a href="https://leetcode.com/problems/out-of-boundary-paths">576.Out of Boundary Paths</a></li>
<li><a href="https://leetcode.com/problems/minimum-jumps-to-reach-home">1654.Minimum Jumps to Reach Home</a></li>
<li><a href="https://leetcode.com/problems/stickers-to-spell-word">691.Stickers to Spell Word</a></li>
<li><a href="https://leetcode.com/problems/palindrome-partitioning">131.Palindrome Partitioning</a></li>
<li><a href="https://leetcode.com/problems/combination-sum-iv">377.Combination Sum IV</a></li>
<li><a href="https://leetcode.com/problems/sum-of-subarray-minimums">907.Sum of Subarray Minimums</a></li>
<li><a href="https://leetcode.com/problems/burst-balloons">312.Burst Balloons</a></li>
<li><a href="https://leetcode.com/problems/maximal-rectangle">85.Maximal Rectangle</a></li>
<li><a href="https://leetcode.com/problems/student-attendance-record-ii">552.Student Attendance Record II</a></li>
<li><a href="https://leetcode.com/problems/maximum-earnings-from-taxi">2008.Maximum Earnings From Taxi</a></li>
<li><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops">787.Cheapest Flights Within K Stops</a></li>
<li><a href="https://leetcode.com/problems/ones-and-zeroes">474.Ones and Zeroes</a></li>
<li><a href="https://leetcode.com/problems/valid-parenthesis-string">678.Valid Parenthesis String</a></li>
<li><a href="https://leetcode.com/problems/maximum-number-of-points-with-cost">1937.Maximum Number of Points with Cost</a></li>
<li><a href="https://leetcode.com/problems/partition-equal-subset-sum">416.Partition Equal Subset Sum</a></li>
<li><a href="https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero">1611.Minimum One Bit Operations to Make Integers Zero</a></li>
<li><a href="https://leetcode.com/problems/count-sorted-vowel-strings">1641.Count Sorted Vowel Strings</a></li>
<li><a href="https://leetcode.com/problems/different-ways-to-add-parentheses">241.Different Ways to Add Parentheses</a></li>
<li><a href="https://leetcode.com/problems/minimum-cost-for-tickets">983.Minimum Cost For Tickets</a></li>
<li><a href="https://leetcode.com/problems/cherry-pickup">741.Cherry Pickup</a></li>
<li><a href="https://leetcode.com/problems/domino-and-tromino-tiling">790.Domino and Tromino Tiling</a></li>
<li><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets">698.Partition to K Equal Sum Subsets</a></li>
<li><a href="https://leetcode.com/problems/wiggle-subsequence">376.Wiggle Subsequence</a></li>
<li><a href="https://leetcode.com/problems/unique-paths-ii">63.Unique Paths II</a></li>
<li><a href="https://leetcode.com/problems/find-the-shortest-superstring">943.Find the Shortest Superstring</a></li>
<li><a href="https://leetcode.com/problems/maximize-score-after-n-operations">1799.Maximize Score After N Operations</a></li>
<li><a href="https://leetcode.com/problems/unique-binary-search-trees-ii">95.Unique Binary Search Trees II</a></li>
<li><a href="https://leetcode.com/problems/non-overlapping-intervals">435.Non-overlapping Intervals</a></li>
<li><a href="https://leetcode.com/problems/all-possible-full-binary-trees">894.All Possible Full Binary Trees</a></li>
<li><a href="https://leetcode.com/problems/minimum-cost-to-cut-a-stick">1547.Minimum Cost to Cut a Stick</a></li>
<li><a href="https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors">1884.Egg Drop With 2 Eggs and N Floors</a></li>
<li><a href="https://leetcode.com/problems/scramble-string">87.Scramble String</a></li>
<li><a href="https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays">1031.Maximum Sum of Two Non-Overlapping Subarrays</a></li>
<li><a href="https://leetcode.com/problems/target-sum">494.Target Sum</a></li>
<li><a href="https://leetcode.com/problems/count-square-submatrices-with-all-ones">1277.Count Square Submatrices with All Ones</a></li>
<li><a href="https://leetcode.com/problems/01-matrix">542.01 Matrix</a></li>
<li><a href="https://leetcode.com/problems/minimum-cost-to-merge-stones">1000.Minimum Cost to Merge Stones</a></li>
<li><a href="https://leetcode.com/problems/total-appeal-of-a-string">2262.Total Appeal of A String</a></li>
<li><a href="https://leetcode.com/problems/maximum-number-of-books-you-can-take">2355.Maximum Number of Books You Can Take</a></li>
<li><a href="https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product">1567.Maximum Length of Subarray With Positive Product</a></li>
<li><a href="https://leetcode.com/problems/predict-the-winner">486.Predict the Winner</a></li>
<li><a href="https://leetcode.com/problems/partition-array-for-maximum-sum">1043.Partition Array for Maximum Sum</a></li>
<li><a href="https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule">1335.Minimum Difficulty of a Job Schedule</a></li>
<li><a href="https://leetcode.com/problems/unique-binary-search-trees">96.Unique Binary Search Trees</a></li>
<li><a href="https://leetcode.com/problems/knight-dialer">935.Knight Dialer</a></li>
<li><a href="https://leetcode.com/problems/is-subsequence">392.Is Subsequence</a></li>
<li><a href="https://leetcode.com/problems/longest-subarray-of-1's-after-deleting-one-element">1493.Longest Subarray of 1’s After Deleting One Element</a></li>
<li><a href="https://leetcode.com/problems/coin-change-ii">518.Coin Change II</a></li>
<li><a href="https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations">1770.Maximum Score from Performing Multiplication Operations</a></li>
<li><a href="https://leetcode.com/problems/min-cost-climbing-stairs">746.Min Cost Climbing Stairs</a></li>
<li><a href="https://leetcode.com/problems/smallest-sufficient-team">1125.Smallest Sufficient Team</a></li>
<li><a href="https://leetcode.com/problems/longest-binary-subsequence-less-than-or-equal-to-k">2311.Longest Binary Subsequence Less Than or Equal to K</a></li>
<li><a href="https://leetcode.com/problems/longest-mountain-in-array">845.Longest Mountain in Array</a></li>
<li><a href="https://leetcode.com/problems/sum-of-distances-in-tree">834.Sum of Distances in Tree</a></li>
<li><a href="https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum">1524.Number of Sub-arrays With Odd Sum</a></li>
<li><a href="https://leetcode.com/problems/can-i-win">464.Can I Win</a></li>
<li><a href="https://leetcode.com/problems/knight-probability-in-chessboard">688.Knight Probability in Chessboard</a></li>
<li><a href="https://leetcode.com/problems/sentence-screen-fitting">418.Sentence Screen Fitting</a></li>
<li><a href="https://leetcode.com/problems/get-the-maximum-score">1537.Get the Maximum Score</a></li>
<li><a href="https://leetcode.com/problems/as-far-from-land-as-possible">1162.As Far from Land as Possible</a></li>
<li><a href="https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs">1723.Find Minimum Time to Finish All Jobs</a></li>
<li><a href="https://leetcode.com/problems/shortest-path-visiting-all-nodes">847.Shortest Path Visiting All Nodes</a></li>
<li><a href="https://leetcode.com/problems/last-stone-weight-ii">1049.Last Stone Weight II</a></li>
<li><a href="https://leetcode.com/problems/sort-integers-by-the-power-value">1387.Sort Integers by The Power Value</a></li>
<li><a href="https://leetcode.com/problems/minimum-time-to-make-rope-colorful">1578.Minimum Time to Make Rope Colorful</a></li>
<li><a href="https://leetcode.com/problems/divisor-game">1025.Divisor Game</a></li>
<li><a href="https://leetcode.com/problems/least-operators-to-express-number">964.Least Operators to Express Number</a></li>
<li><a href="https://leetcode.com/problems/maximum-students-taking-exam">1349.Maximum Students Taking Exam</a></li>
<li><a href="https://leetcode.com/problems/find-good-days-to-rob-the-bank">2100.Find Good Days to Rob the Bank</a></li>
<li><a href="https://leetcode.com/problems/maximum-and-sum-of-array">2172.Maximum AND Sum of Array</a></li>
<li><a href="https://leetcode.com/problems/flip-string-to-monotone-increasing">926.Flip String to Monotone Increasing</a></li>
<li><a href="https://leetcode.com/problems/the-number-of-good-subsets">1994.The Number of Good Subsets</a></li>
<li><a href="https://leetcode.com/problems/bomb-enemy">361.Bomb Enemy</a></li>
<li><a href="https://leetcode.com/problems/largest-bst-subtree">333.Largest BST Subtree</a></li>
<li><a href="https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities">1617.Count Subtrees With Max Distance Between Cities</a></li>
<li><a href="https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options">1359.Count All Valid Pickup and Delivery Options</a></li>
<li><a href="https://leetcode.com/problems/number-of-people-aware-of-a-secret">2327.Number of People Aware of a Secret</a></li>
<li><a href="https://leetcode.com/problems/parallel-courses-iii">2050.Parallel Courses III</a></li>
<li><a href="https://leetcode.com/problems/number-of-good-ways-to-split-a-string">1525.Number of Good Ways to Split a String</a></li>
<li><a href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum">1155.Number of Dice Rolls With Target Sum</a></li>
<li><a href="https://leetcode.com/problems/numbers-at-most-n-given-digit-set">902.Numbers At Most N Given Digit Set</a></li>
<li><a href="https://leetcode.com/problems/string-compression-ii">1531.String Compression II</a></li>
<li><a href="https://leetcode.com/problems/ways-to-make-a-fair-array">1664.Ways to Make a Fair Array</a></li>
<li><a href="https://leetcode.com/problems/number-of-ways-to-build-sturdy-brick-wall">2184.Number of Ways to Build Sturdy Brick Wall</a></li>
<li><a href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance">1334.Find the City With the Smallest Number of Neighbors at a Threshold Distance</a></li>
<li><a href="https://leetcode.com/problems/count-number-of-teams">1395.Count Number of Teams</a></li>
<li><a href="https://leetcode.com/problems/minimum-deletions-to-make-string-balanced">1653.Minimum Deletions to Make String Balanced</a></li>
<li><a href="https://leetcode.com/problems/numbers-with-repeated-digits">1012.Numbers With Repeated Digits</a></li>
<li><a href="https://leetcode.com/problems/minimum-time-to-finish-the-race">2188.Minimum Time to Finish the Race</a></li>
<li><a href="https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion">1186.Maximum Subarray Sum with One Deletion</a></li>
<li><a href="https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks">1986.Minimum Number of Work Sessions to Finish the Tasks</a></li>
<li><a href="https://leetcode.com/problems/maximum-vacation-days">568.Maximum Vacation Days</a></li>
<li><a href="https://leetcode.com/problems/count-the-number-of-ideal-arrays">2338.Count the Number of Ideal Arrays</a></li>
<li><a href="https://leetcode.com/problems/maximum-profit-from-trading-stocks">2291.Maximum Profit From Trading Stocks</a></li>
<li><a href="https://leetcode.com/problems/number-of-music-playlists">920.Number of Music Playlists</a></li>
<li><a href="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values">1130.Minimum Cost Tree From Leaf Values</a></li>
<li><a href="https://leetcode.com/problems/filling-bookcase-shelves">1105.Filling Bookcase Shelves</a></li>
<li><a href="https://leetcode.com/problems/number-of-ways-to-select-buildings">2222.Number of Ways to Select Buildings</a></li>
<li><a href="https://leetcode.com/problems/max-consecutive-ones-ii">487.Max Consecutive Ones II</a></li>
<li><a href="https://leetcode.com/problems/champagne-tower">799.Champagne Tower</a></li>
<li><a href="https://leetcode.com/problems/kth-ancestor-of-a-tree-node">1483.Kth Ancestor of a Tree Node</a></li>
<li><a href="https://leetcode.com/problems/best-sightseeing-pair">1014.Best Sightseeing Pair</a></li>
<li><a href="https://leetcode.com/problems/cherry-pickup-ii">1463.Cherry Pickup II</a></li>
<li><a href="https://leetcode.com/problems/number-of-squareful-arrays">996.Number of Squareful Arrays</a></li>
<li><a href="https://leetcode.com/problems/decode-ways-ii">639.Decode Ways II</a></li>
<li><a href="https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings">2060.Check if an Original String Exists Given Two Encoded Strings</a></li>
<li><a href="https://leetcode.com/problems/maximum-score-words-formed-by-letters">1255.Maximum Score Words Formed by Letters</a></li>
<li><a href="https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target">1449.Form Largest Integer With Digits That Add up to Target</a></li>
<li><a href="https://leetcode.com/problems/count-all-possible-routes">1575.Count All Possible Routes</a></li>
<li><a href="https://leetcode.com/problems/number-of-ways-to-separate-numbers">1977.Number of Ways to Separate Numbers</a></li>
<li><a href="https://leetcode.com/problems/reducing-dishes">1402.Reducing Dishes</a></li>
<li><a href="https://leetcode.com/problems/push-dominoes">838.Push Dominoes</a></li>
<li><a href="https://leetcode.com/problems/pascal's-triangle-ii">119.Pascal’s Triangle II</a></li>
<li><a href="https://leetcode.com/problems/longest-repeating-substring">1062.Longest Repeating Substring</a></li>
<li><a href="https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array">1671.Minimum Number of Removals to Make Mountain Array</a></li>
<li><a href="https://leetcode.com/problems/maximum-length-of-pair-chain">646.Maximum Length of Pair Chain</a></li>
<li><a href="https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays">689.Maximum Sum of 3 Non-Overlapping Subarrays</a></li>
<li><a href="https://leetcode.com/problems/constrained-subsequence-sum">1425.Constrained Subsequence Sum</a></li>
<li><a href="https://leetcode.com/problems/count-number-of-texts">2266.Count Number of Texts</a></li>
<li><a href="https://leetcode.com/problems/minimum-window-subsequence">727.Minimum Window Subsequence</a></li>
<li><a href="https://leetcode.com/problems/count-substrings-that-differ-by-one-character">1638.Count Substrings That Differ by One Character</a></li>
<li><a href="https://leetcode.com/problems/minimum-costs-using-the-train-line">2361.Minimum Costs Using the Train Line</a></li>
<li><a href="https://leetcode.com/problems/count-number-of-ways-to-place-houses">2320.Count Number of Ways to Place Houses</a></li>
<li><a href="https://leetcode.com/problems/shopping-offers">638.Shopping Offers</a></li>
<li><a href="https://leetcode.com/problems/k-concatenation-maximum-sum">1191.K-Concatenation Maximum Sum</a></li>
<li><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three">1262.Greatest Sum Divisible by Three</a></li>
<li><a href="https://leetcode.com/problems/encode-string-with-shortest-length">471.Encode String with Shortest Length</a></li>
<li><a href="https://leetcode.com/problems/kth-smallest-instructions">1643.Kth Smallest Instructions</a></li>
<li><a href="https://leetcode.com/problems/tallest-billboard">956.Tallest Billboard</a></li>
<li><a href="https://leetcode.com/problems/best-team-with-no-conflicts">1626.Best Team With No Conflicts</a></li>
<li><a href="https://leetcode.com/problems/make-the-xor-of-all-segments-equal-to-zero">1787.Make the XOR of All Segments Equal to Zero</a></li>
<li><a href="https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements">2163.Minimum Difference in Sums After Removal of Elements</a></li>
<li><a href="https://leetcode.com/problems/n-th-tribonacci-number">1137.N-th Tribonacci Number</a></li>
<li><a href="https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix">562.Longest Line of Consecutive One in Matrix</a></li>
<li><a href="https://leetcode.com/problems/non-negative-integers-without-consecutive-ones">600.Non-negative Integers without Consecutive Ones</a></li>
<li><a href="https://leetcode.com/problems/restore-the-array">1416.Restore The Array</a></li>
<li><a href="https://leetcode.com/problems/number-of-digit-one">233.Number of Digit One</a></li>
<li><a href="https://leetcode.com/problems/count-numbers-with-unique-digits">357.Count Numbers with Unique Digits</a></li>
<li><a href="https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference">1218.Longest Arithmetic Subsequence of Given Difference</a></li>
<li><a href="https://leetcode.com/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses">2086.Minimum Number of Buckets Required to Collect Rainwater from Houses</a></li>
<li><a href="https://leetcode.com/problems/android-unlock-patterns">351.Android Unlock Patterns</a></li>
<li><a href="https://leetcode.com/problems/longest-turbulent-subarray">978.Longest Turbulent Subarray</a></li>
<li><a href="https://leetcode.com/problems/maximum-value-of-k-coins-from-piles">2218.Maximum Value of K Coins From Piles</a></li>
<li><a href="https://leetcode.com/problems/painting-a-grid-with-three-different-colors">1931.Painting a Grid With Three Different Colors</a></li>
<li><a href="https://leetcode.com/problems/airplane-seat-assignment-probability">1227.Airplane Seat Assignment Probability</a></li>
<li><a href="https://leetcode.com/problems/where-will-the-ball-fall">1706.Where Will the Ball Fall</a></li>
<li><a href="https://leetcode.com/problems/maximum-height-by-stacking-cuboids">1691.Maximum Height by Stacking Cuboids</a></li>
<li><a href="https://leetcode.com/problems/longest-ideal-subsequence">2370.Longest Ideal Subsequence</a></li>
<li><a href="https://leetcode.com/problems/stone-game">877.Stone Game</a></li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><ul>
<li><a href="https://leetcode.cn/leetbook/read/dynamic-programming-1-plus/xch21e/">LeetBook 动态规划精讲（一）</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph 图</title>
    <url>/tech/graph/</url>
    <content><![CDATA[<p>太难了！我哭了！</p>
<h1 id="遍历所有顶点"><a href="#遍历所有顶点" class="headerlink" title="遍历所有顶点"></a>遍历所有顶点</h1><p><a href="https://leetcode.com/problems/all-paths-from-source-to-target">797. All Paths From Source to Target</a></p>
<h2 id="深度优先搜索算法-Depth-First-Search-DFS"><a href="#深度优先搜索算法-Depth-First-Search-DFS" class="headerlink" title="深度优先搜索算法 Depth First Search - DFS"></a>深度优先搜索算法 Depth First Search - DFS</h2><p><strong>栈</strong><br>主要用途：</p>
<ul>
<li>遍历「图」中所有顶点</li>
<li>遍历「图」中任意两点之间的所有路径<br>实现：递归</li>
</ul>
<h2 id="广度优先搜索算法-BFS"><a href="#广度优先搜索算法-BFS" class="headerlink" title="广度优先搜索算法 BFS"></a>广度优先搜索算法 BFS</h2><p><strong>队列</strong><br>主要用途：</p>
<ul>
<li>当在 权重相等且均为正数的「图」 中，快速找出两点之间的最短路径</li>
<li>遍历「图」中所有顶点<br>实现：队列</li>
</ul>
<p>时间复杂度: O(V+E)<br>&#x2F;V&#x2F; 表示顶点数，&#x2F;E&#x2F; 表示边数。</p>
<p>空间复杂度: O(V)<br>&#x2F;V&#x2F; 表示顶点数。</p>
<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><a href="https://leetcode.com/problems/min-cost-to-connect-all-points/">1584. Min Cost to Connect All Points</a><br>生成树指的是「无向图」中，具有该图的<strong>全部顶点</strong>且<strong>边数最少</strong>的连通子图。<br>最小生成树指的是「加权无向图」中总权重最小的生成树。</p>
<h2 id="切分定理"><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h2><p>切分：将「图」切成两个部分，称之为一个「切分」。<br>横切边：如果一条边连接的两个顶点属于切分的两个部分，这个边称为「横切边」。<br>切分定理：在一幅连通加权无向图中，给定任意的切分，如果有一条横切边的权值严格小于所有其他横切边，则这条边必然属于图的最小生成树中的一条边。</p>
<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>求解「加权无向图」的「最小生成树」<br>Steps:</p>
<ol>
<li>所有边从小到大排序</li>
<li>依次加入最小生成树中，形成环则跳过</li>
<li>直到选择n-1条边为止</li>
</ol>
<p>时间复杂度: O(ElogE)<br>&#x2F;E&#x2F; 表示边数。</p>
<p>空间复杂度: O(V)<br>&#x2F;V&#x2F; 表示顶点数。</p>
<h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>求解「加权无向图」的「最小生成树」的另一种算法<br>Steps:</p>
<ol>
<li>用两个集合a, b分别存储已访问节点和未访问节点</li>
<li>从未访问节点集合b中，任选一个节点放入a中</li>
<li>从连接的a, b集合的所有边中，选择权重最小的边，将边连接的b集合中的节点放入a中</li>
<li>重复步骤3，直到b为空</li>
</ol>
<p>时间复杂度: </p>
<ul>
<li>普通二叉堆： O(ElogV)</li>
<li>斐波那契堆：O(E+VlogV)<br>&#x2F;V&#x2F; 表示顶点数，&#x2F;E&#x2F; 表示边数。</li>
</ul>
<p>空间复杂度: O(V)<br>&#x2F;V&#x2F; 表示顶点数。</p>
<h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><p>在加权图中，给定一个起点，求出它分别到其他顶点的「最短路径」</p>
<h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>求解加权图「单源最短路径」问题，其中该图的所有权重必须为非负数<br><a href="https://leetcode.com/problems/network-delay-time">743. Network Delay Time</a><br>Steps:</p>
<ol>
<li>初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为“起点s到该顶点的距离”，例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞</li>
<li>从U中选出“距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</li>
<li>更新U中各个顶点到起点s的距离。由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</li>
<li>重复步骤(2)和(3)，直到遍历完所有顶点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用一个数据结构，存储每一个节点的相邻节点和距离，也可以用int[]&#123;next node index, distance&#125;</span><br>List&lt;Map&lt;Integer, Integer&gt;&gt; neighbors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br>...<br><span class="hljs-comment">// 利用优先队列排序下一条边</span><br>PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;<span class="hljs-type">int</span>[]&gt;(<br>        (info1, info2) -&gt; info1[<span class="hljs-number">0</span>] - info2[<span class="hljs-number">0</span>]); <br><span class="hljs-comment">// 将目标节点放入队列中</span><br>heap.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, target&#125;);<br><span class="hljs-comment">// 用map存储结果</span><br>Map&lt;Integer, Integer&gt; dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;<br>    <span class="hljs-type">int</span>[] info = heap.poll();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> info[<span class="hljs-number">0</span>], cur = info[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (dist.containsKey(cur)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 已知cur节点的最优解，不用再麻烦了</span><br>    dist.put(cur, d); <span class="hljs-comment">// 当前解为cur的最优解</span><br>    Map&lt;Integer, Integer&gt; nexts = neighbors.get(node); <span class="hljs-comment">// 得到下一节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nxt: nexts.keySet()) &#123;<br>        <span class="hljs-keyword">if</span> (!dist.containsKey(nxt)) <span class="hljs-comment">// 下一节点的最优解未知，加入队列中</span><br>            heap.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;d + nexts.get(nxt), nxt&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>时间复杂度: </p>
<ul>
<li>斐波那契堆：O(E+VlogV)<br>&#x2F;V&#x2F; 表示顶点数，&#x2F;E&#x2F; 表示边数。</li>
</ul>
<p>空间复杂度: O(V)<br>&#x2F;V&#x2F; 表示顶点数。</p>
<h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><p>解决「负权图」的「单源最短路径」问题<br><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">787. Cheapest Flights Within K Stops</a></p>
<h3 id="基础定理"><a href="#基础定理" class="headerlink" title="基础定理"></a>基础定理</h3><p><strong>定理一</strong>：在一个有 N 个顶点的「非负权环图」中，两点之间的最短路径最多经过 N-1N−1 条边<br><strong>定理二</strong>：「负权环」没有最短路径</p>
<h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>Def. OPT(i, v) &#x3D; length of shortest path P from v to t using at most i edges.<br>There are two options: </p>
<ul>
<li>P uses at most i-1 edges -&gt; OPT(i, v) &#x3D; OPT(i-1, v) </li>
<li>P uses exactly i edges -&gt; OPT(i-1, w)+Cwv</li>
</ul>
<h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Shortest</span>-<span class="hljs-title class_">Path</span>(G, t) &#123; <br>	<span class="hljs-keyword">for</span> each node v ∈ V<br>		M[<span class="hljs-number">0</span>,v] =  ∞ <br>		M[<span class="hljs-number">0</span>, t] = <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> I = <span class="hljs-number">1</span> to n-<span class="hljs-number">1</span><br>		<span class="hljs-keyword">for</span> each node v ∈ V<br>			M[i, v] = M[i-<span class="hljs-number">1</span>, v] <br>		<span class="hljs-keyword">for</span> each edge (v, w) ∈ E<br>			M[i, v] = <span class="hljs-title function_">min</span>(M[i, v], M[i-<span class="hljs-number">1</span>, w] + <span class="hljs-title class_">Cvw</span>) <br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度: O(mn)</p>
<p>空间复杂度: O(n^2)</p>
<h4 id="Practical-improvements"><a href="#Practical-improvements" class="headerlink" title="Practical improvements"></a>Practical improvements</h4><ul>
<li>Maintain only one array M[v] &#x3D; shortest v-t path that we have found so far. </li>
<li>No need to check edges of the form (v, w) unless M[w] changed in previous iteration. <figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Push</span>-<span class="hljs-title class_">Based</span>-<span class="hljs-title class_">Shortest</span>-<span class="hljs-title class_">Path</span>(G, s, t) &#123; <br>	<span class="hljs-keyword">for</span> each node v ∈ V &#123;<br>		M[v] = ∞<br>		successor[v] = <span class="hljs-literal">null</span><br>	&#125;<br>	M[t] = <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to n-<span class="hljs-number">1</span> &#123;<br>		<span class="hljs-keyword">for</span> each node w ∈ V &#123;<br>			<span class="hljs-keyword">if</span> (M[w] has been updated <span class="hljs-keyword">in</span> previous iteration) &#123;<br>				<span class="hljs-keyword">for</span> each node v such that (v, w) ∈ E &#123; <br>					<span class="hljs-keyword">if</span> (M[v] &gt; M[w] + <span class="hljs-title class_">Cvw</span>)  &#123;<br>						M[v] = M[w] + <span class="hljs-title class_">Cvw</span><br>						successor[v] = w<br>					&#125;<br>				&#125; <br>			&#125;<br>			<span class="hljs-title class_">If</span> no M[w] value changed <span class="hljs-keyword">in</span> iteration I, stop. <br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Bellman-Ford-检测「负权环」"><a href="#Bellman-Ford-检测「负权环」" class="headerlink" title="Bellman-Ford 检测「负权环」"></a>Bellman-Ford 检测「负权环」</h3><p>当对所有边进行N-1次松弛之后，再进行第N次松弛。<br>根据「Bellman-Ford 算法」，所有的边在N−1次松弛之后，所有的距离必然是最短距离。<br>如果在进行第N次松弛后，对于一条边edge(u, v)，还存在<code>distances[u] + weight(u, v) &lt; distances(v)</code>的情况，也就是说，还存在更短的路径。<br>此时就能说明「图」中存在「负权环」。</p>
<h3 id="SPFA-算法-基于「队列」优化的-Bellman-Ford-算法"><a href="#SPFA-算法-基于「队列」优化的-Bellman-Ford-算法" class="headerlink" title="SPFA 算法 - 基于「队列」优化的 Bellman-Ford 算法"></a>SPFA 算法 - 基于「队列」优化的 Bellman-Ford 算法</h3><p>「SPFA 算法」主要是通过「队列」来维护我们接下来要遍历边的起点，而不是「Bellman Ford」算法中的任意还没有遍历过的边。每次只有当某个顶点的最短距离更新之后，并且该顶点不在「队列」中，我们就将该顶点加入到「队列」中。一直循环以上步骤，直到「队列」为空，我们就可以终止算法。</p>
<h1 id="拓扑排序-Topological-Sort"><a href="#拓扑排序-Topological-Sort" class="headerlink" title="拓扑排序 Topological Sort"></a>拓扑排序 Topological Sort</h1><p>对「有向无环图」中所有顶点按照先后顺序的一种线性排序</p>
<h4 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h4><ul>
<li>有向无环图；</li>
<li>「图」中至少有一个顶点「入度」为 0 。如果「图」中所有顶点都有「入度」，则代表所有顶点都至少有一个前置顶点，那么这个就没有顶点可以作为「拓扑排序」的起点。</li>
</ul>
<h2 id="Kahn-算法"><a href="#Kahn-算法" class="headerlink" title="Kahn 算法"></a>Kahn 算法</h2><p><a href="https://leetcode.com/problems/course-schedule-ii/">210. Course Schedule II</a><br>Steps:</p>
<ol>
<li>统计所有的顶点的出入度，将所有入度为0的节点，放入队列中</li>
<li>将队列中的节点取出，标记为已访问，并更新剩余节点的入度数量</li>
<li>重复步骤1-2直到队列为空</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] indegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>List&lt;List&lt;Integer&gt;&gt; nexts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存储下一个节点，可以用Map</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  nexts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>&#125;<br><br>Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">// 找出所有入度为0的第一层节点，放入队列中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  <span class="hljs-keyword">if</span> (indegrees[i] == <span class="hljs-number">0</span>)<br>    queue.add(i);<br>&#125;<br><br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll(); <span class="hljs-comment">// 取出当前节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nxt : nexts.get(cur)) &#123;<br>    <span class="hljs-comment">// 更新下一节点的入度</span><br>    indegrees[nxt]--;<br>    <span class="hljs-keyword">if</span> (indegrees[nxt] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 更新时检查，是否还有前序节点</span><br>      queue.add(nxt); <br>    &#125;<br>  &#125;<br>&#125;<br>...<br></code></pre></td></tr></table></figure>

<p>时间复杂度: O(V+E)<br>&#x2F;V&#x2F; 表示顶点数，&#x2F;E&#x2F; 表示边数。</p>
<p>空间复杂度: O(V+E)<br>&#x2F;V&#x2F; 表示顶点数，&#x2F;E&#x2F; 表示边数。</p>
<h4 id="更多练习"><a href="#更多练习" class="headerlink" title="更多练习"></a>更多练习</h4><h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li><a href="https://leetcode.com/problems/course-schedule/">207. Course Schedule</a></li>
<li><a href="https://leetcode.com/problems/loud-and-rich/">851. Loud and Rich</a>（拓扑排序）</li>
</ul>
<h4 id="复杂"><a href="#复杂" class="headerlink" title="复杂"></a>复杂</h4><ul>
<li><a href="https://leetcode.com/problems/minimum-height-trees/">310. Minimum Height Trees</a> （拓扑排序）</li>
<li><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/">329. Longest Increasing Path in a Matrix</a> （DFS）</li>
<li><a href="https://leetcode.com/problems/find-eventual-safe-states/">802. Find Eventual Safe States</a>（1. 拓扑排序; 2. 深度优先搜索 + 三色标记法）</li>
<li><a href="https://leetcode.com/problems/sequence-reconstruction">444. Sequence Reconstruction</a>（拓扑排序，费了我老劲了！）</li>
<li><a href="https://leetcode.com/problems/parallel-courses">1136. Parallel Courses</a>（拓扑排序，这次就轻松多了）</li>
<li><a href="https://leetcode.com/problems/parallel-courses-iii/">2050. Parallel Courses III</a>（拓扑排序，和上一题类似，但是<a href="https://leetcode.com/problems/parallel-courses-ii/">2050. Parallel Courses II</a>就变态多了，是个NP问题）</li>
<li><a href="https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/">1786. Number of Restricted Paths From First to Last Node</a>（Dijkstra 算法 + 记忆化dp）</li>
<li><a href="https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/">1976. Number of Ways to Arrive at Destination</a>（Dijkstra 算法 + 记忆化dp）</li>
<li><a href="https://leetcode.com/problems/course-schedule-iv/">1462. Course Schedule IV</a>	（拓扑排序）</li>
<li><a href="https://leetcode.com/tag/topological-sort/#:~:text=Largest%20Color%20Value%20in%20a%20Directed%20Graph">1857. Largest Color Value in a Directed Graph</a>	（拓扑排序）</li>
</ul>
<h4 id="未解之谜"><a href="#未解之谜" class="headerlink" title="未解之谜"></a>未解之谜</h4><ul>
<li><a href="https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony">1916. Count Ways to Build Rooms in an Ant Colony</a></li>
<li><a href="https://leetcode.com/problems/design-excel-sum-formula/">631. Design Excel Sum Formula</a></li>
<li><a href="https://leetcode.com/problems/rank-transform-of-a-matrix/">1632. Rank Transform of a Matrix</a></li>
<li><a href="https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/">1203. Sort Items by Groups Respecting Dependencies</a></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://leetcode-cn.com/leetbook/read/graph/r340gv/">LeetBook《图》</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式笔记</title>
    <url>/tech/head-first-design-pattern/</url>
    <content><![CDATA[<h1 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h1><ul>
<li>可维护</li>
<li>可复用</li>
<li>可扩展</li>
<li>灵活性好</li>
</ul>
<p>随着业务变得越来越复杂，面向对象依然能够使得程序结构良好，而面向过程却会导致程序越来越臃肿。</p>
<h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><ul>
<li>开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放</li>
<li>单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因</li>
<li>里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能</li>
<li>依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成</li>
<li>迪米特法则：又名“最少知道原则”，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话</li>
<li>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法</li>
</ul>
<h1 id="构建型模式-Creational-Patterns"><a href="#构建型模式-Creational-Patterns" class="headerlink" title="构建型模式 Creational Patterns"></a>构建型模式 Creational Patterns</h1><h2 id="工厂模式-Factory"><a href="#工厂模式-Factory" class="headerlink" title="工厂模式 Factory"></a>工厂模式 Factory</h2><p>封装对象的设计模式，隐藏通用的实现细节和操作<br>可以降低耦合和减少代码重复<br>详细分类：</p>
<ul>
<li>简单工厂模式<br>让一个工厂类承担构建所有对象的职责<br>弊端：<ul>
<li>如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类</li>
<li>当要生产新的产品时，必须在工厂类中添加新的分支，违背了开闭原则</li>
</ul>
</li>
<li>工厂方法模式<br>为每个产品创建专属工厂，降低了产品间的互相依赖</li>
<li>抽象工厂模式 Abstract factory<br>在工厂方法模式的基础上，将公共的工厂接口提取到<code>Interface</code>中，然后产品工厂实现接口<br>抽象工厂弱化了产品工厂的存在感，统一了方法签名，使得实现替换更加容易<br>抽象工厂模式很好的发挥了开闭原则、依赖倒置原则，但缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类<br>因此，抽象工厂模式适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展</li>
</ul>
<h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h2><p>单例模式非常常见，某个对象全局只需要一个实例时，就可以使用单例模式。它的优点也显而易见：</p>
<ul>
<li>它能够避免对象重复创建，节约空间并提升效率</li>
<li>避免由于操作不同实例导致的逻辑错误</li>
</ul>
<p>单例模式有两种实现方式：</p>
<ul>
<li><p>饿汉式<br>在声明时初始化，构造方法通常定义为 private，保证了其他类无法实例化此类，必须通过<code>getInstance</code>方法才能获取到唯一的<code>instance</code>实例<br>弊端：即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间</p>
</li>
<li><p>懒汉式<br>先声明一个空变量，需要用时才初始化，在<code>getInstance</code>方法中判空创建，<br>好处：按需加载，避免了内存浪费，减少了类初始化时间<br>弊端：1. 非线程安全; 2. 将程序加载时间从启动时延后到了运行时，没有做到构建与使用分离，解耦<br>解决方案一：给判空过程加上锁，</p>
<ol>
<li>双检锁方式，程序效率更高  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>              <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                  instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
  JVM 底层为了优化程序运行效率，可能会对代码进行指令重排序，在一些特殊情况下会导致出现空指针，更进一步的优化是给 instance 变量加上 volatile 关键字</li>
<li>方法级别加锁，有一说双重检测法，低版本的JVM无法保证线程安全  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>          instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>解决方案二：静态内部类方式保证懒汉式单例的线程安全<br>  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<ol>
<li>静态内部类方式是怎么实现懒加载的<br>Java 类的加载过程包括：加载、验证、准备、解析、初始化。初始化阶段即执行类的 clinit 方法（clinit &#x3D; class + initialize），包括为类的静态变量赋初始值和执行静态代码块中的内容。但不会立即加载内部类，内部类会在使用时才加载。所以当此 Singleton 类加载时，SingletonHolder 并不会被立即加载，所以不会像饿汉式那样占用内存。<br>另外，Java 虚拟机规定，当访问一个类的静态字段时，如果该类尚未初始化，则立即初始化此类。当调用Singleton 的 getInstance 方法时，由于其使用了 SingletonHolder 的静态变量 instance，所以这时才会去初始化 SingletonHolder，在 SingletonHolder 中 new 出 Singleton 对象。这就实现了懒加载。</li>
<li>静态内部类方式是怎么保证线程安全的<br>Java 虚拟机的设计是非常稳定的，早已经考虑到了多线程并发执行的情况。虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。</li>
</ol>
<p>对于构建不复杂，加载完成后会立即使用的单例对象，推荐使用饿汉式。对于构建过程耗时较长，并不是所有使用此类都会用到的单例对象，推荐使用懒汉式。</p>
</li>
</ul>
<h2 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 Builder"></a>建造者模式 Builder</h2><p>建造者模式用于创建过程稳定，但配置多变的对象，将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示，不用担心忘了指定某个配置，保证了构建过程是稳定的<br>通过链式调用生成不同的配置<br>Lombok’s @Builder</p>
<h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象<br>比如：Object 的 clone()</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>工厂方法模式：为每一类对象建立工厂，将对象交由工厂创建，客户端只和工厂打交道。</li>
<li>抽象工厂模式：为每一类工厂提取出抽象接口，使得新增工厂、替换工厂变得非常容易。</li>
<li>建造者模式：用于创建构造过程稳定的对象，不同的 Builder 可以定义不同的配置。</li>
<li>单例模式：全局使用同一个对象，分为饿汉式和懒汉式。懒汉式有双检锁和内部类两种实现方式。</li>
<li>原型模式：为一个类定义 clone 方法，使得创建相同的对象更方便。</li>
</ul>
<h1 id="结构型模式-Structural-Patterns"><a href="#结构型模式-Structural-Patterns" class="headerlink" title="结构型模式 Structural Patterns"></a>结构型模式 Structural Patterns</h1><h2 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h2><p>适用于有相关性但不兼容的结构，源接口通过一个中间件转换后才可以适用于目标接口，这个转换过程就是适配，这个中间件就称之为适配器<br>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作</p>
<h2 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 Bridge"></a>桥接模式 Bridge</h2><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式</p>
<h2 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h2><p>用于整体与部分的结构，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式<br>又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构</p>
<h4 id="组合模式中的安全方式与透明方式"><a href="#组合模式中的安全方式与透明方式" class="headerlink" title="组合模式中的安全方式与透明方式"></a>组合模式中的安全方式与透明方式</h4><p>透明方式：在 Component 中声明所有管理子对象的方法，包括 add 、remove 等，这样继承自 Component 的子类都具备了 add、remove 方法。对于外界来说叶节点和枝节点是透明的，它们具备完全一致的接口<br>安全方式：在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可</p>
<h2 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 Decorator"></a>装饰模式 Decorator</h2><p>动态地给一个对象增加一些额外的职责，又称为包装器&#x2F;“油漆工模式”<br>Java I&#x2F;O<br>主要作用:</p>
<ul>
<li>增强一个类原有的功能 - 透明装饰模式 - 可以无限装饰</li>
<li>为一个类添加新的功能 - 半透明装饰模式 - 无法多次装饰<br>可以说，装饰模式是继承的一种替代方案，比生成子类实现更为灵活</li>
</ul>
<h2 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h2><p>体现Java封装思想，将多个子系统封装起来，提供一个更简洁的接口供外部调用<br>外部与一个子系统的通信必须通过一个统一的外观对象进行，外观模式定义了一个高层接口，为子系统中的一组接口提供一个一致的界面，使得子系统更加容易使用，又称为门面模式</p>
<h2 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式 Flyweight"></a>享元模式 Flyweight</h2><p>共享对象，提高复用性，DRY(Don’t repeat yourself)</p>
<h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h2><p>给某一个对象提供一个代理，并由代理对象<strong>控制</strong>对原对象的引用<br>分为：</p>
<ul>
<li>静态代理</li>
<li>动态代理：优势，节省代码量，只需实现需要控制的方法，通过方法名对被代理类进行动态的控制</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>适配器模式：用于有相关性但不兼容的接口</li>
<li>桥接模式：用于同等级的接口互相组合</li>
<li>组合模式：用于整体与部分的结构</li>
<li>外观模式：体现封装的思想</li>
<li>享元模式：体现面向对象的可复用性</li>
<li>代理模式：主要用于对某个对象加以控制</li>
</ul>
<h1 id="行为型模式-Behavioral-Pattern"><a href="#行为型模式-Behavioral-Pattern" class="headerlink" title="行为型模式 Behavioral Pattern"></a>行为型模式 Behavioral Pattern</h1><h2 id="责任链模式-Chain-of-responsibility"><a href="#责任链模式-Chain-of-responsibility" class="headerlink" title="责任链模式 Chain of responsibility"></a>责任链模式 Chain of responsibility</h2><p>处理职责相同，程度不同的类<br>优点：</p>
<ul>
<li>降低对象之间的耦合，发送者无须关心处理细节和传递过程，和处理者解耦</li>
<li>扩展性强，满足开闭原则，可以根据需要增加新的请求处理类</li>
<li>灵活性强。可以动态地改变链内的成员或者改变链的次序来适应流程的变化</li>
<li>简化对象之间的连接。每个对象只需保持一个指向其后继者的引用</li>
<li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合单一职责原则<br>缺点：</li>
<li>不能保证每个请求一定被处理，该请求可能一直传到链的末端都得不到处理</li>
<li>如果责任链过长，请求的处理可能涉及多个处理对象，系统性能将受到一定影响</li>
<li>责任链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于责任链拼接次序错误而导致系统出错，比如循环调用</li>
</ul>
<h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h2><p>通过execute去调用方法，封装 “方法调用”<br>优点：</p>
<ul>
<li>降低系统的耦合度，将 “行为请求者” 和 ”行为实现者“ 解耦</li>
<li>扩展性强。增加或删除命令非常方便，并且不会影响其他类</li>
<li>封装 “方法调用”，方便实现 Undo 和 Redo 操作</li>
<li>灵活性强，可以实现宏命令<br>缺点：</li>
<li>会产生大量命令类。增加了系统的复杂性</li>
</ul>
<h2 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式 Interpreter"></a>解释器模式 Interpreter</h2><p>部分：<br>1.抽象表达式（Abstract Expression）：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()<br>2.终结符表达式（Terminal Expression）：是抽象表达式的子类，用来实现文法中与终结符相关的操作，不可拆分的最小单元<br>3.非终结符表达式（Nonterminal Expression）：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，可被拆分的表达式<br>4.环境（Context）：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据<br>5.客户端（Client）：将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法</p>
<h2 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 Iterator"></a>迭代器模式 Iterator</h2><p>提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节</p>
<h2 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式 Mediator"></a>中介者模式 Mediator</h2><p>定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互<br>当类与类之间的关系呈现网状时，引入一个中介者，可以使类与类之间的关系变成星形。将每个类与多个类的耦合关系简化为每个类与中介者的耦合关系，将多对多关系简化成多对一、一对多关系的设计模式<br>缺点：中介类需要处理所有类之间的协调工作，这可能会使中介者演变成一个超级类</p>
<h2 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式 Memento"></a>备忘录模式 Memento</h2><p>在不破坏封装的条件下，通过备忘录对象存储另外一个对象内部状态的快照，在将来合适的时候把这个对象还原到存储起来的状态<br>优点：</p>
<ul>
<li>提供一种可恢复状态的机制，使用户能够比较方便的回到某个历史的状态</li>
<li>实现了信息的封装，用户不需要关心状态的保存细节<br>缺点：</li>
<li>消耗资源，如果类的成员变量过多，会占用比较大的资源，而且每一次保存都会消耗一定的内存</li>
</ul>
<h2 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式 Observer"></a>观察者模式 Observer</h2><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新<br>Observer, Observable, subscribe &#x2F; register, update</p>
<h2 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h2><p>关于多态的设计模式，如果一个对象有多种状态，并且每种状态下的行为不同，可以为每种状态创建一个状态对象，使用状态对象，使得状态控制更加灵活，扩展性也更好<br>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类<br>优点：将与特定状态相关的行为封装到一个状态对象中，使用多态代替 if-else 或者 switch-case 状态判断<br>缺点：导致类增加，这也是使用多态不可避免的缺点</p>
<h2 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h2><p>定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化<br>优点：扩展性和灵活性。当有新的策略时，只需要增加一个策略类；要修改某个策略时，只需要更改具体的策略类，其他地方的代码都无需做任何调整<br>缺点：调用者需要了解策略类，增加了类与类之间的耦合 &#x3D;&gt; 可以通过简单工厂模式与策略模式的结合，将不同的策略对象封装到工厂类中，用户只需要传递不同的策略类型，然后从工厂中拿到对应的策略对象即可</p>
<h2 id="模板方法模式-Template-method"><a href="#模板方法模式-Template-method" class="headerlink" title="模板方法模式 Template method"></a>模板方法模式 Template method</h2><p>关于继承的设计模式，被继承的父类是模板，它的某些步骤是稳定的，某些步骤被延迟到子类中实现<br>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤<br>可以用方法的作用域控制权限：final - 不希望子类覆写；abstract - 子类必须覆写；protected 或 public - 没有特殊要求</p>
<h2 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式 Visitor"></a>访问者模式 Visitor</h2><p>核心思想：将数据的结构和对数据的操作分离<br>访问者模式（Visitor Pattern）表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作<br>方法的接收者和方法的参数统称为方法的宗量。 根据分派基于多少个宗量，可以将分派分为单分派和多分派。单分派是指根据一个宗量就可以知道应该调用哪个方法，多分派是指需要根据多个宗量才能确定调用目标</p>
<h2 id="小结-Summary"><a href="#小结-Summary" class="headerlink" title="小结 Summary"></a>小结 Summary</h2><ul>
<li>责任链模式：处理职责相同，程度不同的对象，使其在一条链上传递</li>
<li>命令模式：封装“方法调用”，将行为请求者和行为实现者解耦</li>
<li>解释器模式：定义自己的语法规则</li>
<li>迭代器模式：定义 next() 方法和 hasNext() 方法，让外部类使用这两个方法来遍历列表，以达到隐藏列表内部细节的目的</li>
<li>中介者模式：通过引入中介者，将网状耦合结构变成星型结构</li>
<li>备忘录模式：存储对象的状态，以便恢复</li>
<li>观察者模式：处理一对多的依赖关系，被观察的对象改变时，多个观察者都能收到通知</li>
<li>状态模式：关于多态的设计模式，每个状态类处理对象的一种状态</li>
<li>策略模式：殊途同归，用多种方法做同一件事</li>
<li>模板方法模式：关于继承的设计模式，父类是子类的模板</li>
<li>访问者模式：将数据的结构和对数据的操作分离</li>
</ul>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul>
<li><a href="https://leetcode.cn/leetbook/read/design-patterns/9ew9uc/">LeetBook 深入浅出设计模式</a></li>
<li><a href="https://www.baeldung.com/creational-design-patterns">Creational Design Pattern by Baeldung</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Sytem design</tag>
      </tags>
  </entry>
  <entry>
    <title>Heap 堆（优先队列）</title>
    <url>/tech/heap/</url>
    <content><![CDATA[<p>A heap:</p>
<ul>
<li>Stores elements, and can find the smallest (min-heap) or largest (max-heap) element stored in O(1).</li>
<li>Can add elements and remove the smallest (min-heap) or largest (max-heap) element in O(log(n)).</li>
<li>Can perform insertions and removals while always maintaining the first property.</li>
</ul>
<h1 id="PriorityQueue-in-Java"><a href="#PriorityQueue-in-Java" class="headerlink" title="PriorityQueue in Java"></a>PriorityQueue in Java</h1><p>An unbounded priority queue based on a priority heap. The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used.<br>The head of this queue is the least element with respect to the specified ordering</p>
<h2 id="Opeartions"><a href="#Opeartions" class="headerlink" title="Opeartions"></a>Opeartions</h2><ul>
<li>void offer()</li>
<li>Object poll()</li>
<li>int size()</li>
<li>boolean isEmpty()</li>
</ul>
<h1 id="TreeSet-in-Java"><a href="#TreeSet-in-Java" class="headerlink" title="TreeSet in Java"></a>TreeSet in Java</h1><p>A NavigableSet implementation based on a TreeMap. The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used.<br>This implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains).<br>Note that the ordering maintained by a set (whether or not an explicit comparator is provided) must be consistent with equals if it is to correctly implement the Set interface.</p>
<h2 id="Opeartions-1"><a href="#Opeartions-1" class="headerlink" title="Opeartions"></a>Opeartions</h2><ul>
<li>void add()</li>
<li>E lower(E e)</li>
<li>E floor(E e)</li>
<li>E ceiling(E e)</li>
<li>E higher(E e)</li>
</ul>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><ol>
<li>直接，当作排序数组</li>
<li>Dijkstra，求单源最短路径</li>
<li>一边压入，比较另一边</li>
</ol>
<h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><ul>
<li><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array</a></li>
<li><a href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a></li>
<li><a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></li>
<li><a href="https://leetcode.com/problems/avoid-flood-in-the-city/submissions/">1488. Avoid Flood in The City</a>（treeset）</li>
<li><a href="https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/">1337. The K Weakest Rows in a Matrix</a>（Easy, inituitive，但是用二分查找更快）</li>
<li><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/">703. Kth Largest Element in a Stream</a>（Easy, 不能更简单粗暴的heap）</li>
<li><a href="https://leetcode.com/problems/relative-ranks/">506. Relative Ranks</a>（Easy, 任意排序）</li>
<li><a href="https://leetcode.com/problems/last-stone-weight/">1046. Last Stone Weight</a>（Easy, heap直接上）</li>
<li><a href="https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/">2099. Find Subsequence of Length K With the Largest Sum</a>（Easy, 有点意思，理解了，好像又不太理解）</li>
<li><a href="https://leetcode.com/problems/sort-characters-by-frequency/">451. Sort Characters By Frequency</a></li>
<li><a href="https://leetcode.com/problems/reorganize-string/">767. Reorganize String</a>（这题没做出来，着实伤心了！！）</li>
<li><a href="https://leetcode.com/problems/network-delay-time/">743. Network Delay Time</a></li>
<li><a href="https://leetcode.com/problems/ugly-number-ii/">264. Ugly Number II</a>（做到这里，还是没有总结出技巧，要继续努力QwQ）</li>
<li><a href="https://leetcode.com/problems/super-ugly-number/">313. Super Ugly Number</a>（上一题的升级版）</li>
<li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. Kth Smallest Element in a Sorted Matrix</a>（与前面的同一类型）</li>
<li><a href="https://leetcode.com/problems/car-pooling/">1094. Car Pooling</a>（和下面235很像）</li>
<li><a href="https://leetcode.com/problems/top-k-frequent-words/">692. Top K Frequent Words</a>（Easy，直接）</li>
<li><a href="https://leetcode.com/problems/maximum-average-pass-ratio/">1792. Maximum Average Pass Ratio</a>（基础操作）</li>
<li><a href="https://leetcode.com/problems/design-twitter/">355. Design Twitter</a>（简单应用题）</li>
<li><a href="https://leetcode.com/problems/remove-stones-to-minimize-the-total/">1962. Remove Stones to Minimize the Total</a>（算是常规操作）</li>
<li><a href="https://leetcode.com/problems/longest-happy-string/">1405. Longest Happy String</a>（贪心算法）</li>
<li><a href="https://leetcode.com/problems/path-with-maximum-probability/">1514. Path with Maximum Probability</a>（Dijkstra）</li>
<li><a href="https://leetcode.com/problems/process-tasks-using-servers/">1882. Process Tasks Using Servers</a></li>
<li><a href="https://leetcode.com/problems/number-of-orders-in-the-backlog/">1801. Number of Orders in the Backlog</a></li>
<li><a href="https://leetcode.com/problems/the-maze-ii">505. The Maze II</a>（Dijkstra 练到吐）</li>
<li><a href="https://leetcode.com/problems/single-threaded-cpu/">1834. Single-Threaded CPU</a></li>
</ul>
<h2 id="三思"><a href="#三思" class="headerlink" title="三思"></a>三思</h2><ul>
<li><a href="https://leetcode.com/problems/the-skyline-problem/">218. The Skyline Problem</a></li>
<li><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/">787. Cheapest Flights Within K Stops</a>（<a href="../graph/">Graph</a>里的同题，再战，依旧铩羽而归，惭愧惭愧 QwQ，这题可以1. BellBellman-Ford: Map + queue；2. Dijkstra: array + priority queue；升级版<a href="https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/">1928. Minimum Cost to Reach Destination in Time</a>，我还是不会QwQ）</li>
<li><a href="https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/">1353. Maximum Number of Events That Can Be Attended</a>（还需修炼！pq的经典用法）</li>
<li><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/">373. Find K Pairs with Smallest Sums</a>（这题为啥没做出来？？？？反省！！！！！）</li>
<li><a href="https://leetcode.com/problems/path-with-minimum-effort/">1631. Path With Minimum Effort</a>（Dijikstra）</li>
<li><a href="https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</a></li>
<li><a href="https://leetcode.com/problems/jump-game-vi/">1696. Jump Game VI</a>（很好玩的跳跃游戏，总是能把愚蠢的我打回原型🐟）</li>
<li><a href="https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/">1786. Number of Restricted Paths From First to Last Node</a>（需要每天复习一遍的Dijkstra）</li>
<li><a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median from Data Stream</a>（经典的两队配合）</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://leetcode.com/problems/task-scheduler/">621. Task Scheduler</a>（是很tricky的一题，知道怎么做了，但不知道为啥和怎么想出来的）</li>
<li><a href="https://leetcode.com/problems/meeting-rooms-ii">253. Meeting Rooms II</a>（被shuxian剧透了，生气）</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://en.wikipedia.org/wiki/Heap_%28data_structure%29#Implementation">Heap Wikipedia</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>系列特辑</title>
    <url>/tech/interesting-series/</url>
    <content><![CDATA[<h1 id="Sliding-Window-using-Deque"><a href="#Sliding-Window-using-Deque" class="headerlink" title="Sliding Window using Deque"></a>Sliding Window using Deque</h1><ul>
<li><a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></li>
<li><a href="https://leetcode.com/problems/constrained-subsequence-sum/">1425. Constrained Subsequence Sum</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>【Leetcode】456. 132 Pattern</title>
    <url>/tech/leetcode-132-pattern/</url>
    <content><![CDATA[<h1 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h1><p><a href="https://leetcode.com/problems/132-pattern/">456. 132 Pattern</a></p>
<h1 id="常规开篇"><a href="#常规开篇" class="headerlink" title="常规开篇"></a>常规开篇</h1><p>就是有一些题，无论做多少次，拿到还是无从下手；就是有一些题，明明是中等level，答案也就短短十几行，可就是可以难倒一群人。这道132 pattern对我来说就是这样的。</p>
<h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><p>直接三个循环考虑所有的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find132pattern</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123; <span class="hljs-comment">// 1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">1</span>; j++) &#123; <span class="hljs-comment">// 3 </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; nums.length; k++) &#123; <span class="hljs-comment">// 2</span><br>                <span class="hljs-keyword">if</span> (nums[k] &gt; nums[i] &amp;&amp; nums[j] &gt; nums[k])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>简单粗暴，时间复杂度O(n^3)，空间复杂度O(1)</p>
<h1 id="暴力加一点贪心"><a href="#暴力加一点贪心" class="headerlink" title="暴力加一点贪心"></a>暴力加一点贪心</h1><p>对于1，我们永远想要最小的数，所以，我们可以利用这一点，简化上一个暴力解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find132pattern</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, min = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 3</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123; <span class="hljs-comment">// 2</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j] &amp;&amp; nums[j] &gt; min) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        min = Math.min(min, nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度O(n^2)，空间复杂度O(1)</p>
<h1 id="单调栈基础解法"><a href="#单调栈基础解法" class="headerlink" title="单调栈基础解法"></a>单调栈基础解法</h1><p>对于1，我们永远想要最小的数，所以，我们可以用一个循环得到在每一个index时，我们可以得到的最小数。<br>对于2，我们可以从后往前遍历数组，然后用一个单调栈存储数值<br>在遍历时，我们同时可以利用最小数和单调栈，找到符合要求的（1，2）pair。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find132pattern</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <br>    <span class="hljs-type">int</span>[] min = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <span class="hljs-comment">// 1的最优情况</span><br>    min[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        min[i] = Math.min(nums[i], min[i-<span class="hljs-number">1</span>]);<br>    &#125;<br>    <br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 存储所有可能的2</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 从后往前遍历</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt;= min[i]) &#123;<br>            stack.pop(); <span class="hljs-comment">// pop所有小于当前1的数字，因为2需要大于1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums[i]) &#123;<br>            <span class="hljs-comment">// 如果栈内还有元素，那个元素一定 &gt; min[i]，否则就在上一个循环被弹出去了</span><br>            <span class="hljs-comment">// 只要这个元素 &lt; nums[i]，就说明我们找到了一个合格的组合</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        stack.push(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
<h1 id="单调栈再加一点贪心"><a href="#单调栈再加一点贪心" class="headerlink" title="单调栈再加一点贪心"></a>单调栈再加一点贪心</h1><p>对于符合要求的132组合，我们除了像上面的解法一样希望1越小越好，我们还希望在有3的情况下2越大越好，所以，除了确定1、2找3之外，我们可以确定2、3找1。这样的话，我们可以之需要一遍循环，从后往前就好。用一个单调递减的栈保存遇到过的所有数字，作为可能的2，如果遇到更大的3，我们可以做栈弹出，找找有没有更大的2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find132pattern</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, two = Integer.MIN_VALUE; <span class="hljs-comment">// 2</span><br>    <br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 单调递减存储所有可能的3</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 从后往前遍历</span><br>        <span class="hljs-keyword">if</span> (nums[i] &lt; two) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 1: nums[i], 2: two, 3: 确定有比two大的值</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums[i]) &#123;<br>            <span class="hljs-comment">// 用3做nums[i]</span><br>            <span class="hljs-comment">// stack.peek()比two大</span><br>            two = stack.pop();<br>        &#125;<br>        stack.push(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
<h1 id="极简主义"><a href="#极简主义" class="headerlink" title="极简主义"></a>极简主义</h1><p>有没有办法再节省一点，能不能利用nums，减少stack的空间呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find132pattern</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, two = Integer.MIN_VALUE, threeIndex = n;<br>    <br>    <span class="hljs-comment">// 去掉单调栈，改用nums数组，单调递减存储所有可能的3</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 从后往前遍历</span><br>        <span class="hljs-keyword">if</span> (nums[i] &lt; two) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 1: nums[i], 2: two, 3: nums[threeIndex]</span><br>        <span class="hljs-keyword">while</span> (threeIndex &lt; n &amp;&amp; nums[threeIndex] &lt; nums[i]) &#123;<br>            <span class="hljs-comment">// 用3做nums[i]</span><br>            two = nums[threeIndex++];<br>        &#125;<br>        nums[--threeIndex] = nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><ul>
<li><a href="https://esther.fun/tech/monotonic-stack-and-monotonic-queue/">Monotonic Stack, Monotonic Queue 单调队列，单调栈</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构浅谈</title>
    <url>/tech/meet-data-stucture/</url>
    <content><![CDATA[<h2 id="结构的分类"><a href="#结构的分类" class="headerlink" title="结构的分类"></a>结构的分类</h2><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><ol>
<li>集合结构：每个元素平等，相互之间没有关系</li>
<li>线性结构：元素之间，一对一的关系</li>
<li>树形结构：一对多</li>
<li>图形结构：多对多</li>
</ol>
<h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><ol>
<li>顺序存储结构：地址连续的存储单元</li>
<li>链式存储结构</li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="五大特性"><a href="#五大特性" class="headerlink" title="五大特性"></a>五大特性</h4><p>输入、输出、有穷性、确定性和可行性</p>
<h4 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h4><ul>
<li>正确性：没有语法错误（基本）-&gt; 合法输入得到输出结构（核心）-&gt; 非法输入、异常捕捉（优秀）-&gt; 对特殊情况的处理（bonus）</li>
<li>可读性</li>
<li>健壮性</li>
<li>时间、空间效率高</li>
</ul>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(1) &lt; O(logN) 对数阶，二分法&lt; O(n) &lt; O(NlogN) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) 指数阶&lt; O(n!) &lt; O(n^n)</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h4 id="定义和特性"><a href="#定义和特性" class="headerlink" title="定义和特性"></a>定义和特性</h4><p>0个或多个数据元素的<em>有限</em>序列<br>第一个元素无前驱，最后一个元素无后继，其余每个元素都有且仅有一个前驱和一个后继</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul>
<li>创建和初始化</li>
<li>检查是否为空</li>
<li>清空</li>
<li>根据索引取元素</li>
<li>查找元素</li>
<li>插入元素</li>
<li>删除制定索引的元素</li>
<li>返回当前长度</li>
</ul>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ol>
<li>顺序存储<br>用一段地址连续的存储单元一次存储线性表的数据元素<br>优点：</li>
</ol>
<ul>
<li>存取元素方便</li>
<li>无须空间存储元素间的关系<br>缺点：</li>
<li>插入和删除操作需要移动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间容量</li>
<li>造成存储空间的“碎片”</li>
</ul>
<ol start="2">
<li>链式存储<br>优点：</li>
</ol>
<ul>
<li>插入、删除方便</li>
<li>个数灵活不受限<br>缺点：</li>
<li>存取不易</li>
</ul>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>用一组任意的存储单元存放线性表的元素</p>
<h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>用数组描述链表，又称游标实现法<br>优点：插入删除快<br>缺点：内存分配问题没有解决，存取不易</p>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>终端节点的指针端由空指针改为头节点，使整个单链表形成一个头尾相接的环。</p>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>在每个结点再设置一个指向其前驱节点的指针域</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h4 id="定义和特性-1"><a href="#定义和特性-1" class="headerlink" title="定义和特性"></a>定义和特性</h4><p>仅在表尾进行插入和删除操作的线性表<br>**先进后出(last in first out, LIFO)**，栈顶(top, 操作端，表尾)，栈低(bottom，表头，固定的)<br>插入，进栈<br>删除，出栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">数字<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>依此进栈，会有几种出栈次序？<br><span class="hljs-number">1.</span> <span class="hljs-number">123</span>进，<span class="hljs-number">321</span>出 -&gt; <span class="hljs-number">321</span><br><span class="hljs-number">2.</span> <span class="hljs-number">12</span>进，<span class="hljs-number">21</span>出，<span class="hljs-number">3</span>进，<span class="hljs-number">3</span>出 -&gt; <span class="hljs-number">213</span><br><span class="hljs-number">3.</span> <span class="hljs-number">12</span>进，<span class="hljs-number">2</span>出，<span class="hljs-number">3</span>进，<span class="hljs-number">31</span>出 -&gt; <span class="hljs-number">231</span><br><span class="hljs-number">4.</span> <span class="hljs-number">1</span>进，<span class="hljs-number">1</span>出，<span class="hljs-number">23</span>进，<span class="hljs-number">32</span>出 -&gt; <span class="hljs-number">132</span><br><span class="hljs-number">5.</span> <span class="hljs-number">1</span>进，<span class="hljs-number">1</span>出，<span class="hljs-number">2</span>进，<span class="hljs-number">2</span>出，<span class="hljs-number">3</span>进，<span class="hljs-number">3</span>出 -&gt; <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>顺序存储结构，用数组实现</li>
<li>两栈共享空间</li>
<li>链式存储</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol>
<li>实现递归</li>
<li>四则运算表达式求值<br> 后缀（逆波兰）表示法：一种不需要括号的算式表达法<ol>
<li>将中缀表达式转为后缀表达式<br> 从左到右遍历表达式中缀表达式中的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号，则栈顶元素依次出栈并输出，将当前符号进栈，直到最终输出后缀表达式为止</li>
<li>计算值<br> 从左到右遍历表达式后缀表达式中的每个数字和符号，遇到数字就进栈，遇到符号将栈顶两个数字出栈进行运算，结果进栈，一直到获得最终结果 <figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-number">9</span>+(<span class="hljs-number">3</span>-<span class="hljs-number">1</span>)*<span class="hljs-number">3</span>+<span class="hljs-number">10</span>/<span class="hljs-number">2</span><br><span class="hljs-number">1.</span> <span class="hljs-number">9</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> - <span class="hljs-number">3</span> * + <span class="hljs-number">10</span> <span class="hljs-number">2</span> / +<br><span class="hljs-number">2.</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h4 id="定义和特性-2"><a href="#定义和特性-2" class="headerlink" title="定义和特性"></a>定义和特性</h4><p>只允许一端进行插入操作、另一端进行删除操作的线性表<br>**先进先出(first in first out,FIFO)**，队头（允许删除），队尾（允许插入）<br>插入，入队<br>删除，出队</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><ol>
<li>顺序存储，采用循环队列，用两个指针front和rear实现</li>
<li>链式存储</li>
</ol>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>KMP模式匹配算法了解一下？</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>n (n&gt;&#x3D;0) 个结点的有限集<br>n &#x3D; 0，空树<br>根只有一个<br>子树互不交叉</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>度(Degree)：结点拥有的子树数<br>度 &#x3D; 0，叶结点(Leaf) &#x2F; 终端结点<br>度 !&#x3D; 0，分支结点 &#x3D; 根结点 + 内部结点<br>树的度 &#x3D; 树内各结点的度的最大值</p>
<h4 id="结点之间的关系"><a href="#结点之间的关系" class="headerlink" title="结点之间的关系"></a>结点之间的关系</h4><p>父(Parent)、子(Child)、兄弟(Sibling)</p>
<h4 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h4><ul>
<li>层次 (Level)</li>
<li>深度 (Depth) &#x2F; 高度</li>
<li>次序 &#x3D; 有序树 + 无序树</li>
</ul>
<h4 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h4><ol>
<li>双亲表示法<ul>
<li>每个结点存储当前值和父亲的位置</li>
<li>查找父亲很方便，但是查找子很麻烦</li>
</ul>
</li>
<li>多重链表表示法<ul>
<li>每个结点有多个指针域，每个指针指向一个子树的根结点</li>
<li>方案一：指针域的个数 &#x3D; 树的度</li>
<li>方案二：当前结点指针域的个数 &#x3D; 当前结点的度</li>
</ul>
</li>
<li>孩子表示法<ul>
<li>把每个结点的子结点排列起来，以单链表作存储结构</li>
</ul>
</li>
<li>兄弟姐妹表示法<ul>
<li>每个结点存储第一个孩子和它的右兄弟</li>
<li>找子结点方便</li>
<li>优化：加parent指针域来查找父亲</li>
</ul>
</li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>每个结点最多两棵子树</li>
<li>子树是有序的，左右不同</li>
</ul>
<h4 id="基本形态"><a href="#基本形态" class="headerlink" title="基本形态"></a>基本形态</h4><ul>
<li>空树</li>
<li>只有一个根结点</li>
<li>根结点只有左子树</li>
<li>根结点只有右子树</li>
<li>根结点既有左子树又有右子树</li>
</ul>
<h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><ul>
<li>斜树：所有结点都只有左&#x2F;右子树</li>
<li>满二叉树：所有的分支结点都存在左子树和右子树，且所有的叶子结点都在同一层上。（叶子结点只出现在最下一层；非叶子结点的度 &#x3D; 2；同样深度的二叉树，满二叉树的结点个数最多，叶子树最多）</li>
<li>完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同。（叶子结点只出现在最下<strong>两</strong>层；最下层的叶子一定集中在左部连续位置；倒数二层，若有叶子结点，一定在右部连续位置；(结点度 &#x3D;&#x3D; 1) &#x3D;&gt; 该结点只有左子树；同样结点的二叉树，完全二叉树的深度最小）</li>
</ul>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>二叉树的第i层，至多有2^(i-1)个结点</li>
<li>深度为k的二叉树至多有2^k-1个结点</li>
<li>对任一二叉树，given其终端结点数n0，度为2的结点数n2 &#x3D;&gt; n0 &#x3D; n2 + 1<br>—————- 完全二叉树 —————-</li>
<li>具有n个结点的完全二叉树的深度 &#x3D; floor(lnN) + 1</li>
<li>如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i有：<ul>
<li>i &#x3D;&#x3D; 1 &#x3D;&gt; i &#x3D;&#x3D; root || i &gt; 1 &#x3D;&gt; parent of i &#x3D;&#x3D; floor(i&#x2F;2)</li>
<li>2i &gt; n &#x3D;&gt; i &#x3D;&#x3D; leaf || left child of i &#x3D;&#x3D; 2i</li>
<li>2i + 1 &gt; n &#x3D;&gt; i has no right child || right child of i &#x3D;&#x3D; 2i + 1</li>
</ul>
</li>
</ul>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><ol>
<li>顺序存储</li>
<li>二叉链表</li>
</ol>
<h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><ol>
<li>前序遍历：根 -&gt; 左 -&gt; 右</li>
<li>中序遍历：左 -&gt; 根 -&gt; 右</li>
<li>后序遍历：左 -&gt; 右 -&gt; 根</li>
<li>层序遍历</li>
</ol>
<p><em>已知前序遍历序列和中序遍历序列 &#x3D;&#x3D;&#x3D;&gt; 唯一确定一棵二叉树</em><br><em>已知后序遍历序列和中序遍历序列 &#x3D;&#x3D;&#x3D;&gt; 唯一确定一棵二叉树</em><br><em>已知前序遍历序列和后序遍历序列 &#x3D;X&#x3D;&gt; 唯一确定一棵二叉树</em></p>
<h4 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为 G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合</p>
<p>图中数据元素称为顶点（Vertex）</p>
<p>顶点集合V有穷非空</p>
<p>顶点之间的逻辑关系用边来表示，边集可以为空</p>
<p><strong>无向边</strong>：若顶点vi, vj之间的边没有方向，则称这条边为无向边（Edge），用无序偶对<code> (vi, vj)</code> 来表示</p>
<p><strong>无向图</strong>：图中任意两个顶点之间的边都是无向边</p>
<p><strong>有向边</strong>：若从顶点vi到 vj的边有方向，则称这条边为有向边，也称为弧（Arc），用<code>&lt;A,D&gt;</code>来表示，A是弧尾，D是弧头，弧从A指向D</p>
<p><strong>有向图</strong>：图中任意两个顶点之间的边都是有向边</p>
<p><strong>简单图</strong>：图中不存在顶点到其自身的边，且同一条边不重复出现</p>
<p><strong>无向完全图</strong>：任意两个顶点之间都存在边的无向图，含有n个顶点的无向完全图有n*(n-1)&#x2F;2条边</p>
<p><strong>有向完全图</strong>：任意两个顶点之间都存在方向互为相反的两条弧的有向图，含有n个顶点的有向完全图有n*(n-1)条弧</p>
<p><strong>权</strong>：与图的边或弧相关的数</p>
<p><strong>网</strong>：带权的图</p>
<p><strong>子图</strong>：假设有两个图G&#x3D;(V,{E})和G’&#x3D;(V’,{E’})，如果V’⊆V，E’⊆E，则称G’为G的子图</p>
<p><strong>图的顶点与边间关系</strong></p>
<p>对于无向图G&#x3D;(V,{E})，如果边(v,v’)∊E，则称顶点v和v’互为**邻接点(Adjacent)<strong>，即v和v’相邻接。边(v,v’)依附(incident)于顶点v和v’，或者说(v,v’)与顶点v和v’相关联。顶点v的</strong>度(Degree)**是和v相关联的边的数目，记为TD(v)。图的边数其实就是各顶点度数和的一半，e&#x3D;∑TD(v)&#x2F;2。</p>
<p>对于有向图G&#x3D;(V,{E})，如果弧&lt;v,v’&gt;∊E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。弧&lt;v,v’&gt;和顶点v，v’相关联。以顶点v为头的弧的数目称为v的**入度(InDegree)<strong>，记为ID(v)；以v为尾的弧的数目称为v的</strong>出度(OutDegree)**，记为OD(v)；顶点v的度为TD(v)&#x3D;ID(v)+OD(v)。有向图的弧数等于各顶点的出度，也等于各顶点的入度，e&#x3D;∑ID(v)&#x3D;∑OD(v)。<br>无向图G·(V.{E》)中从顶点v到顶点V的路径(Path)是一个顶点序列。</p>
<p>路径的长度是路径上的边或弧的数目。</p>
<p><strong>环</strong>&#x2F;<strong>回路</strong>：第一个顶点到最后一个顶点相同的路径。</p>
<p><strong>简单路径</strong>：序列中顶点不重复出现</p>
<p><strong>简单环</strong>&#x2F;<strong>简单回路</strong>：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路。</p>
<p><strong>连通</strong>：在无向图种，两个顶点之间有路径，则称它们是连通的。如果任意两个顶点都连通，则该图为连通图。</p>
<p><strong>连通分量</strong>：无向图中的<em>极大</em>_<em>连通</em>_<em>子图</em>。</p>
<p><strong>强连通图</strong>：有向图中，两两顶点之间存在路径。</p>
<p><strong>强连通分量</strong>：有向图中的<em>极大</em>_<em>强连通</em>_<em>子图</em>。</p>
<p><strong>连通图的生成树</strong>：一个极小的连通子图，它还有图中的全部n个顶点，但只有足以构成一棵树的n-1条边。</p>
<p><strong>有向树</strong>：一个有向图，恰有一个顶点的入度为0，其余顶点的入度均为1。</p>
<p><strong>有向图的生成森林</strong>：由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p>
<h4 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h4><ol>
<li>矩阵 2[n][n]</li>
<li>二维数组 2[n][0-n]<br>…</li>
</ol>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h4 id="查找的方法"><a href="#查找的方法" class="headerlink" title="查找的方法"></a>查找的方法</h4><ol>
<li>折半查找, mid &#x3D; (low + high) &#x2F; 2</li>
<li>插值查找, mid &#x3D; low + (high - low) * (key - a[low])&#x2F; (a[high] - a [low])</li>
<li>斐波那契查找, mid &#x3D; low + F[k-1] - 1</li>
</ol>
<h4 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h4><ol>
<li>稠密索引，一一对应</li>
<li>分块索引，块内无序，块间有序</li>
<li>倒排索引，次关键码为key，序号为值</li>
</ol>
<h4 id="二叉排序树-二叉查找树"><a href="#二叉排序树-二叉查找树" class="headerlink" title="二叉排序树 &#x2F; 二叉查找树"></a>二叉排序树 &#x2F; 二叉查找树</h4><p>若左子树不空，则左子树上所有结点的值均小于它的根结构的值；<br>若右子树不空，则右子树上所有结点的值均大于它的根结构的值；<br>左、右子树都为二叉排序树。<br><strong>平衡二叉树</strong>：每一个节点的左子树和右子树的高度差至多&#x3D;1</p>
<h4 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h4><p>每一个结点的孩子数 &gt; 2，每一个结点可以存储多个元素</p>
<ol>
<li>2-3树：每一个结点都具有两个孩子（2结点）或三个孩子（3结点），2结点包含一个元素和两个孩子，左子树所有元素小于此元素，右子树所有元素大于此元素，3结点包含两个元素和三个孩子，左子树所有元素小于较小元素，右子树所有元素大于较大元素，中间树包含介于两者之间的元素</li>
<li>2-3-4树：有2结点，3结点和4结点</li>
</ol>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B树是一种平衡的多路查找树，结点最大的孩子数目称为B树的阶（Order）</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Fundation</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Meta 高频面试题</title>
    <url>/tech/meta-coding-questions/</url>
    <content><![CDATA[<h1 id="Top-100-in-2022-Feb"><a href="#Top-100-in-2022-Feb" class="headerlink" title="Top 100 in 2022 Feb"></a>Top 100 in 2022 Feb</h1><ul>
<li><p><a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/">1249. Minimum Remove to Make Valid Parentheses</a>  Stack or Two-way scan</p>
</li>
<li><p><a href="https://leetcode.com/problems/valid-palindrome-ii/">680. Valid Palindrome II</a> Recursive follow up是可以remove at most k</p>
</li>
<li><p><a href="https://leetcode.com/problems/buildings-with-an-ocean-view/">1762. 能看到海景的建筑物</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/">314. 二叉树的垂直遍历</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/range-sum-of-bst/">938. Range Sum of BST</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/dot-product-of-two-sparse-vectors/">1570. 两个稀疏向量的点积</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/">1650. 二叉树的最近公共祖先 III</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/subarray-sum-equals-k/">560. Subarray Sum Equals K</a> hashMap, initial data</p>
</li>
<li><p><a href="https://leetcode.com/problems/random-pick-with-weight/">528. Random Pick with Weight</a> 又是一道pre-sum题, 数组为空，所有数字都是0</p>
</li>
<li><p><a href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/">921. Minimum Add to Make Parentheses Valid</a> One pass</p>
</li>
<li><p><a href="https://leetcode.com/problems/k-closest-points-to-origin/">973. K Closest Points to Origin</a> PriorityQueue or QuickSelect</p>
</li>
<li><p><a href="https://leetcode.com/problems/basic-calculator-ii/">227. Basic Calculator II</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a> 递归</p>
</li>
<li><p><a href="https://leetcode.com/problems/nested-list-weight-sum/">339. 嵌套列表权重和</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/simplify-path/">71. Simplify Path</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/valid-word-abbreviation/">408. 有效单词缩写</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/">426. 将二叉搜索树转化为排序的双向链表</a> 中序遍历 or <a href="https://zhuanlan.zhihu.com/p/101321696">morris遍历</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array</a> QuickSelect</p>
</li>
<li><p><a href="https://leetcode.com/problems/powx-n/">50. Pow(x, n)</a> 递归 Warning StackOverflow</p>
</li>
<li><p><a href="https://leetcode.com/problems/making-a-large-island/">827. Making A Large Island</a> Union Find Set with details</p>
</li>
<li><p><a href="https://leetcode.com/problems/next-permutation/">31. Next Permutation</a> 三步走：1. locate; 2. switch; 3. reorder</p>
</li>
<li><p><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/">987. Vertical Order Traversal of a Binary Tree</a> Sort</p>
</li>
<li><p><a href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a> BFS</p>
</li>
<li><p><a href="https://leetcode.com/problems/maximum-swap/">670. Maximum Swap</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a> QuickSelect</p>
</li>
<li><p><a href="https://leetcode.com/problems/custom-sort-string/">791. Custom Sort String</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/valid-number/">65. Valid Number</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/exclusive-time-of-functions/">636. Exclusive Time of Functions</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/">317. 离建筑物最近的距离</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/accounts-merge/">721. Accounts Merge</a> 组编号，常规UFS，三次遍历</p>
</li>
<li><p><a href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a> 全局变量 or int[]</p>
</li>
<li><p><a href="https://leetcode.com/problems/continuous-subarray-sum/">523. Continuous Subarray Sum</a> Map，要注意初始化和变体</p>
</li>
<li><p><a href="https://leetcode.com/problems/diagonal-traverse/">498. Diagonal Traverse</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/remove-invalid-parentheses/">301. Remove Invalid Parentheses</a> dfs, backtracking</p>
</li>
<li><p><a href="https://leetcode.com/problems/group-shifted-strings/">249. 移位字符串分组</a> hash的方法：(s.charAt(i) - s.charAt(i - 1) + 26) % 26</p>
</li>
<li><p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/">138. Copy List with Random Pointer</a> 循环 or 迭代</p>
</li>
<li><p><a href="https://leetcode.com/problems/find-peak-element/">162. Find Peak Element</a> linear scan &#x2F; binary search</p>
</li>
<li><p><a href="https://leetcode.com/problems/merge-intervals/">56. Merge Intervals</a> 1. sort; 2. listing; 3. to array</p>
</li>
<li><p><a href="https://leetcode.com/problems/add-strings/">415. Add Strings</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/expression-add-operators/">282. Expression Add Operators</a> backtrack 高级回溯 要用long 避免溢出</p>
</li>
<li><p><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">1091. Shortest Path in Binary Matrix</a> DFS</p>
</li>
<li><p><a href="https://leetcode.com/problems/binary-search-tree-iterator/">173. Binary Search Tree Iterator</a> Stack</p>
</li>
<li><p><a href="https://leetcode.com/problems/word-break-ii/">140. Word Break II</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/">1047. Remove All Adjacent Duplicates In String</a> 双指针</p>
</li>
<li><p><a href="https://leetcode.com/problems/valid-palindrome/">125. Valid Palindrome</a> Character.isLetterOrDigit, toLowerCase</p>
</li>
<li><p><a href="https://leetcode.com/problems/merge-sorted-array/submissions/">88. Merge Sorted Array</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/cutting-ribbons/">1891. Cutting Ribbons</a> 二分法</p>
</li>
<li><p><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/">1011. Capacity To Ship Packages Within D Days</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/lru-cache/">146. LRU Cache</a> 细节</p>
</li>
<li><p><a href="https://leetcode.com/problems/moving-average-from-data-stream/">346. 数据流中的移动平均值</a> 1. Queue; 2. 环形列表存储</p>
</li>
<li><p><a href="https://leetcode.com/problems/verifying-an-alien-dictionary/">953. Verifying an Alien Dictionary</a> Special sort or compare bwt i-1 and i</p>
</li>
<li><p><a href="https://leetcode.com/problems/toeplitz-matrix/">766. Toeplitz Matrix</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water</a> 双指针 or 两次遍历</p>
</li>
<li><p><a href="https://leetcode.com/problems/clone-graph/">133. Clone Graph</a> DFS</p>
</li>
<li><p><a href="https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/">708. 循环有序列表的插入</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/palindrome-permutation/">266. Palindrome Permutation</a> set &#x2F; count</p>
</li>
<li><p><a href="https://leetcode.com/problems/valid-palindrome-iii/">1216. 验证回文字符串 III</a> dp</p>
</li>
<li><p><a href="https://leetcode.com/problems/balance-a-binary-search-tree/">1382. Balance a Binary Search Tree</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a> PriorityQueue or Divide and Concur for (i &#x3D; 0; i &lt; n - interval; i +&#x3D; (2*interval)) interval *&#x3D; 2; 注意数组长度为0的情况</p>
</li>
<li><p><a href="https://leetcode.com/problems/walls-and-gates/">286. 墙与门</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">129. Sum Root to Leaf Numbers</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/">2060. Check if an Original String Exists Given Two Encoded Strings</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/kth-missing-positive-number/">1539. Kth Missing Positive Number</a> 两种方法：1. 遍历； 2. Binary Search</p>
</li>
<li><p><a href="https://leetcode.com/problems/alien-dictionary/">269. 火星词典</a> 拓扑排序 Topological Sort - 1. order; 2. queue; 3. toString</p>
</li>
<li><p><a href="https://leetcode.com/problems/max-consecutive-ones-iii/">1004. Max Consecutive Ones III</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/design-tic-tac-toe/">348. 设计井字棋</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/integer-to-english-words/">273. Integer to English Words</a> Recursive</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] LESS_THAN_20 = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-string">&quot;Three&quot;</span>, <span class="hljs-string">&quot;Four&quot;</span>, <span class="hljs-string">&quot;Five&quot;</span>, <span class="hljs-string">&quot;Six&quot;</span>, <span class="hljs-string">&quot;Seven&quot;</span>, <span class="hljs-string">&quot;Eight&quot;</span>, <span class="hljs-string">&quot;Nine&quot;</span>, <span class="hljs-string">&quot;Ten&quot;</span>, <span class="hljs-string">&quot;Eleven&quot;</span>, <span class="hljs-string">&quot;Twelve&quot;</span>, <span class="hljs-string">&quot;Thirteen&quot;</span>, <span class="hljs-string">&quot;Fourteen&quot;</span>, <span class="hljs-string">&quot;Fifteen&quot;</span>, <span class="hljs-string">&quot;Sixteen&quot;</span>, <span class="hljs-string">&quot;Seventeen&quot;</span>, <span class="hljs-string">&quot;Eighteen&quot;</span>, <span class="hljs-string">&quot;Nineteen&quot;</span>&#125;;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] TENS = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Ten&quot;</span>, <span class="hljs-string">&quot;Twenty&quot;</span>, <span class="hljs-string">&quot;Thirty&quot;</span>, <span class="hljs-string">&quot;Forty&quot;</span>, <span class="hljs-string">&quot;Fifty&quot;</span>, <span class="hljs-string">&quot;Sixty&quot;</span>, <span class="hljs-string">&quot;Seventy&quot;</span>, <span class="hljs-string">&quot;Eighty&quot;</span>, <span class="hljs-string">&quot;Ninety&quot;</span>&#125;;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] THOUSANDS = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Thousand&quot;</span>, <span class="hljs-string">&quot;Million&quot;</span>, <span class="hljs-string">&quot;Billion&quot;</span>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode.com/problems/add-bold-tag-in-string/">616. 给字符串添加加粗标签</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/construct-binary-tree-from-string/">536. 从字符串生成二叉树</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/leftmost-column-with-at-least-a-one/">1428. 至少有一个 1 的最左端列</a> 二分法</p>
</li>
<li><p><a href="https://leetcode.com/problems/random-pick-index/">398. Random Pick Index</a> Reservoir sampling</p>
</li>
<li><p><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/minimum-area-rectangle/">939. Minimum Area Rectangle</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/interval-list-intersections/">986. Interval List Intersections</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/number-of-valid-move-combinations-on-chessboard/">2056. Number of Valid Move Combinations On Chessboard</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/angle-between-hands-of-a-clock/">1344. Angle Between Hands of a Clock</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/">863. All Nodes Distance K in Binary Tree</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/find-k-closest-elements/">658. Find K Closest Elements</a> Binary Search</p>
</li>
<li><p><a href="https://leetcode.com/problems/product-of-two-run-length-encoded-arrays/">1868. 两个行程编码数组的积</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/meeting-rooms-ii/">253. 会议室 II</a> PriorityQueue or Two pointers 双指针要再练一下</p>
</li>
<li><p><a href="https://leetcode.com/problems/word-break/">139. Word Break</a> dp</p>
</li>
<li><p><a href="https://leetcode.com/problems/number-of-visible-people-in-a-queue/">1944. Number of Visible People in a Queue</a> 从左往右 &#x2F; 从右往左都可以</p>
</li>
<li><p><a href="https://leetcode.com/problems/closest-binary-search-tree-value/">270. 最接近的二叉搜索树值</a> 磕磕绊绊</p>
</li>
<li><p><a href="https://leetcode.com/problems/multiply-strings/">43. Multiply Strings</a> 小心0</p>
</li>
<li><p><a href="https://leetcode.com/problems/monotonic-array/">896. Monotonic Array</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/next-greater-element-iii/">556. Next Greater Element III</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/palindromic-substrings/">647. Palindromic Substrings</a> 中心扩展 O(n^2)</p>
</li>
<li><p><a href="https://leetcode.com/problems/friends-of-appropriate-ages/">825. Friends Of Appropriate Ages</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/3sum-closest/">16. 3Sum Closest</a> 去重复</p>
</li>
<li><p><a href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/">958. Check Completeness of a Binary Tree</a> DFS (complete tree: 2^k +1  ⇒ x &amp; (x + 1) &#x3D;&#x3D; 0) &#x2F; BFS</p>
</li>
<li><p><a href="https://leetcode.com/problems/daily-temperatures/">739. Daily Temperatures</a> 单调栈 &#x2F; array</p>
</li>
<li><p><a href="https://leetcode.com/problems/swim-in-rising-water/">778. Swim in Rising Water</a> PriorityQueue + DFS &#x2F; UnionFind &#x2F; Binary Search 复杂度都差不多</p>
</li>
<li><p><a href="https://leetcode.com/problems/subsets/">78. Subsets</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/process-restricted-friend-requests/">2076. Process Restricted Friend Requests</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/">325. 和等于 k 的最长子数组长度</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/diameter-of-n-ary-tree/">1522. N 叉树的直径</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/">1644. 二叉树的最近公共祖先 II</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a> 双指针要再练一下 特别小心字符串没有匹配的地方</p>
</li>
<li><p><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/">1209. Remove All Adjacent Duplicates in String II</a> 快慢指针</p>
</li>
</ul>
<h1 id="Top-Questions-in-LeetCode"><a href="#Top-Questions-in-LeetCode" class="headerlink" title="Top Questions in LeetCode"></a>Top Questions in LeetCode</h1><ul>
<li>括号系列<ul>
<li><a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/">1249. Minimum Remove to Make Valid Parentheses</a>  Stack or Two-way scan</li>
<li><a href="https://leetcode.com/problems/remove-invalid-parentheses/">301. Remove Invalid Parentheses</a> dfs, backtracking</li>
<li><a href="https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/">921. Minimum Add to Make Parentheses Valid</a> One pass</li>
<li><a href="https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/">1541. Minimum Insertions to Balance a Parentheses String</a></li>
<li><a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a> Stack</li>
<li><a href="https://leetcode.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a> dp</li>
<li><a href="https://leetcode.com/problems/generate-parentheses/">22. Generate Parentheses</a> dfs</li>
<li><a href="https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/">1003. Check If Word Is Valid After Substitutions</a> Stack</li>
<li><a href="https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/">1963. Minimum Number of Swaps to Make the String Balanced</a></li>
<li><a href="https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/">2116. Check if a Parentheses String Can Be Valid</a></li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/verifying-an-alien-dictionary/">953. Verifying an Alien Dictionary</a> Special sort or compare bwt i-1 and i</li>
<li>回文<ul>
<li><a href="https://leetcode.com/problems/valid-palindrome/">125. Valid Palindrome</a> Character.isLetterOrDigit, toLowerCase</li>
<li><a href="https://leetcode.com/problems/valid-palindrome-ii/">680. Valid Palindrome II</a> Recursive follow up是可以remove at most k</li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/k-closest-points-to-origin/">973. K Closest Points to Origin</a> PriorityQueue or QuickSelect</li>
<li><a href="https://leetcode.com/problems/integer-to-english-words/">273. Integer to English Words</a> Recursive</li>
<li>数学<ul>
<li>简单加法<ul>
<li><a href="https://leetcode.com/problems/add-two-numbers/">2. Add Two Numbers</a></li>
<li><a href="https://leetcode.com/problems/add-two-numbers-ii/">445. Add Two Numbers II</a></li>
<li><a href="https://leetcode.com/problems/add-binary/">67. Add Binary</a></li>
<li><a href="https://leetcode.com/problems/add-strings/">415. Add Strings</a></li>
<li><a href="https://leetcode.com/problems/plus-one/">66. Plus One</a></li>
<li><a href="https://leetcode.com/problems/add-to-array-form-of-integer/">989. Add to Array-Form of Integer</a></li>
<li><a href="https://leetcode.com/problems/add-two-polynomials-represented-as-linked-lists/">1634. 求两个多项式链表的和</a></li>
<li><a href="https://leetcode.com/problems/plus-one-linked-list/">369. 给单链表加一</a></li>
</ul>
</li>
<li>求和<ul>
<li>Map<ul>
<li><a href="https://leetcode.com/problems/3sum/">15. 3Sum</a></li>
<li><a href="https://leetcode.com/problems/subarray-sum-equals-k/">560. Subarray Sum Equals K</a> hashMap, initial data</li>
<li><a href="https://leetcode.com/problems/continuous-subarray-sum/">523. Continuous Subarray Sum</a> Map，要注意初始化和变体</li>
<li><a href="https://leetcode.com/problems/two-sum">1. Two Sum</a></li>
<li><a href="https://leetcode.com/problems/dot-product-of-two-sparse-vectors/">1570. 两个稀疏向量的点积</a></li>
<li><a href="https://leetcode.com/problems/3sum-closest/">16. 3Sum Closest</a></li>
</ul>
</li>
<li>Sum妙用<ul>
<li><a href="https://leetcode.com/problems/random-pick-with-weight/">528. Random Pick with Weight</a> 又是一道pre-sum题</li>
</ul>
</li>
</ul>
</li>
<li>乘法<ul>
<li><a href="https://leetcode.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a> - Two-way scan, 进化one-way</li>
</ul>
</li>
<li>高级数学<ul>
<li><a href="https://leetcode.com/problems/divide-two-integers/">29. Divide Two Integers</a> 位运算真不行</li>
<li><a href="https://leetcode.com/problems/multiply-strings/">43. Multiply Strings</a> 小心0</li>
<li><a href="https://leetcode.com/problems/expression-add-operators/">282. Expression Add Operators</a> backtrack 高级回溯</li>
<li><a href="https://leetcode.com/problems/valid-number/">65. Valid Number</a></li>
<li><a href="https://leetcode.com/problems/basic-calculator-ii/">227. Basic Calculator II</a></li>
</ul>
</li>
<li>排列组合<ul>
<li><a href="https://leetcode.com/problems/next-permutation/">31. Next Permutation</a> 三步走：1. locate; 2. switch; 3. reorder</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></li>
<li><a href="https://leetcode.com/problems/regular-expression-matching/">10. Regular Expression Matching</a></li>
<li>intervals<ul>
<li><a href="https://leetcode.com/problems/merge-intervals/">56. Merge Intervals</a> 1. sort; 2. listing; 3. to array</li>
<li><a href="https://leetcode.com/problems/interval-list-intersections/">986. Interval List Intersections</a></li>
<li><a href="https://leetcode.com/problems/meeting-rooms/">252. 会议室</a></li>
<li><a href="https://leetcode.com/problems/meeting-rooms-ii/">253. 会议室 II</a> PriorityQueue or Two pointers 双指针要再练一下</li>
<li><a href="https://leetcode.com/problems/exclusive-time-of-functions/">636. Exclusive Time of Functions</a></li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/task-scheduler/">621. Task Scheduler</a> 计算细节</li>
<li><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array</a> QuickSelect</li>
<li><a href="https://leetcode.com/problems/move-zeroes/">283. Move Zeroes</a></li>
<li>TreeOrder DFS or BFS<ul>
<li><a href="https://leetcode.com/problems/range-sum-of-bst/">938. Range Sum of BST</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/">314. 二叉树的垂直遍历</a></li>
<li><a href="https://leetcode.com/problems/binary-search-tree-iterator/">173. Binary Search Tree Iterator</a> Stack</li>
<li><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/">987. Vertical Order Traversal of a Binary Tree</a> Sort</li>
<li><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">103. Binary Tree Zigzag Level Order Traversal</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></li>
<li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></li>
<li><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree</a></li>
<li><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">429. N-ary Tree Level Order Traversal</a></li>
<li><a href="https://leetcode.com/problems/cousins-in-binary-tree/">993. Cousins in Binary Tree</a></li>
<li><a href="https://leetcode.com/problems/boundary-of-binary-tree/">545. 二叉树的边界</a></li>
<li><a href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a> 全局变量 or int[]</li>
<li><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a> BFS</li>
<li><a href="https://leetcode.com/problems/clone-graph/">133. Clone Graph</a> DFS</li>
<li><a href="https://leetcode.com/problems/copy-list-with-random-pointer/">138. Copy List with Random Pointer</a> 循环 or 迭代</li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/decode-ways/">91. Decode Ways</a> DP</li>
<li><a href="https://leetcode.com/problems/merge-sorted-array/submissions/">88. Merge Sorted Array</a></li>
<li><a href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a> PriorityQueue or Divide and Concur for (i &#x3D; 0; i &lt; n - interval; i +&#x3D; (2*interval)) interval *&#x3D; 2;</li>
<li><a href="https://leetcode.com/problems/powx-n/">50. Pow(x, n)</a> 递归 Warning StackOverflow</li>
<li><a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a> 双指针要再练一下</li>
<li><a href="https://leetcode.com/problems/number-of-islands/">200. Number of Islands</a> DFS 颜色标记法 or UnionFindSet</li>
<li><a href="https://leetcode.com/problems/alien-dictionary/">269. 火星词典</a> 拓扑排序 Topological Sort - 1. order; 2. queue; 3. toString</li>
<li><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/">426. 将二叉搜索树转化为排序的双向链表</a> 中序遍历 or <a href="https://zhuanlan.zhihu.com/p/101321696">morris遍历</a></li>
<li><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">211. Design Add and Search Words Data Structure</a> Trie</li>
<li><a href="https://leetcode.com/problems/leftmost-column-with-at-least-a-one/">1428. 至少有一个 1 的最左端列</a> 二分法</li>
<li>求祖宗系列<ul>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></li>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a> 递归</li>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/">1123. Lowest Common Ancestor of Deepest Leaves</a></li>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/">1644. 二叉树的最近公共祖先 II</a></li>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/">1650. 二叉树的最近公共祖先 III</a></li>
<li><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/">1676. 二叉树的最近公共祖先 IV</a></li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/first-bad-version/">278. First Bad Version</a> 简单二分</li>
<li><a href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water</a> 双指针 or 两次遍历</li>
<li><a href="https://leetcode.com/problems/word-break/">139. Word Break</a> dp</li>
<li><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a> backtrack</li>
<li><a href="https://leetcode.com/problems/accounts-merge/">721. Accounts Merge</a> 注意union find的思路和优化</li>
<li><a href="https://leetcode.com/problems/buildings-with-an-ocean-view/">1762. 能看到海景的建筑物</a></li>
<li><a href="https://leetcode.com/problems/lru-cache/">146. LRU Cache</a> 细节</li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock</a></li>
<li><a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a> 中序遍历 &#x2F; 递归</li>
<li><a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a> QuickSelect<ul>
<li><a href="https://leetcode.com/problems/top-k-frequent-words/">692. Top K Frequent Words</a></li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">438. Find All Anagrams in a String</a></li>
<li><a href="https://leetcode.com/problems/find-peak-element/">162. Find Peak Element</a></li>
<li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></li>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></li>
<li><a href="https://leetcode.com/problems/word-break-ii/">140. Word Break II</a></li>
<li><a href="https://leetcode.com/problems/maximum-swap/">670. Maximum Swap</a></li>
<li><a href="https://leetcode.com/problems/nested-list-weight-sum/">339. 嵌套列表权重和</a></li>
<li><a href="https://leetcode.com/problems/is-graph-bipartite/">785. Is Graph Bipartite?</a> 颜色标记法</li>
<li><a href="https://leetcode.com/problems/string-to-integer-atoi/">8. String to Integer (atoi)</a> 分情况讨论，疯狂if else orDeterministic Finite Automaton (DFA) 注意溢出情况</li>
<li><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">114. Flatten Binary Tree to Linked List</a></li>
<li><a href="https://leetcode.com/problems/sparse-matrix-multiplication/">311. 稀疏矩阵的乘法</a></li>
<li><a href="https://leetcode.com/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a> set or 排序后的双指针<ul>
<li><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/">350. Intersection of Two Arrays II</a></li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/">159. 至多包含两个不同字符的最长子串</a></li>
<li><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/">340. 至多包含 K 个不同字符的最长子串</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-paths/">257. Binary Tree Paths</a></li>
<li><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4. Median of Two Sorted Arrays</a></li>
<li><a href="https://leetcode.com/problems/read-n-characters-given-read4/">157. 用 Read4 读取 N 个字符</a><ul>
<li>进阶版<ul>
<li><a href="https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/">158. 用 Read4 读取 N 个字符 II</a> 题</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/word-ladder/">127. Word Ladder</a></li>
<li><a href="https://leetcode.com/problems/roman-to-integer/">13. Roman to Integer</a></li>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></li>
<li><a href="https://leetcode.com/problems/closest-binary-search-tree-value/">270. 最接近的二叉搜索树值</a> 这么简单的一道题，为啥我没做出来？？</li>
<li><a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/">317. 离建筑物最近的距离</a></li>
<li><a href="https://leetcode.com/problems/group-shifted-strings/">249. 移位字符串分组</a> hash的方法：(s.charAt(i) - s.charAt(i - 1) + 26) % 26</li>
<li><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/">304. Range Sum Query 2D - Immutable</a></li>
<li><a href="https://leetcode.com/problems/monotonic-array/">896. Monotonic Array</a></li>
<li><a href="https://leetcode.com/problems/random-pick-index/">398. Random Pick Index</a> Reservoir sampling</li>
<li><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">380. Insert Delete GetRandom O(1)</a> List + Map<ul>
<li><a href="https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/">381. Insert Delete GetRandom O(1) - Duplicates allowed</a></li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/walls-and-gates/">286. 墙与门</a></li>
<li><a href="https://leetcode.com/problems/squares-of-a-sorted-array/">977. Squares of a Sorted Array</a></li>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></li>
<li><a href="https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/">708. 循环有序列表的插入</a></li>
<li><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/">325. 和等于 k 的最长子数组长度</a></li>
<li><a href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV</a> DP</li>
<li><a href="https://leetcode.com/problems/custom-sort-string/">791. Custom Sort String</a></li>
<li><a href="https://leetcode.com/problems/diagonal-traverse/">498. Diagonal Traverse</a></li>
<li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. Kth Smallest Element in a Sorted Matrix</a></li>
<li><a href="https://leetcode.com/problems/flatten-nested-list-iterator/">341. Flatten Nested List Iterator</a></li>
<li><a href="https://leetcode.com/problems/valid-sudoku/">36. Valid Sudoku</a> (n n)</li>
<li><a href="https://leetcode.com/problems/moving-average-from-data-stream/">346. 数据流中的移动平均值</a> 1. Queue; 2. 环形列表存储</li>
<li><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/">1047. Remove All Adjacent Duplicates In String</a></li>
<li><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/">1209. Remove All Adjacent Duplicates in String II</a></li>
<li><a href="https://leetcode.com/problems/minesweeper/">529. Minesweeper</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/">298. 二叉树最长连续序列</a><ul>
<li><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/">549. 二叉树中最长的连续序列</a> follow up</li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs</a> Recursion → Iteration</li>
<li><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/">719. Find K-th Smallest Pair Distance</a> 精准二分</li>
<li><a href="https://leetcode.com/problems/implement-strstr/">28. Implement strStr()</a> KMP 太难了</li>
<li><a href="https://leetcode.com/problems/balance-a-binary-search-tree/">1382. Balance a Binary Search Tree</a></li>
<li><a href="https://leetcode.com/problems/sliding-window-median/">480. Sliding Window Median</a></li>
<li><a href="https://leetcode.com/problems/reverse-words-in-a-string/">151. Reverse Words in a String</a></li>
<li><a href="https://leetcode.com/problems/simplify-path/">71. Simplify Path</a> 用Deque<String> stack &#x3D; new LinkedList&lt;&gt;();,可以两头操作</li>
<li><a href="https://leetcode.com/problems/basic-calculator-iii/">772. 基本计算器 III</a> 只有加和乘，follow up是加上减和除</li>
<li><a href="https://leetcode.com/problems/kth-missing-positive-number/">1539. Kth Missing Positive Number</a> Binary Search</li>
<li><a href="https://leetcode.com/problems/minimum-cost-for-tickets/">983. Minimum Cost For Tickets</a> dp</li>
<li><a href="https://leetcode.com/problems/find-k-closest-elements/">658. Find K Closest Elements</a> Binary Search</li>
<li><a href="https://leetcode.com/problems/valid-word-abbreviation/">408. 有效单词缩写</a></li>
<li><a href="https://leetcode.com/problems/robot-room-cleaner/">489. 扫地机器人</a></li>
<li><a href="https://leetcode.com/problems/missing-number/">268. Missing Number</a> XOR; Sum; Binary Search</li>
<li><a href="https://leetcode.com/problems/find-leaves-of-binary-tree/">366. 寻找二叉树的叶子节点</a></li>
<li><a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median from Data Stream</a></li>
<li>中心对称数<ul>
<li><a href="https://leetcode.com/problems/strobogrammatic-number/">246. 中心对称数</a></li>
<li><a href="https://leetcode.com/problems/strobogrammatic-number-ii/">247. 中心对称数 II</a></li>
<li><a href="https://leetcode.com/problems/strobogrammatic-number-iii/">248. 中心对称数 III</a></li>
<li><a href="https://leetcode.com/problems/confusing-number/">1056. 易混淆数</a></li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/course-schedule/">207. Course Schedule</a> Topological Sorting</li>
<li><a href="https://leetcode.com/problems/making-a-large-island/">827. Making A Large Island</a> Union Find Set with details</li>
<li><a href="https://leetcode.com/problems/path-sum/">112. Path Sum</a> recursion or iteration</li>
<li>跳跃游戏<ul>
<li><a href="https://leetcode.com/problems/jump-game/">55. Jump Game</a> Greedy</li>
<li><a href="https://leetcode.com/problems/jump-game-ii/">45. Jump Game II</a> Greedy</li>
<li><a href="https://leetcode.com/problems/jump-game-iii/">1306. Jump Game III</a> recursion or iteration</li>
<li><a href="https://leetcode.com/problems/jump-game-iv/">1345. Jump Game IV</a> Queue</li>
<li><a href="https://leetcode.com/problems/jump-game-v/">1340. Jump Game V</a></li>
<li><a href="https://leetcode.com/problems/jump-game-vi/">1696. Jump Game VI</a> Deque or in-place dp</li>
<li><a href="https://leetcode.com/problems/jump-game-vii/">1871. Jump Game VII</a> Smart DP</li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/jump-game/">14. Longest Common Prefix</a> Horizontal scanning; Vertical scanning; Divide and conquer; Binary search</li>
<li><a href="https://leetcode.com/problems/daily-temperatures/">739. Daily Temperatures</a></li>
<li>bitmask<ul>
<li><a href="https://leetcode.com/problems/subsets/">78. Subsets</a></li>
<li><a href="https://leetcode.com/problems/maximum-good-people-based-on-statements/">2151. Maximum Good People Based on Statements</a></li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">129. Sum Root to Leaf Numbers</a></li>
<li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/">323. 无向图中连通分量的数目</a> UnionFindSet</li>
<li><a href="https://leetcode.com/problems/minimum-area-rectangle/">939. Minimum Area Rectangle</a></li>
<li><a href="https://leetcode.com/problems/minimum-area-rectangle-ii/">963. Minimum Area Rectangle II</a></li>
<li><a href="https://leetcode.com/problems/word-search/">79. Word Search</a></li>
<li><a href="https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/">702. 搜索长度未知的有序数组</a></li>
<li><a href="https://leetcode.com/problems/find-the-celebrity/">277. 搜寻名人</a></li>
<li><a href="https://leetcode.com/problems/max-consecutive-ones-iii/">1004. Max Consecutive Ones III</a></li>
<li><a href="https://leetcode.com/problems/longest-repeating-character-replacement/">424. Longest Repeating Character Replacement</a></li>
<li><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">1091. Shortest Path in Binary Matrix</a></li>
<li><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/">1011. Capacity To Ship Packages Within D Days</a></li>
<li><a href="https://leetcode.com/problems/design-circular-queue/">622. Design Circular Queue</a></li>
<li><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/">863. All Nodes Distance K in Binary Tree</a></li>
<li><a href="https://leetcode.com/problems/toeplitz-matrix/">766. Toeplitz Matrix</a></li>
<li><a href="https://leetcode.com/problems/cutting-ribbons/">1891. Cutting Ribbons</a></li>
<li><a href="https://leetcode.com/problems/closest-binary-search-tree-value/">270. Closest Binary Search Tree Value</a></li>
<li><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></li>
<li><a href="https://leetcode.com/problems/max-area-of-island/">695. Max Area of Island</a></li>
<li><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></li>
<li><a href="https://leetcode.com/problems/palindrome-permutation/">266. Palindrome Permutation</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Monotonic Stack, Monotonic Queue 单调队列，单调栈【ING/太难了/求指导】</title>
    <url>/tech/monotonic-stack-and-monotonic-queue/</url>
    <content><![CDATA[<h1 id="开篇废话"><a href="#开篇废话" class="headerlink" title="开篇废话"></a>开篇废话</h1><p>兜兜转转又一个月，继续征战，这次我们看看视觉美观的单调队列和单调栈，看看单调的人生怎么解。</p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>输入一般是一个array，然后我们只关心一种数据，要么大于，要么小于当前值的值，所以与一般的栈不同，我们有选择性的出入栈。<br>实现的话，一般使用原生栈，<code>Stack in Java</code>，或者，手动单头操作队列</p>
<h2 id="简单题入手"><a href="#简单题入手" class="headerlink" title="简单题入手"></a>简单题入手</h2><p>简单题简单在直接明了，一般都有很明显的提示，寻找单侧下一个最大&#x2F;小值。</p>
<h3 id="求具体数值"><a href="#求具体数值" class="headerlink" title="求具体数值"></a>求具体数值</h3><p>栈内既可以放index，又可以放value<br>例题：</p>
<ul>
<li><a href="https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/">1475. Final Prices With a Special Discount in a Shop</a><br><button type="button" class="collapsible" name="1475">一些理解</button><collapsible-content name="content-1475">
  这题一道比较典型的单调栈问题, 由于我们只需要找到右侧第一个小于当前数的数，我们有两种遍历方式：1. 从左往右遍历，栈中维护之前数字的index，如果之前的数大于当前数，我们那弹出并更新前一个数的答案；2. 从右往左遍历，栈中维护已遇到的数字，如果当前数小于之前的数字，则一直弹出，直到遇到一个小于当前数的数字，或者栈为空，得出当前答案。
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] finalPrices(<span class="hljs-type">int</span>[] prices) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; prices[stack.peek()] &gt;= prices[i]) &#123;<br>            ans[stack.pop()] -= prices[i];<br>        &#125;<br>        ans[i] = prices[i];<br>        stack.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] finalPrices(<span class="hljs-type">int</span>[] prices) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &gt; prices[i]) &#123;<br>            stack.pop();<br>        &#125;<br>        ans[i] = prices[i] - (stack.isEmpty() ? <span class="hljs-number">0</span> : stack.peek());<br>        stack.push(prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
</collapsible-content></li>
</ul>
<p>练习：</p>
<ul>
<li><a href="https://leetcode.com/problems/next-greater-element-i/">496. Next Greater Element I</a></li>
<li><a href="https://leetcode.com/problems/number-of-valid-subarrays/description/">1063. Number of Valid Subarrays</a> 不关心位置，只关心数值，直接在栈中存放数值，简单直接</li>
</ul>
<h3 id="关心index-index之间的差距-数字统计"><a href="#关心index-index之间的差距-数字统计" class="headerlink" title="关心index&#x2F;index之间的差距&#x2F;数字统计"></a>关心index&#x2F;index之间的差距&#x2F;数字统计</h3><p>栈内存放index<br>例题：</p>
<ul>
<li><a href="https://leetcode.com/problems/daily-temperatures/">739. Daily Temperatures</a><br><button type="button" class="collapsible" name="739">一些理解</button><collapsible-content name="content-739">
  这题用单调栈的解法很直接，与上面两题相似，正反遍历都可以，但是比较有意思的地方是用数组优化空间的第二解法，以后遇到类似的题，可以考虑灵活运用。
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> temperatures.length;<br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <br>    <span class="hljs-comment">// 方法一：stack</span><br>    <span class="hljs-comment">// Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br>    <span class="hljs-comment">// for (int i = n-1; i &gt;= 0; i--) &#123;</span><br>    <span class="hljs-comment">//     while (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt;= temperatures[i]) &#123;</span><br>    <span class="hljs-comment">//         stack.pop();</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     ans[i] = stack.isEmpty() ? 0 : stack.peek() - i;</span><br>    <span class="hljs-comment">//     stack.push(i);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <br>    <span class="hljs-comment">// 方法二：利用答案数组</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">highest</span> <span class="hljs-operator">=</span> temperatures[n-<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (temperatures[i] &gt;= highest) &#123;<br>            highest = temperatures[i];<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (temperatures[i + day] &lt;= temperatures[i]) &#123;<br>            day += ans[i + day];<br>        &#125;<br>        ans[i] = day;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
</collapsible-content></li>
</ul>
<p>练习：</p>
<ul>
<li><a href="https://leetcode.com/problems/number-of-visible-people-in-a-queue/">1944. Number of Visible People in a Queue</a> 基础操作啊，兄弟萌，搞定这道‘Hard’题，是不是信心暴涨？</li>
<li><a href="https://leetcode.com/problems/number-of-people-that-can-be-seen-in-a-grid/">2282. Number of People That Can Be Seen in a Grid</a> 上一题的复杂版，增加了一种情况，都一样啦</li>
<li><a href="https://leetcode.com/problems/buildings-with-an-ocean-view/">1762. Buildings With an Ocean View</a> 我在面Meta时遇到的原题，用Stack很简单，但是，由于题目的特殊性，还有更简单的！</li>
</ul>
<h3 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h3><p>有的时候index和value都需要，那么我们可以灵活运用：1. 栈内存放index，利用数组取值；2. 栈内直接存放复合结构。<br>练习：</p>
<ul>
<li><a href="https://leetcode.com/problems/next-greater-node-in-linked-list/">1019. Next Greater Node In Linked List</a></li>
</ul>
<h2 id="中等题练手"><a href="#中等题练手" class="headerlink" title="中等题练手"></a>中等题练手</h2><h3 id="求区间最大最小值"><a href="#求区间最大最小值" class="headerlink" title="求区间最大最小值"></a>求区间最大最小值</h3><p>单调栈中存放index，然后利用单调性找到最大最小区间</p>
<p>例题：</p>
<ul>
<li><p><a href="https://leetcode.com/problems/maximum-of-minimum-values-in-all-subarrays/">1950. Maximum of Minimum Values in All Subarrays</a><br><button type="button" class="collapsible" name="1950">一些理解</button></p>
<collapsible-content name="content-1950">
  答案一定是非递增的数列。

<p>  首先上Brute Force大法，考虑所有的子数组，时间复杂度是O(n^2)，空间复杂度为O(1)。<br>  再考虑优化空间，其实，我们可以用一个单调递增栈维护追踪最大数值的范围。栈内存放index，按照值递增。</p>
<p>  以<code>[10, 20, 50, 10]</code>为例，当我们遍历到第3位时，栈内的情况是<code>[0, 1, 2]</code>，这时，为了维护栈的单调性，我们需要进行弹出操作。<br>  首先，弹出index：2，index为2的数字，在哪一个子数组中，可以作为最小值？左边界为上一个stack元素（上一个值小于nums[2]的index）+ 1，右边界为当前index - 1，所以，对于nums[2]来说，它作为最小值的范围是[1+1, 3-1]，也就是[2,2]，长度为(2-2+1)。所以，更新一下ans[0]的答案。<br>  然后，弹出index：1，考虑 index为1的数字 作为最小值的范围。左边界依旧是上一个stack元素 + 1，右边界为当前index - 1，也就是[0 + 1, 3 - 1] &#x3D; [1, 2]，事实也是这样。所以，更新一下长度为2的答案。<br>  接着，弹出index：0，这时，stack里没有元素了，说明它是从数组头开始，最小的一个数字，所以左边界就是0，右边界依旧是index - 1，所以，index为0的数字 作为最小值的范围是[0, 3 - 1] &#x3D; [0, 2]。更新一下长度为3的答案。<br>  弹出操作结束，我们需要把当前index压入栈中，栈变成了<code>[3]</code>，因为已经到栈的末尾了，所以我们进行弹出操作，考虑index为3的数字 作为最小值的范围。此处，栈为空，所以，左边界为0，右边界为数组长度 - 1，范围是[0, 3]，更新长度为4的答案。</p>
<p>  到这里的话，相信大家已经理解了栈的操作，可以有一个问题没有解决，就是我们在考虑边界的时候，考虑的是最大边界，那么就有可能中间有一些部分是没有更新到的（比如在<code>[5, 1, 1, 5]</code>这个例子中，大家可以按照上面的操作自行模拟一下）。继续考虑上一个模拟例子，index为0的数字 作为最小值的范围最大范围是[0, 2]，那么是不是说明在[0,1]，[0,0]的范围内，index也可以作为最小值，所以长度小于3的答案，一定大于或等于ans[3]。因为，我们需要对答案数组进行一个遍历，保证它整体是一个非递增数列，并且填补空缺。</p>
<p>  解决所有问题之后，上代码。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findMaximums(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 存放数组index，按照值严格递增</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> (i == n) ? <span class="hljs-number">0</span> : nums[i]; <span class="hljs-comment">// trick：用0作为哨兵，解决遍历完成的情况</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &gt;= cur) &#123; <br>            <span class="hljs-comment">// 栈内index元素不小于当前值，需要弹出，以保证栈单调递增</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> stack.pop(),<br>                left = stack.isEmpty() ? <span class="hljs-number">0</span> : stack.peek() + <span class="hljs-number">1</span>, <span class="hljs-comment">// 左边界情况</span><br>                right = i - <span class="hljs-number">1</span>, <span class="hljs-comment">// 右边界情况 </span><br>                len = right - left + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// nums[index]是[left, right]的子数组中最小值</span><br>            <span class="hljs-comment">// 根据len， 更新ans数组</span><br>            ans[len - <span class="hljs-number">1</span>] = Math.max(ans[len - <span class="hljs-number">1</span>], nums[index]);<br>        &#125;<br>        stack.push(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 保证ans数组的非递增性，填补空缺</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        ans[i-<span class="hljs-number">1</span>] = Math.max(ans[i], ans[i-<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  时间复杂度为 O(n)，因为每个元素，我们最多处理一次。<br>  空间复杂度为 O(n)，因为我们需要一个栈来存储元素，最大为数组长度。</p>
</collapsible-content>
</li>
<li><p><a href="https://leetcode.com/problems/sum-of-subarray-ranges/">2104. Sum of Subarray Ranges</a><br><button type="button" class="collapsible" name="2104">一些理解</button></p>
<collapsible-content name="content-2104">
  上一题的进阶版

<p>  这题花了我很久的时间，主要难点在于如何把题目转换成一道单调栈的题目（多数题的难点）。</p>
<p>  我们先用Brute Force进行思考，考虑所有的子数组，用<code>min</code>和<code>max</code>来记录当前数组的最小值和最大值，时间复杂度是O(n^2)，空间复杂度为O(1)。</p>
<p>  想想是否有优化空间，其实，答案 &#x3D; ∑(子数组的差值) &#x3D; ∑(子数组最大值 - 子数组最小值) &#x3D; ∑子数组最大值 - ∑子数组最小值。所以，我们可以用两个Queue来计算数组最大值的和，以及数组最小值的和。</p>
<p>  考虑nums&#x3D;[4,-2,-3,5,1]的情况。<br>  先看最小值，每个数字至少有一次成为数组最小值的机会，用最大值<code>5</code>来说，在<code>[5]</code>这个子数组中，它是最小值，那考虑最小值<code>-3</code>来说，它在<code>[-3], [-2,-3], [-3,5], [4,-2,-3], [-2,-3,5], [-3,5,1], [4,-2,-3,5], [-2,-3,5,1], [4,-2,-3,5,1]</code>，这9个子数组中都是最小值，所以<code>∑子数组最小值</code>中有9个<code>-3</code>和1个<code>5</code>。如何得出这个9和1呢？我们可以利用单调栈。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 数组值的单增栈，存放index</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt;= nums.length; right++) &#123; <span class="hljs-comment">//从左往右遍历数组</span><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; (right == nums.length || nums[stack.peek()] &gt;= nums[right])） &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop(); <span class="hljs-comment">// 计算cur为最小值的子数组数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek(); <span class="hljs-comment">// 左边界为stack的当前头，如果stack为空，左边界为 -1</span><br>        ans -= nums[cur] * (right - cur) * (cur - left); <span class="hljs-comment">// 处理当前最小值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  同理，可得最大值的情况，每个数字也至少有一次成为数组最大值的机会，考虑最小值<code>-3</code>来说，它在<code>[-3]</code>，同样利用单调栈。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 数组值的单减栈，存放index</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; nums.length; right++) &#123; <span class="hljs-comment">//从左往右遍历数组</span><br>    <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt;= nums[i]) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop(); <span class="hljs-comment">// 计算cur为最大值的子数组数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek(); <span class="hljs-comment">// 左边界为stack的当前头，如果stack为空，左边界为 -1</span><br>        ans += nums[cur] * (right - cur) * (cur - left); <span class="hljs-comment">// 处理当前最大值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  所以，我们可以得出完整的代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">subArrayRanges</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt;= n; right++) &#123;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; (right == n || nums[stack.peek()] &gt;= nums[right])) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>            ans -= (<span class="hljs-type">long</span>)nums[last] * (right - last) * (last - left);<br>        &#125;<br>        stack.add(right);<br>    &#125;<br>    <br>    stack.clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt;= n; right++) &#123;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; (right == n || nums[stack.peek()] &lt;= nums[right])) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>            ans += (<span class="hljs-type">long</span>)nums[last] * (right - last) * (last - left);<br>        &#125;<br>        stack.add(right);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
</collapsible-content></li>
</ul>
<p>练习：</p>
<ul>
<li><a href="https://leetcode.com/problems/maximum-score-of-a-good-subarray/">1793. Maximum Score of a Good Subarray</a> 相同套路，也可以用双指针</li>
<li><a href="https://leetcode.com/problems/maximum-subarray-min-product/">1856. Maximum Subarray Min-Product</a></li>
<li><a href="https://leetcode.com/problems/sum-of-subarray-minimums/">907. Sum of Subarray Minimums</a></li>
<li><a href="https://leetcode.com/problems/subarray-with-elements-greater-than-varying-threshold/">2334. Subarray With Elements Greater Than Varying Threshold</a></li>
</ul>
<h3 id="结合数组，简化二维问题"><a href="#结合数组，简化二维问题" class="headerlink" title="结合数组，简化二维问题"></a>结合数组，简化二维问题</h3><p>例题：</p>
<ul>
<li><p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">84. Largest Rectangle in Histogram</a><br><button type="button" class="collapsible" name="84">一些理解</button></p>
<collapsible-content name="content-84">
  这题也有点复杂，如何利用单调栈，降低时间复杂度。

<p>  还是首先考虑Brute Force，可以用从左往右遍历数组，对于每一个index，考虑它作为高度的情况下，矩阵宽为多少，考虑所有情况取最大值就好了。时间复杂度为O(n^2)，空间复杂度为O(n)，其实还挺好的。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = heights.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = i;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; heights[left] &gt;= heights[i]) &#123;<br>            left--;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; heights[right] &gt;= heights[i]) &#123;<br>            right++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> right - left - <span class="hljs-number">1</span>;<br>        max = Math.max(max, width * heights[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  但是，到这里还不能过所有的case。那咋办？上工具。如果我们有一个根据长度递增的单调栈，当进入某一个index时，我们发现stack里的高度大于当前高度，以stack里的高度作为高度的矩阵的宽度有限了，不能再向右扩展了，于是我们计算一下以stack里的高度作为高度的矩阵的面积，将它弹出，直到stack里的高度都小于当前高度，继续探索极限。<br>  这里用到的技巧主要有三个：<br>  1. stack不直接放高度，而使用数组index表示，更方面我们找到位置，计算宽度 （简单操作细节）；<br>  2. 在数组遍历结束后，对于栈里剩余元素的处理，这里我们默认在数组结尾补上一个<code>0</code> （常见操作细节）；<br>  3. 在弹出元素时计算结果。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = heights.length;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 按照高度递增的栈，存放高度index</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (i == n) ? <span class="hljs-number">0</span> : heights[i]; <span class="hljs-comment">// 细节2: 补0操作</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= h) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> stack.pop(), left = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>            max = Math.max(max, heights[index] * (i - left - <span class="hljs-number">1</span>));<br>        &#125;<br>        stack.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  这样时间&#x2F;空间复杂度为O(n)，因为对于每一个index，我们最多处理一次。</p>
</collapsible-content></li>
<li><p><a href="https://leetcode.com/problems/count-submatrices-with-all-ones/">1504. Count Submatrices With All Ones</a><br><button type="button" class="collapsible" name="1504">一些理解</button></p>
<collapsible-content name="content-1504">
  在上题的基础上，把问题变得稍微复杂一些，变化有：
      1. Histogram不是直接给定的，需要用一个数组维护；
      2. 需要计算所有的矩阵数量，不只是最大的那一个

  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubmat</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] mat)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mat.length, m = mat[<span class="hljs-number">0</span>].length, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[] heights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 存放index</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 按行遍历</span><br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        stack.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++) &#123; <span class="hljs-comment">// 按列遍历</span><br>            heights[j] = (mat[i][j] == <span class="hljs-number">1</span>) ? heights[j] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计高度</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[j]) &#123;<br>                <span class="hljs-comment">// 弹出比当前列高的index</span><br>                stack.pop();<br>            &#125;<br>            <span class="hljs-comment">// 计算以mat[i][j]为右下的所有矩形数</span><br>            <span class="hljs-keyword">if</span> (!stack.isEmpty()) &#123; <br>                <span class="hljs-comment">// 前面有一个比现在低的列</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> stack.peek(); <span class="hljs-comment">// 得到比当前低的列的index</span><br>                sum[j] = sum[preIndex]; <span class="hljs-comment">// 匹配特定矩形，保证可以得到sum[preIndex]个矩形</span><br>                sum[j] += heights[j] * (j - preIndex); <span class="hljs-comment">// 另外，计算当前列和矮列之间的矩形数量</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 说明当前列是最低的</span><br>                sum[j] = heights[j] * (j + <span class="hljs-number">1</span>); <span class="hljs-comment">// 所以一共有这么多个矩形以mat[i][j]为右下</span><br>            &#125;<br>            ans += sum[j];<br>            stack.push(j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
</collapsible-content></li>
</ul>
<p>练习：</p>
<ul>
<li><a href="https://leetcode.com/problems/maximal-rectangle/">85. Maximal Rectangle</a></li>
</ul>
<h3 id="使用多个单调栈"><a href="#使用多个单调栈" class="headerlink" title="使用多个单调栈"></a>使用多个单调栈</h3><p>例题：</p>
<ul>
<li><p><a href="https://leetcode.com/problems/jump-game-viii/">2297. Jump Game VIII</a><br><button type="button" class="collapsible" name="2297">一些理解</button></p>
<collapsible-content name="content-2297">
  这道题烦在理解题目意思上。

<p>  首先，可以明确的是，我们只能往后跳，不能回头。如果i点可以到达j点，那么i，j需要满足题目给定的两个条件之一。这两个条件是独立的，不可能有一个点既满足条件1，又满足条件2。所以，我们可以把这两个条件独立进行思考。</p>
<p>  先来看看第二个条件，<code>nums[i] &gt; nums[j] and nums[k] &gt;= nums[i] for all indexes k in the range i &lt; k &lt; j.</code> 意思就是，i位的数字比j位的数字大，并且，i和j中间的之间的所有数字都大于等于i位的数字，换言之，j必须是第一个小于i的数字，即使还有一个index为j2的数字也小于nums[i]，i也无法跳到j2，因为j在i和j2之间，并且nums[j]小于nums[i]，不满足条件了。所以，对于每一个index i来说，在这个条件下最多只可能到达一个j，也有可能没有满足条件的j。<br>  那么，我们是不是可以用一个递增的单调栈，如果出现了一下较小的数字，说明栈内的index可以跳到当前位置。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Stack&lt;Integer&gt; maxStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 存放index，按照数值递增</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>    <span class="hljs-keyword">while</span> (!maxStack.isEmpty() &amp;&amp; nums[maxStack.peek()] &gt; nums[j]) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> maxStack.pop(); <span class="hljs-comment">// nums[j]是i之后第一个比nums[i]小的数字</span><br>        <span class="hljs-comment">// 考虑从 i -&gt; j的情况</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  同理，我们考虑第一个条件，<code>nums[i] &lt;= nums[j] and nums[k] &lt; nums[i] for all indexes k in the range i &lt; k &lt; j</code>，在这种情况下，如果i的数字小于等于j的数字，并且i，j之间的数字都小于nums[i]，i可以到达j，也就是说，在nums[j]是第一个大于等于nums[i]的数字。那么，与上一个条件类似，我们可以使用一个递减的单调栈，找到第一个大于等于nums[i]的数字。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Stack&lt;Integer&gt; minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">// 存放index，按照数值递减</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>    <span class="hljs-keyword">while</span> (!minStack.isEmpty() &amp;&amp; nums[minStack.peek()] &lt;= nums[j]) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> maxStack.pop(); <span class="hljs-comment">// nums[j]是i之后第一个大于等于nums[i]的数字</span><br>        <span class="hljs-comment">// 考虑从 i -&gt; j的情况</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  最后还有一件事情，就是，如何考虑从i到j的成本情况。我们需要用一个dp列表，来维护到达每一个index的最小cost。<br>  那么，有两个可能的问题：</p>
<ol>
<li>是不是我们在到达位置j时，j之前的位置都已经计算cost完成？<br> 是的。因为我们是从左到右遍历的，在循环体内计算当前位置的cost，所以，在到达位置j之前，前面的index一定是已经计算结束了，不存在到达位置j之后，对于位置j之前的dp值更新。</li>
<li>是不是到达位置j之前，所有的位置一定都能到达？<br> 是的，因为相邻的位置，一定要么满足条件1，要么满足条件2，两个条件互补。所以，我们从位置0一定可以到达所有的位置。</li>
</ol>
<p>  所有的问题都解决啦，那么我们就可以开始写代码了。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] costs)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>    Arrays.fill(dp, Long.MAX_VALUE);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    Stack&lt;Integer&gt; maxStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(), minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">while</span> (!minStack.isEmpty() &amp;&amp; nums[minStack.peek()] &lt;= nums[j]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> minStack.pop();<br>            dp[j] = Math.min(dp[j], dp[i] + costs[j]);<br>        &#125;<br>        minStack.push(j);<br>        <span class="hljs-keyword">while</span> (!maxStack.isEmpty() &amp;&amp; nums[maxStack.peek()] &gt; nums[j]) &#123;<br>            dp[j] = Math.min(dp[j], dp[maxStack.pop()] + costs[j]);<br>        &#125;<br>        maxStack.push(j);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
</collapsible-content></li>
</ul>
<p>练习：</p>
<ul>
<li><a href="https://leetcode.com/problems/next-greater-element-iv/">2454. Next Greater Element IV</a></li>
</ul>
<h3 id="将记录和计算步骤分开"><a href="#将记录和计算步骤分开" class="headerlink" title="将记录和计算步骤分开"></a>将记录和计算步骤分开</h3><p>例题：</p>
<ul>
<li><a href="https://leetcode.com/problems/maximum-width-ramp/">962. Maximum Width Ramp</a> &#x2F;&#x2F; todo<br><button type="button" class="collapsible" name="962">一些理解</button><collapsible-content name="content-962">
  这道题同样使用单调栈，但是又有一些不同。常规单调栈，我们会遍历数组，对于每一个元素进行处理和答案更新，但是，在这道题中，1. 我们并不关心所有元素，只把特定的元素加入栈中；2. 第一遍遍历，我们先组建栈，在第二步遍历时，我们才寻找答案。
  所以，在使用单调栈的过程中，我们要学会变通，抓主要矛盾，灵活使用。
</collapsible-content></li>
</ul>
<p>练习：</p>
<ul>
<li><a href="https://leetcode.com/problems/find-the-most-competitive-subsequence/">1673. Find the Most Competitive Subsequence</a></li>
</ul>
<h3 id="其他练习"><a href="#其他练习" class="headerlink" title="其他练习"></a>其他练习</h3><ul>
<li><p><a href="https://leetcode.com/problems/132-pattern/">456. 132 Pattern</a> 值得练习哦，单独po了一个页<a href="https://esther.fun/tech/leetcode-132-pattern/">我的理解</a></p>
</li>
<li><p><a href="https://leetcode.com/problems/next-greater-element-ii/">503. Next Greater Element II</a> 在前面496的基础上增加环形的要求，但是还是基本的单调栈，思考难度不高</p>
</li>
<li><p><a href="https://leetcode.com/problems/online-stock-span/">901. Online Stock Span</a> 种类题偏简单，想清楚即可</p>
</li>
<li><p><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/">581. Shortest Unsorted Continuous Subarray</a> 用单调栈可以解决的问题，但是可能还有更好的办法哦</p>
</li>
<li><p><a href="https://leetcode.com/problems/maximum-binary-tree/">654. Maximum Binary Tree</a> 这题用单调栈没有递归直接，需要一些理解</p>
</li>
<li><p><a href="https://leetcode.com/problems/steps-to-make-array-non-decreasing/">2289. Steps to Make Array Non-decreasing</a> 需要考虑更多的情况，值得练习 todo</p>
</li>
<li><p><a href="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/">1130. Minimum Cost Tree From Leaf Values</a> 这题需要把题目意思转换成一个stack的问题，理解力+技巧</p>
</li>
<li><p><a href="https://leetcode.com/problems/remove-duplicate-letters/">316. Remove Duplicate Letters</a> &#x3D; <a href="https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/">1081. Smallest Subsequence of Distinct Characters</a> 变身妙蛙种子，直呼妙蛙妙蛙 &#x2F;&#x2F;[todo]</p>
</li>
<li><p><a href="https://leetcode.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/">2030. Smallest K-Length Subsequence With Occurrences of a Letter</a> 进阶版</p>
</li>
<li><p><a href="https://leetcode.com/problems/car-fleet/">853. Car Fleet</a> 挺有趣的，转换之后就很简单啦</p>
</li>
<li><p><a href="https://leetcode.com/problems/car-fleet-ii/">1776. Car Fleet II</a> 配套系列，另一个角度</p>
</li>
<li><p><a href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/">255. Verify Preorder Sequence in Binary Search Tree</a> 是一道很好的单调栈应用题 todo</p>
</li>
<li><p><a href="https://leetcode.com/problems/sum-of-total-strength-of-wizards/">2281. Sum of Total Strength of Wizards</a> 进阶版</p>
</li>
<li><p><a href="https://leetcode.com/problems/remove-k-digits/">402. Remove K Digits</a> 基础题，普通操作</p>
</li>
<li><p><a href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water</a> 经典题，单独po了一个页<a href="https://esther.fun/tech/leetcode-trapping-rain-water/">我的理解</a> todo</p>
</li>
<li><p><a href="https://leetcode.com/problems/max-chunks-to-make-sorted-ii/">768. Max Chunks To Make Sorted II</a></p>
</li>
</ul>
<h2 id="难题上手"><a href="#难题上手" class="headerlink" title="难题上手"></a>难题上手</h2><p><a href="https://leetcode.com/problems/odd-even-jump/">975. Odd Even Jump</a><br><a href="https://leetcode.com/problems/create-maximum-number/">321. Create Maximum Number</a></p>
<ol start="1671">
<li>Minimum Number of Removals to Make Mountain Array</li>
<li>Constrained Subsequence Sum</li>
<li>Score of Parentheses</li>
</ol>
<p>214 Shortest Palindrome<br>239 Sliding Window Maximum</p>
<p>321 Create Maximum Number</p>
<p>862 Shortest Subarray with Sum at Least K<br>889 Construct Binary Tree from Preorder and Postorder Traversal<a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal</a>)</p>
<p>和单调栈没什么关系，自己练习一下吧：<a href="https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/">1996. The Number of Weak Characters in the Game</a></p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Python边角知识问答</title>
    <url>/tech/python-corner-questions/</url>
    <content><![CDATA[<ol>
<li>String的前缀有哪些？</li>
</ol>
<ul>
<li>自然字符串，r&#x2F;R 避免转义 </li>
<li>Unicode字符串，u&#x2F;U 处理Unicode文本 </li>
<li>带变量的字符串， f&#x2F;F 取得变量值</li>
</ul>
<ol start="2">
<li><p>元组和列表的区别？元组用什么标识？<br>  元组是不可变的列表。用<code>,</code>标识。</p>
</li>
<li><p>元组不可以修改么？<br>  不可以改变元组中的值，但是，可以用新的元组覆盖旧元组。</p>
</li>
<li><p>如何解释<code>a = (1)</code>？<br>  把数值1赋给变量a，圆括号没有意义。</p>
</li>
<li><p><code>&#39;\n \n&#39;.isspace()</code> True or False?<br>  True</p>
</li>
</ol>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Meaningless</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick Select 快速选择</title>
    <url>/tech/quickselect/</url>
    <content><![CDATA[<h1 id="开篇废话"><a href="#开篇废话" class="headerlink" title="开篇废话"></a>开篇废话</h1><p>最近有重要面试，时间真的很紧张啊！不会的还有好多，只能逐个快速击破了！QwQ</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol>
<li>Choose a random pivot.</li>
<li>Use a <strong>partition</strong> algorithm to place the pivot into its perfect position pos in the sorted array, move smaller elements to the left of pivot, and larger or equal ones - to the right.</li>
<li>Compare pos and N - k to choose the side of array to proceed recursively.</li>
</ol>
<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><h2 id="自用简易模版"><a href="#自用简易模版" class="headerlink" title="自用简易模版"></a>自用简易模版</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>  <span class="hljs-keyword">return</span> quickSelect(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, k-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quickSelect</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> partition(nums, l, r);<br>  <span class="hljs-keyword">if</span> (index == k) <span class="hljs-keyword">return</span> nums[k];<br>  <span class="hljs-keyword">return</span> index &lt; k ? quickSelect(nums, index+<span class="hljs-number">1</span>, r, k) : quickSelect(nums, l, index - <span class="hljs-number">1</span>, k);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[r];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt; r; i++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[i] &gt;= pivot) &#123;<br>          swap(nums, l++, i);<br>      &#125;<br>  &#125;<br>  swap(nums, l, r);<br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[l];<br>  nums[l] = nums[r];<br>  nums[r] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ul>
<li><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array</a> 非常直接</li>
<li><a href="https://leetcode.com/problems/k-closest-points-to-origin/">973. K Closest Points to Origin</a> 直接+1</li>
<li><a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a> 加了一个map</li>
<li><a href="https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array">1985. Find the Kth Largest Integer in the Array</a> 变成String比较，而且数值更大了</li>
<li><a href="https://leetcode.com/problems/wiggle-sort-ii/">324. Wiggle Sort II</a> 太难了，放弃了</li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Segment Tree 线段树</title>
    <url>/tech/segment-tree/</url>
    <content><![CDATA[<h1 id="开篇废话"><a href="#开篇废话" class="headerlink" title="开篇废话"></a>开篇废话</h1><p>做题遇到了线段树，三脸懵逼，赶紧的吧！</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul>
<li>线段树是一棵二叉树</li>
<li>构造线段树的时间复杂度和空间复杂度都为O(n)</li>
<li>二叉树的节点区间定义，<code>[start, end]</code>代表节点的区间范围，<code>max / min / sum</code>是节点在<code>[start, end]</code>区间上的最值, <code>left</code>, <code>right</code>是当前节点区间划分之后的左右节点区间。</li>
<li>维护线段树中存在的区间中最值，有利于高效查询任何区间的最值，O(logN)。</li>
<li>单点更新：单点更新需要从叶子节点一路走到根节点, 去更新线段树上的值。因为线段树的高度为log(n),所以更新序列中一个节点的复杂度为log(n)</li>
<li>使用Lazy Propagation 懒加载实现区间更新，期望复杂度降到了O(logn) 的级别或更低</li>
<li>对于值域范围不确定的处理技巧：（1）离散化 + 线段树；（2）动态开点: 不事前构造空树，而是在插入操作 update 和查询操作 query 时根据访问需要进行「开点」操作，线段树的插入和查询都是log(n)的，因此我们在单次操作的时候，最多会创建数量级为log(n)的点，因此空间复杂度为O(mlog(n))。</li>
</ul>
<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><h2 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h2><h3 id="节点区间定义"><a href="#节点区间定义" class="headerlink" title="节点区间定义"></a>节点区间定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [start, end] 代表节点的区间范围</span><br><span class="hljs-comment">// max 是节点在(start,end)区间上的最大值</span><br><span class="hljs-comment">// left , right 是当前节点区间划分之后的左右节点区间</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTreeNode</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> start, end, max;<br>    <span class="hljs-keyword">public</span> SegmentTreeNode left, right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SegmentTreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> max)</span> &#123;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>        <span class="hljs-built_in">this</span>.max = max<br>        <span class="hljs-built_in">this</span>.left = <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="构造代码"><a href="#构造代码" class="headerlink" title="构造代码"></a>构造代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造的代码及注释</span><br><span class="hljs-keyword">public</span> SegmentTreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A)</span> &#123;<br>    <span class="hljs-comment">// write your code here</span><br>    <span class="hljs-keyword">return</span> buildhelper(<span class="hljs-number">0</span>, A.length - <span class="hljs-number">1</span>, A);<br>&#125;<br><span class="hljs-keyword">public</span> SegmentTreeNode <span class="hljs-title function_">buildhelper</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] A)</span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">SegmentTreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SegmentTreeNode</span>(left, right, A[left]); <span class="hljs-comment">// 根据节点区间的左边界的序列值为节点赋初值</span><br>    <span class="hljs-keyword">if</span>(left == right)&#123;<br>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 如果左边界和右边界相等,节点左边界的序列值就是线段树节点的接节点值</span><br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 划分当前区间的左右区间</span><br>    root.left = buildhelper(left, mid, A);<br>    root.right = buildhelper(mid + <span class="hljs-number">1</span>, right, A);<br>    root.max = Math.max(root.left.max, root.right.max); <span class="hljs-comment">// 根据节点区间的左右区间的节点值得到当前节点的节点值</span><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="区间查询的代码"><a href="#区间查询的代码" class="headerlink" title="区间查询的代码"></a>区间查询的代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start &lt;= root.start &amp;&amp; root.end &lt;= end) &#123;<br>        <span class="hljs-comment">// 如果查询区间在当前节点的区间之内,直接输出结果</span><br>        <span class="hljs-keyword">return</span> root.max;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (root.start + root.end) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 将当前节点区间分割为左右2个区间的分割线</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE; <span class="hljs-comment">// 给结果赋初值</span><br>    <span class="hljs-keyword">if</span> (mid &gt;= start) &#123;   <span class="hljs-comment">// 如果查询区间和左边节点区间有交集,则寻找查询区间在左边区间上的最大值</span><br>        ans = Math.max(ans, query(root.left, start, end));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt;= end) &#123; <span class="hljs-comment">// 如果查询区间和右边节点区间有交集,则寻找查询区间在右边区间上的最大值</span><br>        ans = Math.max(ans, query(root.right, start, end));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans; <span class="hljs-comment">// 返回查询结果</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="单点更新的代码"><a href="#单点更新的代码" class="headerlink" title="单点更新的代码"></a>单点更新的代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(SegmentTreeNode root, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root.start == root.end &amp;&amp; root.start == index) &#123; <span class="hljs-comment">// 找到被改动的叶子节点</span><br>        root.max = value; <span class="hljs-comment">// 改变value值</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (root.start + root.end) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 将当前节点区间分割为2个区间的分割线</span><br>    <span class="hljs-keyword">if</span>(index &lt;= mid)&#123; <span class="hljs-comment">// 如果index在当前节点的左边</span><br>        modify(root.left, index, value); <span class="hljs-comment">// 递归操作</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果index在当前节点的右边</span><br>        modify(root.right, index, value); <span class="hljs-comment">// 递归操作</span><br>    &#125;<br>    root.max = Math.max(root.left.max, root.right.max); <span class="hljs-comment">// 可能对当前节点的影响</span><br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="数组的实现"><a href="#数组的实现" class="headerlink" title="数组的实现"></a>数组的实现</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">NumArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>  <span class="hljs-type">int</span>[] seg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span> * n]; <span class="hljs-comment">// 一般去数组长度的四倍</span><br>  build(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, seg, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="构造代码-1"><a href="#构造代码-1" class="headerlink" title="构造代码"></a>构造代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// build segment tree, set the value of seg[idx]</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] seg, <span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start == end) &#123;<br>      seg[idx] = nums[start];<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;<br>    build(nums, start, mid, seg, <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>);<br>    build(nums, mid + <span class="hljs-number">1</span>, end, seg, <span class="hljs-number">2</span> * idx + <span class="hljs-number">2</span>);<br>    seg[idx] = seg[<span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>] + seg[<span class="hljs-number">2</span> * idx + <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="区间查询的代码-1"><a href="#区间查询的代码-1" class="headerlink" title="区间查询的代码"></a>区间查询的代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> queryStart, <span class="hljs-type">int</span> queryEnd, <span class="hljs-type">int</span>[] seg, <span class="hljs-type">int</span> idx)</span> &#123;<br>  <span class="hljs-keyword">if</span> (queryStart &lt;= start &amp;&amp; end &lt;= queryEnd) <span class="hljs-keyword">return</span> seg[idx];<br>  <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (mid &gt;= queryStart) &#123;<br>    ans += query(start, mid, queryStart, queryEnd, seg, <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt;= queryEnd) &#123;<br>    ans += query(mid + <span class="hljs-number">1</span>, end, queryStart, queryEnd, seg, <span class="hljs-number">2</span> * idx + <span class="hljs-number">2</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="单点更新的代码-1"><a href="#单点更新的代码-1" class="headerlink" title="单点更新的代码"></a>单点更新的代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> indexToBeUpdated, <span class="hljs-type">int</span> newVal, <span class="hljs-type">int</span>[] seg, <span class="hljs-type">int</span> idx)</span> &#123;<br>  <span class="hljs-keyword">if</span> (start == end) &#123;<br>    seg[idx] = newVal;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (indexToBeUpdated &lt;= mid) &#123;<br>    update(start, mid, indexToBeUpdated, newVal, seg, <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    update(mid + <span class="hljs-number">1</span>, end, indexToBeUpdated, newVal, seg, <span class="hljs-number">2</span> * idx + <span class="hljs-number">2</span>);<br>  &#125;<br>  seg[idx] = seg[<span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>] + seg[<span class="hljs-number">2</span> * idx + <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Lazy-Propagation-懒加载"><a href="#Lazy-Propagation-懒加载" class="headerlink" title="Lazy Propagation 懒加载"></a>Lazy Propagation 懒加载</h2><h3 id="区间懒更新"><a href="#区间懒更新" class="headerlink" title="区间懒更新"></a>区间懒更新</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// update [left, right] by val</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateLazySegTree</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> val)</span> &#123;<br>  <span class="hljs-keyword">if</span> (lazy[index] != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// this node is lazy</span><br>    seg[index] += (end - start + <span class="hljs-number">1</span>) * lazy[index]; <span class="hljs-comment">// update current node by removing laziness</span><br>    <span class="hljs-keyword">if</span> (start != end) &#123; <span class="hljs-comment">// update lazy[] for children nodes</span><br>      lazy[<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>] += lazy[index];<br>      lazy[<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>] += lazy[index];<br>    &#125;<br>    lazy[index] = <span class="hljs-number">0</span>; <span class="hljs-comment">// current node processed. No longer lazy</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (left &lt;= start &amp;&amp; end &lt;= right) &#123; <span class="hljs-comment">// segment is fully within update range</span><br>    seg[index] += (end - start + <span class="hljs-number">1</span>) * val; <span class="hljs-comment">// update segment</span><br>    <span class="hljs-keyword">if</span> (start != end) &#123; <span class="hljs-comment">// update lazy[] for children</span><br>      lazy[<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>] += val;<br>      lazy[<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>] += val;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>; <span class="hljs-comment">// recurse deeper for appropriate child</span><br><br>  <span class="hljs-keyword">if</span> (left &lt;= mid) &#123;<br>    updateLazySegTree(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, start, mid, left, right, val);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt;= right) &#123;<br>    updateLazySegTree(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, mid + <span class="hljs-number">1</span>, end, left, right, val);<br>  &#125;<br>  <span class="hljs-comment">// merge updates</span><br>  seg[index] = seg[<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>] + sef[<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="区间懒查询"><a href="#区间懒查询" class="headerlink" title="区间懒查询"></a>区间懒查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// query [left, right]</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">queryLazySegTree</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>  <span class="hljs-keyword">if</span> (lazy[index] != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// this node is lazy</span><br>    seg[index] += (end - start + <span class="hljs-number">1</span>) * lazy[index]; <span class="hljs-comment">// normalize current node by removing laziness</span><br>    <span class="hljs-keyword">if</span> (start != end) &#123; <span class="hljs-comment">// update lazy[] for children nodes</span><br>      lazy[<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>] += lazy[index];<br>      lazy[<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>] += lazy[index];<br>    &#125;<br>    lazy[index] = <span class="hljs-number">0</span>; <span class="hljs-comment">// current node processed. No longer lazy</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (left &lt;= start &amp;&amp; end &lt;= right) <span class="hljs-comment">// segment completely inside range</span><br>    <span class="hljs-keyword">return</span> seg[index];<br>  <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>; <span class="hljs-comment">// partial overlap of current segment and queried range. Recurse deeper.</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (left &lt;= mid)<br>    ans += queryLazySegTree(<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, start, mid, left, right);<br>  <span class="hljs-keyword">if</span> (mid+<span class="hljs-number">1</span> &lt;= right)<br>    ans += queryLazySegTree(<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, mid + <span class="hljs-number">1</span>, right, left, right);<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LC: 699</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>      Node l, r;<br>      <span class="hljs-type">int</span> val, lazy;<br>  &#125;<br>  <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>  <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">fallingSquares</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] positions)</span> &#123;<br>      List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] info : positions) &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> info[<span class="hljs-number">0</span>], h = info[<span class="hljs-number">1</span>], cur = query(root, <span class="hljs-number">0</span>, N, x, x + h - <span class="hljs-number">1</span>);<br>          update(root, <span class="hljs-number">0</span>, N, x, x + h - <span class="hljs-number">1</span>, cur + h);<br>          ans.add(root.val);<br>      &#125;<br>      <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>      <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      updateLazy(node, start, end);<br>      <span class="hljs-keyword">if</span> (left &lt;= start &amp;&amp; end &lt;= right) <span class="hljs-keyword">return</span> node.val;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (left &lt;= mid) &#123;<br>          <span class="hljs-keyword">if</span> (node.l == <span class="hljs-literal">null</span>)  &#123;<br>              node.l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>              node.l.val = node.val;<br>          &#125;<br>          ans = query(node.l, start, mid, left, right);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt;= right) &#123;<br>          <span class="hljs-keyword">if</span> (node.r == <span class="hljs-literal">null</span>)  &#123;<br>              node.r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>              node.r.val = node.val;<br>          &#125;<br>          ans = Math.max(ans, query(node.r, mid + <span class="hljs-number">1</span>, end, left, right));<br>      &#125;<br>      <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateLazy</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>      <span class="hljs-keyword">if</span> (node.lazy != <span class="hljs-number">0</span>) &#123;<br>          node.val = node.lazy;<br>          <span class="hljs-keyword">if</span> (start != end) &#123;<br>              <span class="hljs-keyword">if</span> (node.l != <span class="hljs-literal">null</span>) node.l.lazy = node.lazy;<br>              <span class="hljs-keyword">if</span> (node.r != <span class="hljs-literal">null</span>) node.r.lazy = node.lazy;<br>          &#125;<br>          node.lazy = <span class="hljs-number">0</span>;<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> newValue)</span> &#123;<br>      <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">if</span> (left &lt;= start &amp;&amp; end &lt;= right) &#123;<br>          node.val = newValue;<br>          node.lazy = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (node.l != <span class="hljs-literal">null</span>) node.l.lazy = newValue;<br>          <span class="hljs-keyword">if</span> (node.r != <span class="hljs-literal">null</span>) node.r.lazy = newValue;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (node.l == <span class="hljs-literal">null</span>) &#123;<br>          node.l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>          node.l.val = node.val;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (node.r == <span class="hljs-literal">null</span>) &#123;<br>          node.r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>          node.r.val = node.val;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (left &lt;= mid) &#123;<br>          update(node.l, start, mid, left, right, newValue);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt;= right) &#123;<br>          update(node.r, mid + <span class="hljs-number">1</span>, end, left, right, newValue);<br>      &#125;<br>      node.val = Math.max(node.l.val, node.r.val);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ul>
<li><a href="https://leetcode.com/problems/range-sum-query-immutable/">303. Range Sum Query - Immutable</a> Easy，拿来上手</li>
<li><a href="https://leetcode.com/problems/range-sum-query-mutable/">307. Range Sum Query - Mutable</a> 在上一提的代码基础上，加修改，Easy</li>
<li><a href="https://leetcode.cn/problems/range-addition/">370. Range Addition</a> 练手区间更新，建议在303的基础上修改，基础代码都一样，可以考虑去掉seg数组</li>
<li><a href="https://leetcode.com/problems/falling-squares/">699. Falling Squares</a> 练习对于值域范围不确定的处理技巧1:离散化 + 线段树，非强制在线：将值域映射到较小的空间，然后套用固定空间的线段树求解；2:动态开点</li>
<li><a href="https://leetcode.cn/problems/range-sum-query-2d-mutable/">308. Range Sum Query 2D - Mutable</a> 训练下思维转化，对于二维数组我们应该咋办……</li>
</ul>
<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul>
<li><a href="https://leetcode.com/problems/the-skyline-problem/">218. The Skyline Problem</a> &#x2F;&#x2F; todo: 没时间了，写一题实在是费老大劲了！放弃</li>
<li><a href="https://leetcode.com/problems/count-integers-in-intervals/">2276. Count Integers in Intervals</a></li>
<li><a href="https://leetcode.com/problems/amount-of-new-area-painted-each-day/">2158. Amount of New Area Painted Each Day</a></li>
<li><a href="https://leetcode.cn/problems/my-calendar-iii/">732. My Calendar III</a></li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://leetcode.com/articles/a-recursive-approach-to-segment-trees-range-sum-queries-lazy-propagation/">Recursive Approach to Segment Trees</a></li>
<li><a href="https://seramasumi.github.io/docs/Algorithms/mc-%E5%BE%AE%E8%AF%BE%E5%A0%82-%E7%BA%BF%E6%AE%B5%E6%A0%91_Segment_Tree.html">线段树 by Sera Masumi??</a></li>
<li><a href="https://www.jianshu.com/p/91f2c503e62f">Segment Tree 线段树 原理及实现</a></li>
<li><a href="https://maratona.ic.unicamp.br/MaratonaVerao2016/material/segment_tree_lecture.pdf">Segment tree - Theory and applications</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247491187&idx=2&sn=bb2d8b7e89c535914da8107387e951a2">【线段树专题】求解常见「值域爆炸，查询有限」区间问题的几种方式</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Understanding Bitwise Operators</title>
    <url>/tech/understanding-bitwise-operators/</url>
    <content><![CDATA[<ul>
<li>&amp; (bitwise AND)</li>
<li>| (bitwise OR)</li>
<li>~ (bitwise NOT)</li>
<li>^ (bitwise XOR)</li>
<li>&lt;&lt; (bitwise left shift)</li>
<li>&gt;&gt; (bitwise right shift)</li>
<li>&gt;&gt;&gt; (bitwise unsigned right shift)</li>
<li>&amp;&#x3D; (bitwise AND assignment)</li>
<li>|&#x3D; (bitwise OR assignment)</li>
<li>^&#x3D; (bitwise XOR assignment)</li>
<li>&lt;&lt;&#x3D; (bitwise left shift and assignment)</li>
<li>&gt;&gt;&#x3D; (bitwise right shift and assignment)</li>
<li>&gt;&gt;&gt;&#x3D; (bitwise unsigned right shift and assignment)</li>
</ul>
<h1 id="与"><a href="#与" class="headerlink" title="&amp; 与"></a>&amp; 与</h1><p>0 &amp; 0 &#x3D; 0<br>0 &amp; 1 &#x3D; 0<br>1 &amp; 1 &#x3D; 1<br>与1在一起，保留自己，与0(您)一起，奉献一生</p>
<p>Usage: 奇偶检查</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> randInt = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">if</span>(randInt &amp; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-title function_">trace</span>(<span class="hljs-string">&quot;Odd number.&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-title function_">trace</span>(<span class="hljs-string">&quot;Even number.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="或"><a href="#或" class="headerlink" title="| 或"></a>| 或</h1><p>0 | 0 &#x3D; 0<br>0 | 1 &#x3D; 1<br>1 | 1 &#x3D; 1<br>或1变1，或0(您)还是自己</p>
<p>Usage: 条件判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> option1 = <span class="hljs-number">1</span>, option2 = <span class="hljs-number">2</span>, option3 = <span class="hljs-number">4</span>, option4 = <span class="hljs-number">8</span>; <br><br><span class="hljs-keyword">var</span> determineConditions = <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-keyword">if</span> (options &amp; option1) &#123;<br>    <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;option1&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (options &amp; option2) &#123;<br>    <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;option2&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (options &amp; option3) &#123;<br>    <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;option3&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (options &amp; option4) &#123;<br>    <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;option4&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">determineConditions</span>(option1 | option3);<br></code></pre></td></tr></table></figure>

<h1 id="非"><a href="#非" class="headerlink" title="~ 非"></a>~ 非</h1><p>~0 &#x3D; 1<br>~1 &#x3D; 0</p>
<p>Usage: 补数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">37</span>, cnum = ~num + <span class="hljs-number">1</span>; <br><span class="hljs-title function_">log</span>(cnum + num === <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<h1 id="异或"><a href="#异或" class="headerlink" title="^ 异或"></a>^ 异或</h1><p>0 ^ 0 &#x3D; 0<br>0 ^ 1 &#x3D; 1<br>1 ^ 1 &#x3D; 0</p>
<p>Properties:</p>
<ul>
<li>0 ^ N &#x3D; N, N ^ N &#x3D; 0</li>
<li>交换律和结合律: a ^ b &#x3D; b ^ a, a ^ b ^ c &#x3D; a ^ (b ^ c)</li>
</ul>
<p>Usage: </p>
<ul>
<li>交换两个数<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">a = a ^ b;<br>b = a ^ b;<br>a = a ^ b; <span class="hljs-comment">// a, b 值交换</span><br></code></pre></td></tr></table></figure></li>
<li><a href="https://leetcode.com/problems/single-number/">Single Number</a><br>Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">nums.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">n,a</span>) =&gt;</span> a^n, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="左移"><a href="#左移" class="headerlink" title="&lt;&lt; 左移"></a>&lt;&lt; 左移</h1><p>a &lt;&lt; b is shifting the number a to the left by b places, and add 0 to the last b position<br>a &lt;&lt; b &#x3D;&#x3D; a * Math.pow(2,b)</p>
<p>Usage: 乘以2的倍数</p>
<h1 id="右移"><a href="#右移" class="headerlink" title="&gt;&gt; 右移"></a>&gt;&gt; 右移</h1><p>a &gt;&gt; b is shifting the number a to the right by b places, and add 0 to the last b position<br>a &gt;&gt; b &#x3D;&#x3D; a &#x2F; Math.pow(2,b)</p>
<h1 id="无符号右移，逻辑右移"><a href="#无符号右移，逻辑右移" class="headerlink" title="&gt;&gt;&gt; 无符号右移，逻辑右移"></a>&gt;&gt;&gt; 无符号右移，逻辑右移</h1><p>a &gt;&gt;&gt; b is shifting the number a to the right by b places, and add 0 to position.</p>
<h1 id="其他常见技巧"><a href="#其他常见技巧" class="headerlink" title="其他常见技巧"></a>其他常见技巧</h1><h2 id="n-n-1"><a href="#n-n-1" class="headerlink" title="n &amp; (n-1)"></a>n &amp; (n-1)</h2><p>移除二进制数n中最低位的1</p>
<blockquote>
<p>假设 n 的二进制表示为：a10⋯0，其中 a 表示若干个高位，1 表示最低位的1，0⋯0 表示后面的若干个0，那么 n-1 的二进制表示为：a01⋯1，将 a10⋯0 与 a01⋯1 进行按位与运算，高位 a 不变，在这之后的所有位都会变为0，这样我们就将最低位的那个1移除了。</p>
</blockquote>
<p>练习：</p>
<ul>
<li><a href="https://leetcode.com/problems/number-of-1-bits/">191. Number of 1 Bits</a></li>
</ul>
<h2 id="n-n-n-n-1"><a href="#n-n-n-n-1" class="headerlink" title="n &amp; (-n) &#x2F; n &amp; (~n + 1)"></a>n &amp; (-n) &#x2F; n &amp; (~n + 1)</h2><p>直接获取n二进制表示的最低位的1</p>
<blockquote>
<p>假设 n 的二进制表示为：a10⋯0，其中 a 表示若干个高位，1 表示最低位的1，0⋯0 表示后面的若干个0，那么 -n 的二进制表示为：(ā01⋯1)+(1) &#x3D; (ā10⋯0)，将 a10⋯0 与 ā10⋯0 进行按位与运算，高位全部变为0，最低位的1以及之后的所有0不变，这样我们就获取了n二进制表示的最低位的1。</p>
</blockquote>
<h1 id="更多练习"><a href="#更多练习" class="headerlink" title="更多练习"></a>更多练习</h1><h2 id="EASY"><a href="#EASY" class="headerlink" title="EASY"></a>EASY</h2><ul>
<li><a href="https://leetcode.com/problems/reverse-bits/">190. Reverse Bits</a></li>
<li><a href="https://leetcode.com/problems/power-of-two/">231. Power of Two</a></li>
<li><a href="https://leetcode.com/problems/sum-of-two-integers/">371. Sum of Two Integers</a></li>
</ul>
<p><a href="https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary%3A-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently">https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary%3A-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently</a></p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Union-Find Set / Disjoint Set Union 并查集介绍</title>
    <url>/tech/union-find-set/</url>
    <content><![CDATA[<h1 id="开篇废话"><a href="#开篇废话" class="headerlink" title="开篇废话"></a>开篇废话</h1><p>数据结构「并查集」（Union-Find），也称「不相交集合」（Disjoin-Sets）挺火的，刷题的时候一直遇到，刷到必是medium以上。本身原理并不复杂，就是实现代码稍微多了点。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img  src="/../../../../../pics/tech/ufs/union-find.png"  ><span class="image-caption">并查集主要知识点导图</span></p>
<h1 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h1><h2 id="并-Union"><a href="#并-Union" class="headerlink" title="并 Union"></a>并 Union</h2><p>把两个集合合并成一个集合，表示这两个集合之间产生连接</p>
<h2 id="查-Find"><a href="#查-Find" class="headerlink" title="查 Find"></a>查 Find</h2><p>查询元素属于哪个集合</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><p>代码基本框架如下，对于<code>find</code>和<code>union</code>下面会介绍不同的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-type">int</span>[] root;<br><br>    UnionFind(<span class="hljs-type">int</span> size) &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            root[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> root[x];<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-comment">// join x and y</span><br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">connected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(x) == find(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Quick-Find-实现"><a href="#Quick-Find-实现" class="headerlink" title="Quick Find 实现"></a>Quick Find 实现</h2><p>此实现重点在于超快速<code>find</code>方法，时间复杂度在O(1)，而对于<code>union</code>时间复杂度是O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFindQuickFind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    UnionFindQuickFind(<span class="hljs-type">int</span> size) &#123;<br>        <span class="hljs-built_in">super</span>(size);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> root[x];<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootX</span> <span class="hljs-operator">=</span> find(x), rootY = find(y);<br>        <span class="hljs-keyword">if</span> (rootX != rootY) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; root.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (root[i] == rootY) &#123;<br>                    root[i] = rootX;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Quick-Union-实现"><a href="#Quick-Union-实现" class="headerlink" title="Quick Union 实现"></a>Quick Union 实现</h2><p>此实现是最常用的版本，其他的优化也是基于此版本<br>虽然提高了<code>find</code>方法的时间复杂度，但平均了<code>union</code>的时间复杂度，总体效率会高于<em>Quick Find</em>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFindQuickUnion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    UnionFindQuickUnion(<span class="hljs-type">int</span> size) &#123;<br>        <span class="hljs-built_in">super</span>(size);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x != root[x]) &#123;<br>            x = root[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootX</span> <span class="hljs-operator">=</span> find(x), rootY = find(y);<br>        <span class="hljs-keyword">if</span> (rootX != rootY) &#123;<br>            root[rootY] = rootX;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="按秩合并优化-实现"><a href="#按秩合并优化-实现" class="headerlink" title="按秩合并优化 实现"></a>按秩合并优化 实现</h2><p>针对<code>union</code>操作的优化，在<code>union</code>操作时，根据约定的秩序从两个根节点中选择新的根结点</p>
<h3 id="标准按秩，按当前树的高度合并"><a href="#标准按秩，按当前树的高度合并" class="headerlink" title="标准按秩，按当前树的高度合并"></a>标准按秩，按当前树的高度合并</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFindOptimizationByRank</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnionFindQuickUnion</span> &#123;<br>    <span class="hljs-type">int</span>[] rank; <span class="hljs-comment">// 新增rank数组， 存放当前root树的高度</span><br>    UnionFindOptimizationByRank(<span class="hljs-type">int</span> size) &#123;<br>        <span class="hljs-built_in">super</span>(size);<br>        rank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>        Arrays.fill(rank, <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化，人人平等</span><br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootX</span> <span class="hljs-operator">=</span> find(x), rootY = find(y);<br>        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;<br>            root[rootY] = rootX;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[rootY] &gt; rank[rootX]) &#123;<br>            root[rootX] = rootY;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root[rootY] = rootX;<br>            rank[rootX]++; <span class="hljs-comment">// 增加高度</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="人多势众，按当前集合元素数量合并"><a href="#人多势众，按当前集合元素数量合并" class="headerlink" title="人多势众，按当前集合元素数量合并"></a>人多势众，按当前集合元素数量合并</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFindOptimizationByCount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnionFindQuickUnion</span> &#123;<br>    <span class="hljs-type">int</span>[] count;<br>    UnionFindOptimizationByCount(<span class="hljs-type">int</span> size) &#123;<br>        <span class="hljs-built_in">super</span>(size);<br>        count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>        Arrays.fill(count, <span class="hljs-number">1</span>); <span class="hljs-comment">// 初始化，人人平等</span><br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootX</span> <span class="hljs-operator">=</span> find(x), rootY = find(y);<br>        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCount</span> <span class="hljs-operator">=</span> count[rootX] + count[rootY];<br>        <span class="hljs-keyword">if</span> (count[rootX] &gt; count[rootY]) &#123;<br>            root[rootY] = rootX;<br>            count[rootX] = newCount;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root[rootX] = rootY;<br>            count[rootY] = newCount;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="路径压缩优化-实现"><a href="#路径压缩优化-实现" class="headerlink" title="路径压缩优化 实现"></a>路径压缩优化 实现</h2><p>针对<code>find</code>操作的优化，在<code>find</code>操作时，压缩已查找的路径，具体实现有两种，差距不大</p>
<h3 id="完全压缩（递归）"><a href="#完全压缩（递归）" class="headerlink" title="完全压缩（递归）"></a>完全压缩（递归）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFindOptimizationPathUpdateComplete</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnionFindQuickUnion</span> &#123;<br>    UnionFindOptimizationPathUpdateComplete(<span class="hljs-type">int</span> size) &#123;<br>        <span class="hljs-built_in">super</span>(size);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == root[x]) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root[x] = find(root[x]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="隔代压缩（循环）"><a href="#隔代压缩（循环）" class="headerlink" title="隔代压缩（循环）"></a>隔代压缩（循环）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFindOptimizationPathUpdateGap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnionFindQuickUnion</span> &#123;<br>    UnionFindOptimizationPathUpdateGap(<span class="hljs-type">int</span> size) &#123;<br>        <span class="hljs-built_in">super</span>(size);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x != root[x]) &#123;<br>            root[x] = root[root[x]];<br>            x = root[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="终极优化-版本"><a href="#终极优化-版本" class="headerlink" title="终极优化 版本"></a>终极优化 版本</h2><p>注：这里存在个人偏见<br>路径压缩优化后是否还需要按秩合并存在一丢丢的争议，读者可自行斟酌</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFindFinal</span> &#123;<br>    <span class="hljs-type">int</span>[] root;<br>    <span class="hljs-type">int</span>[] count;<br>    UnionFindFinal(<span class="hljs-type">int</span> size) &#123;<br>        count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>        Arrays.fill(count, <span class="hljs-number">1</span>);<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            root[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x != root[x]) &#123;<br>            root[x] = root[root[x]];<br>            x = root[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootX</span> <span class="hljs-operator">=</span> find(x), rootY = find(y);<br>        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCount</span> <span class="hljs-operator">=</span> count[rootX] + count[rootY];<br>        <span class="hljs-keyword">if</span> (count[rootX] &gt; count[rootY]) &#123;<br>            root[rootY] = rootX;<br>            count[rootX] = newCount;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root[rootX] = rootY;<br>            count[rootY] = newCount;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">connected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(x) == find(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>Time Complexity:  O(Nα(N)) ≈ O(N), where N is the number of vertices (and also the number of edges) in the graph, and α(N) is the Inverse-Ackermann function. We make up to N queries of dsu.union, which takes (amortized) O(α(N)) time.</p>
<p>Space Complexity: O(N)</p>
<h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol>
<li>通过一些方法将自定义类型转为整型后使用并查集（e.g. 生成哈希值；二维变一维）</li>
<li>使用链表 + 映射（Map）</li>
<li>使用桩，stub</li>
</ol>
<h2 id="My-Favorite"><a href="#My-Favorite" class="headerlink" title="My Favorite"></a>My Favorite</h2><ul>
<li><a href="https://leetcode.com/problems/count-servers-that-communicate/">1267. Count Servers that Communicate</a> (这题特别好，开眼界了，除了基本的使用方法，点和点join之外，还可以自己和自己join)</li>
<li><a href="https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/">947. Most Stones Removed with Same Row or Column</a> (同理上一题)</li>
</ul>
<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><ul>
<li><a href="https://leetcode.com/problems/number-of-provinces/">547. Number of Provinces</a> (加岛屿计数器)</li>
<li><a href="https://leetcode.com/problems/redundant-connection/">684. Redundant Connection</a> (<code>unique</code>二用)</li>
<li><a href="https://leetcode.com/problems/longest-consecutive-sequence/">128. Longest Consecutive Sequence</a> (+size数组)</li>
<li><a href="https://leetcode.com/problems/graph-valid-tree/">261. Graph Valid Tree</a> (+count)</li>
<li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph">323. Number of Connected Components in an Undirected Graph</a> (+count)</li>
<li><a href="https://leetcode.com/problems/max-area-of-island/">695. Max Area of Island</a> (+size数组)</li>
<li><a href="https://leetcode.com/problems/sentence-similarity-ii">737. Sentence Similarity II</a></li>
<li><a href="https://leetcode.com/problems/similar-string-groups/">839. Similar String Groups</a></li>
<li><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/">990. Satisfiability of Equality Equations</a></li>
<li><a href="https://leetcode.com/problems/lexicographically-smallest-equivalent-string/">1061. Lexicographically Smallest Equivalent String</a></li>
<li><a href="https://leetcode.com/problems/number-of-enclaves">1020. Number of Enclaves</a> (+stub)</li>
<li><a href="https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/">1101. The Earliest Moment When Everyone Become Friends</a></li>
<li><a href="https://leetcode.com/problems/synonymous-sentences/">1258. Synonymous Sentences</a></li>
<li><a href="https://leetcode.com/problems/graph-connectivity-with-threshold/">1627. Graph Connectivity With Threshold</a></li>
<li><a href="https://leetcode.com/problems/validate-binary-tree-nodes/">1361. Validate Binary Tree Nodes</a></li>
<li><a href="https://leetcode.com/problems/number-of-operations-to-make-network-connected/">1319. Number of Operations to Make Network Connected</a></li>
<li><a href="https://leetcode.com/problems/detect-cycles-in-2d-grid/">1559. Detect Cycles in 2D Grid</a></li>
<li><a href="https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/">1579. Remove Max Number of Edges to Keep Graph Fully Traversable</a></li>
<li><a href="https://leetcode.com/problems/count-sub-islands/">1905. Count Sub Islands</a></li>
<li><a href="https://leetcode-cn.com/problems/YesdPw/">LCS 03. 主题空间</a></li>
<li><a href="https://leetcode.com/problems/connecting-cities-with-minimum-cost/">1135. Connecting Cities With Minimum Cost</a></li>
</ul>
<h2 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h2><ul>
<li><a href="https://leetcode.com/problems/number-of-islands/">200. Number of Islands</a> (扁平化，降维，2D变1D)</li>
<li><a href="https://leetcode.com/problems/surrounded-regions/">130. Surrounded Regions</a> (扁平化; 特殊占位)</li>
<li><a href="https://leetcode.com/problems/accounts-merge/">721. Accounts Merge</a> (Map?)</li>
<li><a href="https://leetcode.com/problems/making-a-large-island/">827. Making A Large Island</a></li>
<li><a href="https://leetcode.com/problems/possible-bipartition">886. Possible Bipartition</a> (Map? 算是一种变体吧？想解法还是想了一会儿的)</li>
<li><a href="https://leetcode.com/problems/minimize-malware-spread/">924. Minimize Malware Spread</a> (难的是计算的部分，ufs本身还是很straightforward的)</li>
<li><a href="https://leetcode.com/problems/minimize-malware-spread-ii/">928. Minimize Malware Spread II</a> (上一题的变体)</li>
<li><a href="https://leetcode.com/problems/smallest-string-with-swaps/">1202. Smallest String With Swaps</a></li>
<li><a href="https://leetcode.com/problems/number-of-closed-islands/">1254. Number of Closed Islands</a> (54SB, 很拙劣地做出了这道题，双%5，战五渣)</li>
<li><a href="https://leetcode.com/problems/min-cost-to-connect-all-points">1584. Min Cost to Connect All Points</a></li>
<li><a href="https://leetcode.com/problems/path-with-minimum-effort/">1631. Path With Minimum Effort</a></li>
<li><a href="https://leetcode.com/problems/minimize-hamming-distance-after-swap-operations/">1722. Minimize Hamming Distance After Swap Operations</a></li>
<li><a href="https://leetcode.com/problems/last-day-where-you-can-still-cross/">1970. Last Day Where You Can Still Cross</a></li>
<li><a href="https://leetcode.com/problems/process-restricted-friend-requests/">2076. Process Restricted Friend Requests</a> (加一个restrictions map)</li>
<li><a href="https://leetcode.com/problems/find-all-people-with-secret/">2092. Find All People With Secret</a> (思考isolate)</li>
</ul>
<h2 id="魔鬼"><a href="#魔鬼" class="headerlink" title="魔鬼"></a>魔鬼</h2><ul>
<li><a href="https://leetcode.com/problems/number-of-islands-ii">305. Number of Islands II</a> (corner cases折磨人：数组元素重复；land count有增有减)</li>
<li><a href="https://leetcode.com/problems/evaluate-division/">399. Evaluate Division</a> (数学题)</li>
<li><a href="https://leetcode.com/problems/redundant-connection-ii/">685. Redundant Connection II</a></li>
<li><a href="https://leetcode.com/problems/largest-component-size-by-common-factor/">952. Largest Component Size by Common Factor</a> </li>
<li><a href="https://leetcode.com/problems/regions-cut-by-slashes/">959. Regions Cut By Slashes</a></li>
</ul>
<h2 id="偷看答案"><a href="#偷看答案" class="headerlink" title="偷看答案"></a>偷看答案</h2><ul>
<li><a href="https://leetcode.com/problems/is-graph-bipartite/">785. Is Graph Bipartite?</a></li>
<li><a href="https://leetcode.com/problems/bricks-falling-when-hit/">803. Bricks Falling When Hit</a></li>
<li><a href="https://leetcode.com/problems/optimize-water-distribution-in-a-village/">1168. Optimize Water Distribution in a Village</a></li>
<li><a href="https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/">1697. Checking Existence of Edge Length Limited Paths</a></li>
<li><a href="https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths-ii/">1724. Checking Existence of Edge Length Limited Paths II</a></li>
</ul>
<h2 id="未解之谜"><a href="#未解之谜" class="headerlink" title="未解之谜"></a>未解之谜</h2><ul>
<li><a href="https://leetcode.com/problems/number-of-distinct-islands/">694. Number of Distinct Islands</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-distinct-islands-ii/">711. Number of Distinct Islands II</a></li>
<li><a href="https://leetcode.com/problems/couples-holding-hands/">765. Couples Holding Hands</a> (我想不明白，玄学)</li>
<li><a href="https://leetcode.com/problems/swim-in-rising-water/">778. Swim in Rising Water</a></li>
<li><a href="https://leetcode.com/problems/path-with-maximum-minimum-value/">1102. Path With Maximum Minimum Value</a></li>
<li><a href="https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/">1391. Check if There is a Valid Path in a Grid</a></li>
<li><a href="https://leetcode.com/problems/rank-transform-of-a-matrix/">1632. Rank Transform of a Matrix</a></li>
<li><a href="https://leetcode.com/problems/gcd-sort-of-an-array">1998. GCD Sort of an Array</a></li>
<li><a href="https://leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree/">2003. Smallest Missing Genetic Value in Each Subtree</a></li>
</ul>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul>
<li><a href="https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/">1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</a></li>
<li><a href="https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/">1569. Number of Ways to Reorder Array to Get Same BST</a></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://leetcode-cn.com/leetbook/read/graph/r340gv/">LeetBook《图》</a></li>
<li><a href="https://github.com/Liu821218213/LeetCode-Orust/blob/master/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93.md">Liu821218213的并查集总结</a></li>
<li><a href="https://segmentfault.com/a/1190000022952886">HYN的技术笔记</a></li>
<li><a href="https://www.liwei.party/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/page/2/">liweiwei的网站</a></li>
<li><a href="https://leetcode-cn.com/tag/union-find/problemset/">Leetcode题目合集</a></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论第二章读书笔记</title>
    <url>/tech/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight js"><figcaption><span>伪代码</span></figcaption><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">INSERTION</span>-<span class="hljs-title function_">SORT</span>(A)<br><span class="hljs-keyword">for</span> j=<span class="hljs-number">2</span> to A.<span class="hljs-property">length</span><br>  key = A[j]<br>  <span class="hljs-comment">//insert A[j] into the sortes sequence A[1...j-1]</span><br>  i = j-<span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> i&gt;<span class="hljs-number">0</span> and A[i]&gt;key<br>    A[i+<span class="hljs-number">1</span>] = A[i]<br>    i = i-<span class="hljs-number">1</span><br>  A[i+<span class="hljs-number">1</span>] = key<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><figcaption><span>javascript实现</span></figcaption><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertion_sort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> key = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) &#123;<br>    key = arr[j];<br>    i = j - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[i] &gt; key) &#123;<br>      arr[i+<span class="hljs-number">1</span>] = arr[i];<br>      i = i - <span class="hljs-number">1</span>;<br>    &#125;<br>    arr[i+<span class="hljs-number">1</span>] = key;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="循环不变式"><a href="#循环不变式" class="headerlink" title="循环不变式"></a>循环不变式</h2><p><strong>初始化</strong>：循环第一次迭代之前，它为真<br><strong>保持</strong>：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真<br><strong>终止</strong>：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的  </p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><table>
<thead>
<tr>
<th align="left">INSERTION-SORT(A)</th>
<th align="left">代价</th>
<th align="left">次数</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>for j=2 to A.length</code></td>
<td align="left">c1</td>
<td align="left">n</td>
</tr>
<tr>
<td align="left"><code>  key = A[j]</code></td>
<td align="left">c2</td>
<td align="left">n-1</td>
</tr>
<tr>
<td align="left"><code>  //insert A[j] into the sortes sequence A[1...j-1]</code></td>
<td align="left">0</td>
<td align="left">n-1</td>
</tr>
<tr>
<td align="left"><code>  i = j-1</code></td>
<td align="left">c4</td>
<td align="left">n-1</td>
</tr>
<tr>
<td align="left"><code>  while i&gt;0 and A[i]&gt;key</code></td>
<td align="left">c5</td>
<td align="left">∑tj (2&lt;&#x3D;j&lt;&#x3D;n)</td>
</tr>
<tr>
<td align="left"><code>  A[i+1] = A[i]</code></td>
<td align="left">c6</td>
<td align="left">∑(tj - 1) (2&lt;&#x3D;j&lt;&#x3D;n)</td>
</tr>
<tr>
<td align="left"><code>  i = i-1</code></td>
<td align="left">c7</td>
<td align="left">∑(tj - 1) (2&lt;&#x3D;j&lt;&#x3D;n)</td>
</tr>
<tr>
<td align="left"><code>  A[i+1] = key</code></td>
<td align="left">c8</td>
<td align="left">n-1</td>
</tr>
</tbody></table>
<p>tj 表示对那个值j第5行执行while循环测试的次数<br>所以，T(n) &#x3D; c1n + c2(n-1) + c4(n-1) + c5∑tj (2&lt;&#x3D;j&lt;&#x3D;n) + c6∑(tj - 1) (2&lt;&#x3D;j&lt;&#x3D;n) + c7∑(tj - 1) (2&lt;&#x3D;j&lt;&#x3D;n) + c8(n-1)<br><strong>最佳情况</strong>：对j&#x3D;2, 3, …, n，有tj &#x3D; 1，所以 T(n) &#x3D; (c1 + c2 + c4 + c5 +c8)n - (c2 + c4 + c5 + c8) &#x3D; Θ(n)<br><strong>最坏情况</strong>：对j&#x3D;2, 3, …, n，有tj &#x3D; j，所以 ∑tj (2&lt;&#x3D;j&lt;&#x3D;n) &#x3D; ∑j (2&lt;&#x3D;j&lt;&#x3D;n) &#x3D; n(n+1)&#x2F;2 - 1,  ∑(tj - 1) (2&lt;&#x3D;j&lt;&#x3D;n) &#x3D; n(n-1)&#x2F;2, T(n) &#x3D; (c5 + c6 + c7)n^2&#x2F;2 + (c1 + c2 + c4 + c5&#x2F;2 - c6&#x2F;2 - c7&#x2F;2 + c8)n - (c2 + c4 + c5 + c8) &#x3D; Θ(n^2)  </p>
<h1 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h1><h2 id="分治模式"><a href="#分治模式" class="headerlink" title="分治模式"></a>分治模式</h2><p>分治模式在每层递归时都有三个步骤：<br><strong>分解</strong>原问题为若干个子问题，这些字问题是原问题的规模较小的实例。<br><strong>解决</strong>这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。<br><strong>合并</strong>这些子问题的解成原问题的解。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序算法完全遵循分治模式。直观上其操作如下：<br><strong>分解</strong>：分解待排序的n个元素的序列成各具n&#x2F;2个元素的两个子序列。<br><strong>解决</strong>：使用归并排序递归地排序两个子序列。<br><strong>合并</strong>：合并两个已排序的子序列以产生已排序的答案。</p>
<p>通过调用一个辅助过程MERGE(A, p, q, r)来完成两个已排序序列的合并，其中A是一个数组，p、q和r是数组下标，满足 p&lt;&#x3D;q&lt;r。该过程假设子数组A[p..q]和A[q+1..r]都已排好序。它合并两个子数组形成单一的已排好序的子数组并代替当前的子数组A[p..r]。</p>
<figure class="highlight js"><figcaption><span>伪代码</span></figcaption><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">MERGE</span>(A, p, q, r)<br>  n1 = q - p + <span class="hljs-number">1</span><br>  n2 = r - q<br>  <span class="hljs-title class_">Let</span> L[<span class="hljs-number">1.</span>.<span class="hljs-property">n1</span>+<span class="hljs-number">1</span>] and R[<span class="hljs-number">1.</span>.<span class="hljs-property">n2</span>+<span class="hljs-number">1</span>] be <span class="hljs-keyword">new</span> arrays<br>  <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to n1<br>    L[i] = A[p + i - <span class="hljs-number">1</span>]<br>  <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to n2<br>    R[j] = A[q+j]<br>  <span class="hljs-comment">//插入哨兵牌</span><br>  L[n1 + <span class="hljs-number">1</span>] = ∞<br>  R[n2 + <span class="hljs-number">1</span>] = ∞<br>  i = <span class="hljs-number">1</span><br>  j = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span> k = p to r<br>    <span class="hljs-keyword">if</span> L[i] &lt;= R[j]<br>      A[k] = L[i]<br>      i = i + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span> A[k] = R[j]<br>      j = j + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">MERGE</span>-<span class="hljs-title function_">SORT</span>(A, p, r)<br><span class="hljs-keyword">if</span> p &lt; r<br>  q = └(p + r)/<span class="hljs-number">2</span>┘<br>  <span class="hljs-variable constant_">MERGE</span>-<span class="hljs-title function_">SORT</span>(A, p, q)<br>  <span class="hljs-variable constant_">MERGE</span>-<span class="hljs-title function_">SORT</span>(A, q + <span class="hljs-number">1</span>, r)<br>  <span class="hljs-title function_">MERGE</span>(A, p, q, r)<br></code></pre></td></tr></table></figure>

<h2 id="分析分治算法"><a href="#分析分治算法" class="headerlink" title="分析分治算法"></a>分析分治算法</h2><p>分治算法运行时间的递归式来自基本模式的单个步骤。假设T(n)是规模为n的一个问题的运行时间。若问题规模足够小，如对某个常量c，n&lt;&#x3D;c，则直接求解需要常量时间，将其记作Θ(1)。假设把原问题分解成a个子问题，每个子问题的规模是原问题的1&#x2F;b。为了求解一个规模为n&#x2F;b的子问题，需要T(n&#x2F;b)的时间，所以，需要aT(n&#x2F;b)的时间来求解a个子问题，如果分解问题成子问题需要时间D(n)，合并子问题的解成原问题的解需要C(n)，那么得到递归式：<br>若n&lt;&#x3D;c，T(n) &#x3D; Θ(1)；其他，T(n) &#x3D; aT(n&#x2F;b) + D(n) + C(n)  </p>
<p>所以，归并排序的最坏情况运行时间T(n)的递归式：<br>若n&#x3D;1，T(n) &#x3D; Θ(1)；若n&gt;1，T(n) &#x3D; 2T(n&#x2F;2) + Θ(n)<br>等价于：若n&#x3D;1，T(n) &#x3D; c；若n&gt;1，T(n) &#x3D; 2T(n&#x2F;2) +  cn<br>对递归式T(n) &#x3D; 2T(n&#x2F;2) +  cn构造递归树，如下：<br>所以，T(n) &#x3D; Θ(nlgn)</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>2.1-2 重写INSERTION-SORT，使之按非升序排列</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">INSERTION</span>-<span class="hljs-title class_">SORT2</span>(A)<br><span class="hljs-keyword">for</span> j=<span class="hljs-number">2</span> to A.<span class="hljs-property">length</span><br>  key = A[j]<br>  i = j-<span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span> and A[i] &lt; key<br>    A[i+<span class="hljs-number">1</span>] = A[i]<br>    i = i-<span class="hljs-number">1</span><br>  A[i+<span class="hljs-number">1</span>] = key<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertion_sort2</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> key = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) &#123;<br>    key = arr[j];<br>    i = j - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[i] &lt; key) &#123;<br>      arr[i+<span class="hljs-number">1</span>] = arr[i];<br>      i = i - <span class="hljs-number">1</span>;<br>    &#125;<br>    arr[i+<span class="hljs-number">1</span>] = key;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2.1-3 考虑一下查找问题：<br>输入：n个数的一个序列 A&#x3D;&lt;a1, a2, …, an&gt; 和一个值v<br>输出：下标i是的 v&#x3D;A[i] 或者当v不在A中出现时，v为特殊值NIL<br>写出<em>线性查找</em>的伪代码，它扫描整个序列来查找v。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要的性质。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">LINEAR</span>-<span class="hljs-title function_">SEARCH</span>(A, v)<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to A.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">if</span> A[i] equals v<br>    <span class="hljs-keyword">return</span> i<br><span class="hljs-keyword">return</span> <span class="hljs-variable constant_">NIL</span><br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">linear_search</span>(<span class="hljs-params">arr, v</span>) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] === v) &#123;<br>      <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2.1-4 考虑把两个n位二进制整数加起来的问题，这两个整数分别存储在两个n元数组A和B中。这两个整数的和应按二进制形式存储在一个(n+1)元数组C中。请给出该问题的形式化描述，并写出伪代码。<br>输入：两个n元数组A和B<br>输出：一个(n+1)元数组C  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">BINARY</span>-<span class="hljs-title function_">ADD</span>(A, B)<br><span class="hljs-keyword">for</span> i=A.<span class="hljs-property">length</span> to <span class="hljs-number">1</span><br>    tmp = A[i] + B[i] + tmp;<br>  <span class="hljs-keyword">if</span> tmp &gt; <span class="hljs-number">1</span><br>    C[i+<span class="hljs-number">1</span>] = tmp - <span class="hljs-number">2</span><br>    tmp = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">else</span> C[i+<span class="hljs-number">1</span>] = tmp<br>        tmp = <span class="hljs-number">0</span><br>C[<span class="hljs-number">1</span>] = tmp      <br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binary_add</span>(<span class="hljs-params">arr1, arr2</span>) &#123;<br>  <span class="hljs-keyword">var</span> arr3 = [];<br>  <span class="hljs-keyword">var</span> tmp = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = arr1.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    tmp = arr1[i] + arr2[i] + tmp;<br>    <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">1</span>) &#123;<br>      arr3[i+<span class="hljs-number">1</span>] = tmp - <span class="hljs-number">2</span>;<br>      tmp = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      arr3[i+<span class="hljs-number">1</span>] = tmp;<br>      tmp = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  arr3[<span class="hljs-number">0</span>] = tmp;<br>  <span class="hljs-keyword">return</span> arr3;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2.2-1 用Θ记号表示函数n^3&#x2F;1000-100n^2-100n+3<br>Θ(n^3)</p>
<p>2.2-2 考虑排序存储在数组A中的n个数：首先找出A中的最小元素并将其与A[1]中的元素进行交换。接着，找出A中的次最小元素并将其与A[2]中的元素进行交换。对A中前n-1个元素按该方式继续。这算法称为<em>选择算法</em>，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前n-1个元素，而不是对所有n个元素运行？用Θ记号给出选择排序的最好情况与最坏情况运行时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">SELECTION</span>(A)<br><span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span> to A.<span class="hljs-property">length</span>-<span class="hljs-number">1</span><br>  min = A[j]<br>  pointer = j<br>  <span class="hljs-keyword">for</span> i=j to A.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">if</span> A[i] &lt; min<br>      min = A[i]<br>      pointer = i<br>  A[pointer] = A[j]<br>  A[j] = min    <br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selection</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> min = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">var</span> pointer = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j++) &#123;<br>    min = arr[j];<br>    pointer = j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = j; i &lt;arr.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;<br>        min = arr[i];<br>        pointer = i;<br>      &#125;<br>    &#125;<br>    arr[pointer] = arr[j];<br>    arr[j] = min;<br>  &#125;  <br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为第n个元素在进过前n-1个循环后一定是最大的，所以不需要对它在进行操作。<br>Θbest &#x3D; Θ(n^2)<br>Θworest &#x3D; <del>Θ(n^3)</del>  Θ(n^2)</p>
<p>2.2-3 再次考虑<em>线性查找</em>问题（参见练习2.1-3）。假定要查找的元素等可能地为数组中的任意元素，平均需要检查的输入序列的多少元素？最坏情况又如何？用Θ记号给出线性查找的平均情况和最坏情况运行时间。证明你的答案<br><strong>平均情况</strong> T(n) &#x3D; 1&#x2F;(n+1) + 2&#x2F;(n+1) + 3&#x2F;(n+1) + … + n&#x2F;(n+1) + n&#x2F;(n+1)  &#x3D; (n^2 + 3n)&#x2F;2(n+1) &#x3D; Θ(n)<br><strong>最坏情况</strong> T(n) &#x3D; Θ(n) </p>
<p>2.3-2 重写过程MERGE，使之不使用哨兵，而是一旦数组L或R的所有元素均被复制回A就立刻停止，然后把两一个数组的剩余部分复制回A</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MERGE2</span>(A, p, q, r)<br>n1 = q - p + <span class="hljs-number">1</span><br>n2 = r - q<br><span class="hljs-keyword">let</span> L[<span class="hljs-number">1.</span>.<span class="hljs-property">n1</span>] and R[<span class="hljs-number">1.</span>. n2] be <span class="hljs-keyword">new</span> arrays<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to n1<br>  L[i] = A[p + i - <span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to n2<br>  R[j] = A[q + j]<br>i = <span class="hljs-number">1</span><br>j = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> k = p to r<br>  <span class="hljs-keyword">if</span> (L[i] &lt;= R[j] or j &gt; n2)<br>    A[k] = L[i]<br>    i = i + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (L[i] &gt; R[j] or i &gt; n1)<br>    A[k] = R[j]<br>    j = j + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">11</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge2</span>(<span class="hljs-params">p, q, r</span>) &#123;<br>  <span class="hljs-keyword">var</span> n1 = q - p + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> n2 = r - q;<br>  <span class="hljs-keyword">var</span> arrL = [];<br>  <span class="hljs-keyword">var</span> arrR = [];<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n1; i++) &#123;<br>    arrL[i] = arr[p + i];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n2; j++) &#123;<br>    arrR[j] = arr[q + j + <span class="hljs-number">1</span>];<br>  &#125;<br>  i = <span class="hljs-number">0</span>;<br>  j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (k = p; k &lt; r + <span class="hljs-number">1</span>; k++) &#123;<br>    <span class="hljs-keyword">if</span> (arrL[i] &lt;= arrR[j] || j &gt;= n2) &#123;<br>      arr[k] = arrL[i];<br>      i = i + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arrL[i] &gt; arrR[j] || i &gt;= n1) &#123;<br>      arr[k] = arrR[j];<br>      j = j + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">p, r</span>) &#123;<br>  <span class="hljs-keyword">var</span> mid = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (p &lt; r) &#123;<br>    mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((p + r)/<span class="hljs-number">2</span>);<br>    <span class="hljs-title function_">merge_sort</span>(p, mid);<br>    <span class="hljs-title function_">merge_sort</span>(mid+<span class="hljs-number">1</span>, r);<br>    <span class="hljs-title function_">merge2</span>(p, mid, r);<br>  &#125;<br>&#125;<br><span class="hljs-title function_">merge_sort</span>(<span class="hljs-number">0</span>, arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br></code></pre></td></tr></table></figure>

<p>2.3-4 我们可以把插入排序表示为如下的一个递归过程。为了排序A[1..n]，我们递归地排序A[1..n-1]，然后把A[n]插入到已排序的数组A[1..n-1]。为插入排序的这个递归版本的最坏情况运行时间写一个递归式<br>如果n &#x3D; 1，T(1) &#x3D; 1；<br>如果n &gt; 1，将A[n]插入A[1..n-1]需要比进行n-1次比较，所以 T(n) &#x3D; T(n-1) + c(n-1)  </p>
<p>2.3-5 回顾<em>线性查找</em>问题，注意到，如果序列A已排好序，就可以将该序列的中点与v进行比较。根据比较的结果，原序列中有一半就可以不用再做进一步的考虑了。<em>二分查找算法</em>重复这个过程，每次都将序列剩余部分的规模减半。为二分查找写出迭代或递归的伪代码。证明：二分查找的最坏运行时间为Θ(lgn)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">BINARY</span>-<span class="hljs-title function_">SEARCH</span>(A, key)<br>start = <span class="hljs-number">1</span><br>end = A.<span class="hljs-property">length</span><br><span class="hljs-keyword">while</span> (start &lt;= end)<br>  i = └(start + end) / <span class="hljs-number">2</span>┘<br>  <span class="hljs-keyword">if</span> (A[i] == key)<br>    <span class="hljs-keyword">return</span> i<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[i] &gt; key)<br>    end = i - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[i] &lt; key)<br>    start = i + <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NF&quot;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params">array, key</span>) &#123;<br>  <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>, end = array.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((start + end)/<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (array[i] === key) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[i] &gt; key) &#123;<br>      end = i - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[i] &lt; key) &#123;<br>      start = i + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NF&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果n &#x3D; 1，T(1) &#x3D; 1；<br>如果n &gt; 1, 最差的情况就是比较到最后一位，得出结论，所以T(n)&#x3D;lgn</p>
<p>2.3-6 注意<em>插入排序</em>的第5~7行的while循环采用一种线性查找来（反向）扫描已排好序的子数组A[1..j-1]。我们可以使用<em>二分查找</em>来把插入排序的最坏情况运行总时间改进到Θ(nlgn)吗？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">INSERTION</span>-<span class="hljs-title class_">SORT2</span>(A)<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">2</span> to A.<span class="hljs-property">length</span><br>    newA = A.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>    key = A[i]<br>    answer = <span class="hljs-variable constant_">BINARY</span>-<span class="hljs-title function_">SEARCH</span>(newA, key)<br>    <span class="hljs-keyword">for</span> j=i down to answer<br>      A[j] = A[j-<span class="hljs-number">1</span>]<br>    A[answer] = key<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params">array, key</span>) &#123;<br>  <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>, end = array.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((start + end)/<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (array[i] === key) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[i] &gt; key) &#123;<br>      end = i - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[i] &lt; key) &#123;<br>      start = i + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (start &lt; end)? <span class="hljs-attr">end</span>: start;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertion_sort2</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> new_array = array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, i);<br>    <span class="hljs-keyword">var</span> key = array[i];<br>    <span class="hljs-keyword">var</span> answer = <span class="hljs-title function_">binary_search</span>(new_array, key);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = i; j &gt; answer; j--) &#123;<br>      array[j] = array[j-<span class="hljs-number">1</span>];<br>    &#125;<br>    array[answer] = key;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2.3-7 描述一个运行时间为Θ(nlgn)的算法，给定n个整数的集合S和另一个整数x，该算法能确定S中是否存在两个其和刚好为x的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">determineSumX</span>(<span class="hljs-params">array, x</span>) &#123;<br>  <span class="hljs-keyword">var</span> filtered = array.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">return</span> e&lt;x;<br>  &#125;);<br>  <span class="hljs-keyword">var</span> sorted = <span class="hljs-title function_">insertion_sort2</span>(filtered);<br>  <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>, end = sorted.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(start &lt; end) &#123;<br>    <span class="hljs-keyword">if</span> (sorted[start] + sorted[end] === x) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sorted[start] + sorted[end] &lt; x) &#123;<br>      start = start + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sorted[start] + sorted[end] &gt; x) &#123;<br>      end = end - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params">array, key</span>) &#123;<br>  <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>, end = array.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>    i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((start + end)/<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (array[i] === key) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[i] &gt; key) &#123;<br>      end = i - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[i] &lt; key) &#123;<br>      start = i + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (start &lt; end)? <span class="hljs-attr">end</span>: start;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertion_sort2</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> new_array = array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, i);<br>    <span class="hljs-keyword">var</span> key = array[i];<br>    <span class="hljs-keyword">var</span> answer = <span class="hljs-title function_">binary_search</span>(new_array, key);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = i; j &gt; answer; j--) &#123;<br>      array[j] = array[j-<span class="hljs-number">1</span>];<br>    &#125;<br>    array[answer] = key;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>2.1 （在归并排序中对小数组采用插入排序）虽然归并排序的最坏情况运行时间为Θ(nlgn)，而插入排序的最坏运行时间为Θ(n^2)，但是插入牌组中的常量因子可能使得它在n较小时，在许多机器上实际运行得更快。因此，在归并排序中，当子问题变得足够小时，采用插入排序来使递归的叶变粗是有意义的。考虑对归并排序的一种修改，其中使用插入排序来排序长度为k的n&#x2F;k个子表，然后使用标准的合并机制来合并这些子表，这里k是一个待定的值。<br>a. 证明：插入排序最坏的情况可以在Θ(nk)时间内排序每个长度为k的n&#x2F;k个子表。<br>b. 表明在最坏的情况下如何在Θ(nlg(n&#x2F;k))时间内合并这些子表。<br>c. 假定修改后的算法的最坏情况运行时间为Θ(nk+nlg(n&#x2F;k))，要使修改后的算法与标准的归并排序具有相同的运行时间，作为n的一个函数，借助Θ记号，k的最大值是什么？<br>d. 在实践中，我们应该如何选择k？<br>a. 因为插入排序的最坏运行时间为Θ(n^2)，所以对于长度为k的1个子表，最坏运行时间为Θ(k^2)；<br>又因为一共有n&#x2F;k个子表，所以，最坏运行时间为(n&#x2F;k)*Θ(k^2) &#x3D; Θ(nk)。<br>b. 由结果递归树可得，最小的叶子节点为cn&#x2F;k，共有k个叶子节点，所以树的高度为lg(n&#x2F;k)，又每层将贡献总代价cn，所以，总代价为cn(lg(n&#x2F;k)+1)，也就是Θ(nlog(n&#x2F;k))。<br>c. Θ(nk + nlg(n&#x2F;k)) &#x3D; Θ(nlgn)，&#x3D;&gt;Θ(k+lg(n&#x2F;k)) &#x3D; Θ(lgn)，所以k&lt;lgn，k的最大值应该是lgn。<br>d. <em>这是个实验问题，应该在k的合法范围内测试可能的k，用T-INSERTION-SORT(k)表示k个元素的插入排序时间，T-MERGE-SORT(k)表示k个元素的合并排序时间。该问题等价于测试求解T-INSERTION-SORT(k)&#x2F;T-MERGE-SORT(k)比值最小的k值。</em></p>
<p>2.2 （冒泡排序算法的正确性）<em>冒泡排序</em>算法是一种流行但低效的排序算法，它的作用是反复交换相邻的未按次序排列的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">BUBBLESORT</span>(A)<br><span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to A.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br><span class="hljs-number">2</span>   <span class="hljs-keyword">for</span> j = A.<span class="hljs-property">length</span> downto i + <span class="hljs-number">1</span><br><span class="hljs-number">3</span>     <span class="hljs-keyword">if</span> A[j] &lt; A[j-<span class="hljs-number">1</span>]<br><span class="hljs-number">4</span>       exchange A[j] <span class="hljs-keyword">with</span> A[j-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<p>a. 假设A′表示BUBBLESORT(A)的输出。为了证明BUBBLESORT正确，我们必须证明它将终止并且有：<br>            A’[1] ≤ A’[2] ≤ … ≤ A’[n]                           (2.3)<br>其中 n&#x3D;A.length。为了证明BUBBLESORT确实完成了排序我们还需要证明什么？<br>下面两个部分将证明不等式（2.3）。<br>b. 为第2<del>4行的for循环精确地说明一个循环不变式，并证明该循环不变式成立。你的证明应该使用本章中给出的循环不变式证明的结构。<br>c. 利用在(b)部分证明的循环不变式的终止条件，为第1</del>4行的for循环说明一个循环不变式，它可以用来证明不等式(2.3)。你的证明应采用本章中给出的循环不变式的证明结构。<br>d. 冒泡排序算法的最坏情况运行时间是多少？与插入排序的运行时间相比，其性能如何？<br>a. 当n&#x3D;1时，能够正确排序。<br>b. 对第2<del>4行的for循环，循环不变式是A[j]是子数组A[j…n]中的最小值，且子数组中的元素并未改变。约定：n&#x3D;A.length。<br>初始化：开始时，j&#x3D;n，子数组中只包含A[n]，故循环不变式成立<br>保持：假设对于任意的一个j，使得A[j]是子数组A[j…n]中的最小值，在下一轮循环中，若A[j] &lt; A[j-1]，则A[j]和A[j-1]交换。使得A[j-1]是子数组A[j-1…n]中的最小值，循环不变式依然成立<br>终止：循环结束时j&#x3D;i，A[j]是子数组A[j…n]中的最小值，且子数组中的元素并未改变。<br>c. 对于1</del>4行的for循环，循环不变式是每次循环前，A[1…i-1]中包含了整个数组中前i-1小的排好序的元素，而A[i…n]中包含剩下的元素。 <br>初始化：第一次循环前i&#x3D;1，子数组为空，循环不变式成立<br>保持：假设对于任意一个i，使得A[1…i-1]中包含了整个数组中前i-1小的排好序的元素，而A[i…n]中包含剩下的元素，则内层循环保证了A[i]是子数组A[i…n]中的最小元素，则A[1…i]中包含了整个数组中前i小的排好序的元素，而A[i+1…n]中包含剩下的元素。循环不变式成立<br>终止：循环结束时i&#x3D;n+1，则A[1…n]中包含了整个数组中前n小的排好序的元素，即数组有序。<br>d. 冒泡排序最坏和最好运行时间均为Θ(n^2)<br>插入排序的最坏运行时间为Θ(n^2)，但是最好运行时间为Θ(n)<br>排序前A所有元素已经有序时，插入排序达到最好运行时间。  </p>
<p>2.3 （霍纳(Horner)规则的正确性）给定系数a0, a1, …, an和x的值，代码片段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1　y = 0<br>2　for i = n downto 0<br>3　　　y = ai + x·y<br></code></pre></td></tr></table></figure>
<p>实现了用于求值多项式<br><img src="http://upload-images.jianshu.io/upload_images/916567-8a4207f83a46e6a3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"> <br>的霍纳规则。<br>a. 借助Θ记号，实现霍纳规则的以上代码片段的运行时间是多少？<br>b. 编写伪代码来实现朴素的多项式求值算法，该算法从头开始计算多项式的每个项。该算法的运行时间是多少？与霍纳规则相比，其性能如何？<br>c. 考虑以下循环不变式：<br>在第2～3行for循环每次迭代的开始有<img src="http://upload-images.jianshu.io/upload_images/916567-c916945818cbbd02.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"> 把没有项的和式解释为等于0。遵照本章中给出的循环不变式证明的结构，使用该循环不变式来证明终止时有<img src="http://upload-images.jianshu.io/upload_images/916567-36a22821ffb8a3d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>d. 最后证明上面给出的代码片段将正确地求由系数a0, a1, …, an刻画的多项式的值。<br>Answer:<br>a. Θ(n)<br>b. 伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">MERGE</span>(A, p, q, r)<br>n1 = q - p + <span class="hljs-number">1</span><br>n2 = r - q<br><span class="hljs-title class_">Let</span> L[<span class="hljs-number">1.</span>.<span class="hljs-property">n1</span>+<span class="hljs-number">1</span>] and R[<span class="hljs-number">1.</span>.<span class="hljs-property">n2</span>+<span class="hljs-number">1</span>] be <span class="hljs-keyword">new</span> arrays<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to n1<br>    L[i] = A[p + i - <span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to n2<br>    R[j] = A[q+j]<br><span class="hljs-comment">//插入哨兵牌</span><br>L[n1 + <span class="hljs-number">1</span>] = ∞<br>R[n2 + <span class="hljs-number">1</span>] = ∞<br>i = <span class="hljs-number">1</span><br>j = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> k = p to r<br>    <span class="hljs-keyword">if</span> L[i] &lt;= R[j]<br>        A[k] = L[i]<br>        i = i + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span> A[k] = R[j]<br>        j = j + <span class="hljs-number">1</span><br>        count = count + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Reflection on an Internal Interview</title>
    <url>/thinking/reflection-on-an-internal-interview/</url>
    <content><![CDATA[<p>An internal interview</p>
<p>Q1. Three reasons why we should hire you?<br>A1. </p>
<ol>
<li>I want to gain a great vision for the further, which is important to my product as well as the company, starting from having diversive experience.</li>
<li>I can help the program in some ways. First, I like to observe things and reflection on them. Maybe during the experience, can find places to improve. Moreover, I can help you promote this program especially in China. I have the experience in filming SAP customer stories, which was a branding news.</li>
<li>I am qualified. I have been working at SAP for 3 years as software engineer.</li>
</ol>
<p>Q2: One reason why we should not hire you?<br>A2: It depends on your standards for the admission. If I am not qualified or not match well with you options, it is ok not to admit me, which also saves time for me.</p>
<p>Q3: Why are you nervious?<br>A3: It does not match my expactations because it was described as informal and casual like a conversation, but now it is a real interview. Another reason is that I am not so confidence about the English interview. I am trying to imporve it as well. I am attening some public speaking programs and practicing it.</p>
<p>Talking about hobbies.</p>
<p>Q4: Do you like the conversation now?<br>A4: It is not about the content but the way we are doing the talk. I am expecting responses and interactions from the conversation. But interview, it is just one employees with questions and one interviewer brought answers.</p>
<p>Q5: Please state one bad thing that you observated from the work.<br>A5: The work process is too heavy and complicated, making our work not agile enough. But I need not think a better way to make it organizated and simple.<br>Q6: Why? Did you notice how other big companies deliver their products in a efficient way?<br>A6: No. I think every company has its pros and cons. The knowledge how other companies or groups are doing the developing and delivering is what I expacted from this program. Hope I can find a better way in your esteemed program. I know this program can bring me to Sicon Villiage where I can have a close look at other big companies and learn a lot from it.</p>
<p>Q7: What is you github account? Why do you hestitate on this question?<br>A7: 29Esther. Because it is a private thing. Internet are interesting in some way because you do not know who is who.</p>
<p>Q8: Any questions?<br>A8: </p>
<ol>
<li>How do you value the plum test result? – I am asking this because I hope you can consider the potential qualities in each person and form a strong team to be really agile and play scrum games.</li>
<li>How is you lunch? – Hope you are having a nice day and a good conversation with me. So it is great for my interview.</li>
<li>How do you value a player? I mean the weight of tests and interviews. What do you value most from a candidate?</li>
</ol>
<hr>
<p>Learning Points:</p>
<ol>
<li>Always aim at the target</li>
<li>List you USP (unique selling point) and high light points during preparation</li>
<li>Step out of the question itself and look at the question in a higher level or in the shoes of the interviewers.</li>
<li>Do not need to answer all the questions in a good manner. You just need 3 impressive points.</li>
<li>Try to lead the conversation as much as you can, do not be leaded and trapped.</li>
</ol>
]]></content>
      <categories>
        <category>writing</category>
      </categories>
      <tags>
        <tag>Thinking</tag>
      </tags>
  </entry>
</search>
